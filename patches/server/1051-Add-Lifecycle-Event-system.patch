From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Tue, 18 Jul 2023 17:49:38 -0700
Subject: [PATCH] Add Lifecycle Event system

This event system is separate from Bukkit's event system and is
meant for managing resources across reloads and from points in the
PluginBootstrap.

diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
index 30b50e6294c6eaade5e17cfaf34600d122e6251c..0bb7694188d5fb75bb756ce75d0060ea980027ee 100644
--- a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
@@ -1,6 +1,8 @@
 package io.papermc.paper.plugin.bootstrap;
 
 import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import io.papermc.paper.plugin.lifecycle.event.PaperLifecycleEventManager;
 import io.papermc.paper.plugin.provider.PluginProvider;
 import java.nio.file.Path;
 import net.kyori.adventure.text.logger.slf4j.ComponentLogger;
@@ -12,6 +14,10 @@ public final class PluginBootstrapContextImpl implements BootstrapContext {
     private final Path dataFolder;
     private final ComponentLogger logger;
     private final Path pluginSource;
+    // Paper start - lifecycle events
+    private boolean allowsLifecycleRegistration = true;
+    private final PaperLifecycleEventManager<BootstrapContext> lifecycleEventManager = new PaperLifecycleEventManager<>(this, () -> this.allowsLifecycleRegistration); // Paper - lifecycle events
+    // Paper end - lifecycle events
 
     public PluginBootstrapContextImpl(PluginMeta config, Path dataFolder, ComponentLogger logger, Path pluginSource) {
         this.config = config;
@@ -45,4 +51,20 @@ public final class PluginBootstrapContextImpl implements BootstrapContext {
     public @NotNull Path getPluginSource() {
         return this.pluginSource;
     }
+
+    // Paper start - lifecycle event system
+    @Override
+    public @NotNull PluginMeta getPluginMeta() {
+        return this.config;
+    }
+
+    @Override
+    public LifecycleEventManager<BootstrapContext> getLifecycleManager() {
+        return this.lifecycleEventManager;
+    }
+
+    public void lockLifecycleEventRegistration() {
+        this.allowsLifecycleRegistration = false;
+    }
+    // Paper end
 }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
new file mode 100644
index 0000000000000000000000000000000000000000..f2190599dda61840969045f6ea9237678faccec4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
@@ -0,0 +1,62 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.registrar.Registrar;
+import io.papermc.paper.plugin.lifecycle.event.registrar.RegistrarEvent;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEventImpl;
+import io.papermc.paper.plugin.lifecycle.event.registrar.StaticRegistrarEventImpl;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import java.util.ArrayList;
+import java.util.List;
+import org.bukkit.plugin.Plugin;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.slf4j.Logger;
+
+@DefaultQualifier(NonNull.class)
+public class LifecycleEventRunner {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+    public static final LifecycleEventRunner INSTANCE = new LifecycleEventRunner();
+
+    private final List<LifecycleEventType<?, ?, ?>> lifecycleEventTypes = new ArrayList<>();
+
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent, ET extends LifecycleEventType<O, E, ?>> ET addEventType(final ET eventType) {
+        this.lifecycleEventTypes.add(eventType);
+        return eventType;
+    }
+
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent> void callEvent(final LifecycleEventType<O, E, ?> eventType, final E event) {
+        final AbstractLifecycleEventType<O, E, ?, ?> lifecycleEventType = (AbstractLifecycleEventType<O, E, ?, ?>) eventType;
+        lifecycleEventType.forEachHandler(registeredHandler -> {
+            try {
+                registeredHandler.lifecycleEventHandler().run(event);
+            } catch (final Throwable ex) {
+                LOGGER.error("Could not run '{}' lifecycle event handler from {}", lifecycleEventType.name(), registeredHandler.owner().getPluginMeta().getDisplayName(), ex);
+            }
+        });
+    }
+
+    public void unregisterAllEventHandlersFor(final Plugin plugin) {
+        for (final LifecycleEventType<?, ?, ?> lifecycleEventType : this.lifecycleEventTypes) {
+            this.removeEventHandlersOwnedBy(lifecycleEventType, plugin);
+        }
+    }
+
+    private <O extends LifecycleEventOwner> void removeEventHandlersOwnedBy(final LifecycleEventType<O, ?, ?> eventType, final Plugin possibleOwner) {
+        final AbstractLifecycleEventType<O, ?, ?, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ?, ?, ?>) eventType;
+        lifecycleEventType.removeMatching(registeredHandler -> registeredHandler.owner().getPluginMeta().getName().equals(possibleOwner.getPluginMeta().getName()));
+    }
+
+    public <O extends LifecycleEventOwner, R extends Registrar> void callStaticRegistrarEvent(final LifecycleEventType<O, RegistrarEvent<R>, ?> lifecycleEventType, final R registrar) {
+        this.callEvent(lifecycleEventType, new StaticRegistrarEventImpl<>(registrar));
+    }
+
+    public <O extends LifecycleEventOwner, R extends Registrar> void callReloadableRegistrarEvent(final LifecycleEventType<O, RegistrarEvent.Reloadable<R>, ?> lifecycleEventType, final R registrar, final RegistrarEvent.Reloadable.Cause cause) {
+        this.callEvent(lifecycleEventType, new ReloadableRegistrarEventImpl<>(registrar, cause));
+    }
+
+    private LifecycleEventRunner() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..da9e334e67086400a7d690941bfd48a7d7331683
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.types.MonitorLifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.types.PrioritizedLifecycleEventType;
+import org.bukkit.plugin.Plugin;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public final class LifecycleEventTypeProviderImpl implements LifecycleEventTypeProvider {
+
+    public static LifecycleEventTypeProviderImpl instance() {
+        return (LifecycleEventTypeProviderImpl) LifecycleEventTypeProvider.PROVIDER;
+    }
+
+    @Override
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Monitor<O, E> monitor(final String name, final Class<? extends O> ownerType) {
+        return LifecycleEventRunner.INSTANCE.addEventType(new MonitorLifecycleEventType<>(name, ownerType));
+    }
+
+    @Override
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Prioritized<O, E> prioritized(final String name, final Class<? extends O> ownerType) {
+        return LifecycleEventRunner.INSTANCE.addEventType(new PrioritizedLifecycleEventType<>(name, ownerType));
+    }
+
+    @Override
+    public LifecycleEventManager<Plugin> createPluginLifecycleManager(final LifecycleEventOwner.PluginOwner plugin) {
+        Preconditions.checkArgument(plugin instanceof Plugin, "Can only provide bukkit Plugin instances");
+        return new PaperLifecycleEventManager<>(((Plugin) plugin), plugin::allowingLifecycleEventRegistration);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..f1be5b9a29435bae0afd2bd951bfe88d1669e7eb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.AbstractLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.LifecycleEventHandlerConfiguration;
+import java.util.function.BooleanSupplier;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public final class PaperLifecycleEventManager<O extends LifecycleEventOwner> implements LifecycleEventManager<O> {
+
+    private final O owner;
+    public final BooleanSupplier registrationCheck;
+
+    public PaperLifecycleEventManager(final O owner, final BooleanSupplier registrationCheck) {
+        this.owner = owner;
+        this.registrationCheck = registrationCheck;
+    }
+
+    @Override
+    public void registerEventHandler(final LifecycleEventHandlerConfiguration<? super O> handlerConfiguration) {
+        Preconditions.checkState(this.registrationCheck.getAsBoolean(), "Cannot register lifecycle event handlers");
+        ((AbstractLifecycleEventHandlerConfiguration<? super O, ?, ?>) handlerConfiguration).registerFrom(this.owner);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..06e7fdd7767258c1fa9ab8f021a52fe17c569b58
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public abstract class AbstractLifecycleEventHandlerConfiguration<O extends LifecycleEventOwner, E extends LifecycleEvent, CI extends AbstractLifecycleEventHandlerConfiguration<O, E, CI>> implements LifecycleEventHandlerConfiguration<O> {
+
+    private final LifecycleEventHandler<? super E> handler;
+    private final AbstractLifecycleEventType<O, E, ?, CI> type;
+
+    protected AbstractLifecycleEventHandlerConfiguration(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, CI> type) {
+        this.handler = handler;
+        this.type = type;
+    }
+
+    public abstract CI config();
+
+    public final void registerFrom(final O owner) {
+        this.type.register(owner, this.handler, this.config());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..c08eda17fb718dc62881fb7e7c168ddb9e984282
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class MonitorLifecycleEventHandlerConfigurationImpl<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventHandlerConfiguration<O, E, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> implements MonitorLifecycleEventHandlerConfiguration<O> {
+
+    private boolean monitor = false;
+
+    public MonitorLifecycleEventHandlerConfigurationImpl(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> eventType) {
+        super(handler, eventType);
+    }
+
+    @Override
+    public MonitorLifecycleEventHandlerConfigurationImpl<O, E> config() {
+        return this;
+    }
+
+    public boolean isMonitor() {
+        return this.monitor;
+    }
+
+    @Override
+    public MonitorLifecycleEventHandlerConfiguration<O> monitor() {
+        this.monitor = true;
+        return this;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..7190b3e256f467d586e3610d61f3ae9d2023e147
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java
@@ -0,0 +1,43 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import java.util.OptionalInt;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PrioritizedLifecycleEventHandlerConfigurationImpl<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventHandlerConfiguration<O, E, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> implements PrioritizedLifecycleEventHandlerConfiguration<O> {
+
+    private static final OptionalInt DEFAULT_PRIORITY = OptionalInt.of(0);
+    private static final OptionalInt MONITOR_PRIORITY = OptionalInt.empty();
+
+    private OptionalInt priority = DEFAULT_PRIORITY;
+
+    public PrioritizedLifecycleEventHandlerConfigurationImpl(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> eventType) {
+        super(handler, eventType);
+    }
+
+    @Override
+    public PrioritizedLifecycleEventHandlerConfigurationImpl<O, E> config() {
+        return this;
+    }
+
+    public OptionalInt priority() {
+        return this.priority;
+    }
+
+    @Override
+    public PrioritizedLifecycleEventHandlerConfiguration<O> priority(final int priority) {
+        this.priority = OptionalInt.of(priority);
+        return this;
+    }
+
+    @Override
+    public PrioritizedLifecycleEventHandlerConfiguration<O> monitor() {
+        this.priority = MONITOR_PRIORITY;
+        return this;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..816fbeb379515e56727092a40027f0c0db1a299f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public record ReloadableRegistrarEventImpl<R extends Registrar>(R registrar, Cause cause) implements RegistrarEvent.Reloadable<R> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..bd52f3e00e44f891d09a34c2f55283ac4cefcdc3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public record StaticRegistrarEventImpl<R extends Registrar>(R registrar) implements RegistrarEvent<R> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..01d2629497e362df3baee1ceb359948a3b1b5b3f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.AbstractLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.LifecycleEventHandlerConfiguration;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public abstract class AbstractLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent, C extends LifecycleEventHandlerConfiguration<O>, CI extends AbstractLifecycleEventHandlerConfiguration<O, E, CI>> implements LifecycleEventType<O, E, C> {
+
+    private final String name;
+    private final Class<? extends O> ownerType;
+
+    protected AbstractLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        this.name = name;
+        this.ownerType = ownerType;
+    }
+
+    @Override
+    public String name() {
+        return this.name;
+    }
+
+    protected final void verifyOwner(final O owner) {
+        if (!this.ownerType.isInstance(owner)) {
+            throw new IllegalArgumentException("You cannot register the lifecycle event '" + this.name + "' on " + owner);
+        }
+    }
+
+    public abstract void forEachHandler(Consumer<? super RegisteredHandler<O, E>> consumer);
+
+    public abstract void removeMatching(Predicate<? super RegisteredHandler<O, E>> predicate);
+
+    public abstract void register(final O owner, final LifecycleEventHandler<? super E> handler, CI config);
+
+    public record RegisteredHandler<O, E extends LifecycleEvent>(O owner, LifecycleEventHandler<? super E> lifecycleEventHandler) {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..de5699153853a58dc8ab9252e5dae1f1bf11eb4e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorLifecycleEventType.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfigurationImpl;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class MonitorLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E, MonitorLifecycleEventHandlerConfiguration<O>, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> implements LifecycleEventType.Monitor<O, E> {
+
+    final List<RegisteredHandler<O, E>> handlers = new ArrayList<>();
+    int nonMonitorIdx = 0;
+
+    public MonitorLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        super(name, ownerType);
+    }
+
+    @Override
+    public MonitorLifecycleEventHandlerConfigurationImpl<O, E> handler(final LifecycleEventHandler<? super E> handler) {
+        return new MonitorLifecycleEventHandlerConfigurationImpl<>(handler, this);
+    }
+
+    @Override
+    public void register(final O owner, final LifecycleEventHandler<? super E> handler, final MonitorLifecycleEventHandlerConfigurationImpl<O, E> config) {
+        this.verifyOwner(owner);
+        final RegisteredHandler<O, E> registeredHandler = new RegisteredHandler<>(owner, handler);
+        if (!config.isMonitor()) {
+            this.handlers.add(this.nonMonitorIdx, registeredHandler);
+            this.nonMonitorIdx++;
+        } else {
+            this.handlers.add(registeredHandler);
+        }
+    }
+
+    @Override
+    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer) {
+        for (final RegisteredHandler<O, E> handler : this.handlers) {
+            consumer.accept(handler);
+        }
+    }
+
+    @Override
+    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(predicate);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..75abbd3e6ead8f9ca26d7a1de24a5883d67efbd4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java
@@ -0,0 +1,68 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfigurationImpl;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.OptionalInt;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PrioritizedLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E, PrioritizedLifecycleEventHandlerConfiguration<O>, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> implements LifecycleEventType.Prioritized<O, E> {
+
+    private static final Comparator<PrioritizedHandler<?, ?>> COMPARATOR = Comparator.comparing(PrioritizedHandler::priority, (o1, o2) -> {
+        if (o1.equals(o2)) {
+            return 0;
+        } else if (o1.isEmpty()) {
+            return 1;
+        } else if (o2.isEmpty()) {
+            return -1;
+        } else {
+            return Integer.compare(o1.getAsInt(), o2.getAsInt());
+        }
+    });
+
+    private final List<PrioritizedHandler<O, E>> handlers = new ArrayList<>();
+
+    public PrioritizedLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        super(name, ownerType);
+    }
+
+    @Override
+    public PrioritizedLifecycleEventHandlerConfiguration<O> handler(final LifecycleEventHandler<? super E> handler) {
+        return new PrioritizedLifecycleEventHandlerConfigurationImpl<>(handler, this);
+    }
+
+    @Override
+    public void register(final O owner, final LifecycleEventHandler<? super E> handler, final PrioritizedLifecycleEventHandlerConfigurationImpl<O, E> config) {
+        this.registerWithPriority(owner, handler, config.priority());
+    }
+
+    public void registerWithPriority(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler, final OptionalInt priority) {
+        this.verifyOwner(owner);
+        this.handlers.add(new PrioritizedHandler<>(new RegisteredHandler<>(owner, lifecycleEventHandler), priority));
+        this.handlers.sort(COMPARATOR);
+    }
+
+    @Override
+    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer) {
+        for (final PrioritizedHandler<O, E> handler : this.handlers) {
+            consumer.accept(handler.handler());
+        }
+    }
+
+    @Override
+    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(prioritizedHandler -> predicate.test(prioritizedHandler.handler()));
+    }
+
+    private record PrioritizedHandler<O extends LifecycleEventOwner, E extends LifecycleEvent>(RegisteredHandler<O, E> handler, OptionalInt priority) {}
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
index 9c7552968b8c017c71a7a77557a66a03ed89f125..913a4814b944c73ee1f03b6f209a457e5fbb52df 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
@@ -261,6 +261,15 @@ class PaperPluginInstanceManager {
                 + pluginName + " (Is it up to date?)", ex, plugin); // Paper
         }
 
+        // Paper start - lifecycle event system
+        try {
+            io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.INSTANCE.unregisterAllEventHandlersFor(plugin);
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while unregistering lifecycle event handlers for "
+                + pluginName + " (Is it up to date?)", ex, plugin);
+        }
+        // Paper end
+
         try {
             this.server.getMessenger().unregisterIncomingPluginChannel(plugin);
             this.server.getMessenger().unregisterOutgoingPluginChannel(plugin);
diff --git a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
index 8ef13e4f00a61db0dab9ef63231d77adcfaba5ab..79ec67dd6dc71f83e23f722811369723c155195d 100644
--- a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
@@ -30,8 +30,9 @@ public class BootstrapProviderStorage extends SimpleProviderStorage<PluginBootst
             @Override
             public boolean load(PluginProvider<PluginBootstrap> provider, PluginBootstrap provided) {
                 try {
-                    BootstrapContext context = PluginBootstrapContextImpl.create(provider, PluginInitializerManager.instance().pluginDirectoryPath());
+                    PluginBootstrapContextImpl context = PluginBootstrapContextImpl.create(provider, PluginInitializerManager.instance().pluginDirectoryPath()); // Paper - lifecycle events
                     provided.bootstrap(context);
+                    context.lockLifecycleEventRegistration(); // Paper - lifecycle events
                     return true;
                 } catch (Throwable e) {
                     LOGGER.error("Failed to run bootstrapper for %s. This plugin will not be loaded.".formatted(provider.getSource()), e);
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
index d96399e9bf1a58db5a4a22e58abb99e7660e0694..b3a9824eda7edef21f778b4255a31808fc0739f5 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
@@ -143,4 +143,11 @@ public class MinecraftInternalPlugin extends PluginBase {
     public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
         throw new UnsupportedOperationException("Not supported.");
     }
+
+    // Paper start - lifecycle events
+    @Override
+    public boolean allowingLifecycleEventRegistration() {
+        return false;
+    }
+    // Paper end - lifecycle events
 }
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider b/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider
new file mode 100644
index 0000000000000000000000000000000000000000..c647fd9cef4f82b6ef17a942c208cc37bf5e99c2
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider
@@ -0,0 +1 @@
+io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProviderImpl
diff --git a/src/test/java/io/papermc/paper/plugin/PaperTestPlugin.java b/src/test/java/io/papermc/paper/plugin/PaperTestPlugin.java
index 1d14f530ef888102e47eeeaf0d1a6076e51871c4..dbd4b36b3abacdad1eea729b94d46847c27e3461 100644
--- a/src/test/java/io/papermc/paper/plugin/PaperTestPlugin.java
+++ b/src/test/java/io/papermc/paper/plugin/PaperTestPlugin.java
@@ -143,4 +143,11 @@ public class PaperTestPlugin extends PluginBase {
     public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
         throw new UnsupportedOperationException("Not supported.");
     }
+
+    // Paper start - lifecycle events
+    @Override
+    public boolean allowingLifecycleEventRegistration() {
+        return false;
+    }
+    // Paper end - lifecycle events
 }
