From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Initial <auto@mated.null>
Date: Fri, 25 Jun 2021 01:03:18 -0500
Subject: [PATCH] McDev imports


diff --git a/src/main/java/com/mojang/authlib/yggdrasil/YggdrasilGameProfileRepository.java b/src/main/java/com/mojang/authlib/yggdrasil/YggdrasilGameProfileRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..a3ab666b5fa89aad7ee167d9aeff2f62019a4a78
--- /dev/null
+++ b/src/main/java/com/mojang/authlib/yggdrasil/YggdrasilGameProfileRepository.java
@@ -0,0 +1,95 @@
+package com.mojang.authlib.yggdrasil;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import com.mojang.authlib.Agent;
+import com.mojang.authlib.Environment;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.HttpAuthenticationService;
+import com.mojang.authlib.ProfileLookupCallback;
+import com.mojang.authlib.exceptions.AuthenticationException;
+import com.mojang.authlib.yggdrasil.response.ProfileSearchResultsResponse;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.List;
+import java.util.Set;
+
+public class YggdrasilGameProfileRepository implements GameProfileRepository {
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final String searchPageUrl;
+    private static final int ENTRIES_PER_PAGE = 2;
+    private static final int MAX_FAIL_COUNT = 3;
+    private static final int DELAY_BETWEEN_PAGES = 100;
+    private static final int DELAY_BETWEEN_FAILURES = 750;
+
+    private final YggdrasilAuthenticationService authenticationService;
+
+    public YggdrasilGameProfileRepository(final YggdrasilAuthenticationService authenticationService, final Environment environment) {
+        this.authenticationService = authenticationService;
+        searchPageUrl = environment.getAccountsHost() + "/profiles/";
+    }
+
+    @Override
+    public void findProfilesByNames(final String[] names, final Agent agent, final ProfileLookupCallback callback) {
+        final Set<String> criteria = Sets.newHashSet();
+
+        for (final String name : names) {
+            if (!Strings.isNullOrEmpty(name)) {
+                criteria.add(name.toLowerCase());
+            }
+        }
+
+        final int page = 0;
+
+        for (final List<String> request : Iterables.partition(criteria, ENTRIES_PER_PAGE)) {
+            int failCount = 0;
+            boolean failed;
+
+            do {
+                failed = false;
+
+                try {
+                    final ProfileSearchResultsResponse response = authenticationService.makeRequest(HttpAuthenticationService.constantURL(searchPageUrl + agent.getName().toLowerCase()), request, ProfileSearchResultsResponse.class);
+                    failCount = 0;
+
+                    LOGGER.debug("Page {} returned {} results, parsing", page, response.getProfiles().length);
+
+                    final Set<String> missing = Sets.newHashSet(request);
+                    for (final GameProfile profile : response.getProfiles()) {
+                        LOGGER.debug("Successfully looked up profile {}", profile);
+                        missing.remove(profile.getName().toLowerCase());
+                        callback.onProfileLookupSucceeded(profile);
+                    }
+
+                    for (final String name : missing) {
+                        LOGGER.debug("Couldn't find profile {}", name);
+                        callback.onProfileLookupFailed(new GameProfile(null, name), new ProfileNotFoundException("Server did not find the requested profile"));
+                    }
+
+                    try {
+                        Thread.sleep(DELAY_BETWEEN_PAGES);
+                    } catch (final InterruptedException ignored) {
+                    }
+                } catch (final AuthenticationException e) {
+                    failCount++;
+
+                    if (failCount == MAX_FAIL_COUNT) {
+                        for (final String name : request) {
+                            LOGGER.debug("Couldn't find profile {} because of a server error", name);
+                            callback.onProfileLookupFailed(new GameProfile(null, name), e);
+                        }
+                    } else {
+                        try {
+                            Thread.sleep(DELAY_BETWEEN_FAILURES);
+                        } catch (final InterruptedException ignored) {
+                        }
+                        failed = true;
+                    }
+                }
+            } while (failed);
+        }
+    }
+}
diff --git a/src/main/java/com/mojang/brigadier/CommandDispatcher.java b/src/main/java/com/mojang/brigadier/CommandDispatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..103576715ef6ae4df4b216ae9ae31b6fb1086bd5
--- /dev/null
+++ b/src/main/java/com/mojang/brigadier/CommandDispatcher.java
@@ -0,0 +1,705 @@
+// Copyright (c) Microsoft Corporation. All rights reserved.
+// Licensed under the MIT license.
+
+package com.mojang.brigadier;
+
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.context.CommandContextBuilder;
+import com.mojang.brigadier.context.SuggestionContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import com.mojang.brigadier.tree.RootCommandNode;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
+
+/**
+ * The core command dispatcher, for registering, parsing, and executing commands.
+ *
+ * @param <S> a custom "source" type, such as a user or originator of a command
+ */
+public class CommandDispatcher<S> {
+    /**
+     * The string required to separate individual arguments in an input string
+     *
+     * @see #ARGUMENT_SEPARATOR_CHAR
+     */
+    public static final String ARGUMENT_SEPARATOR = " ";
+
+    /**
+     * The char required to separate individual arguments in an input string
+     *
+     * @see #ARGUMENT_SEPARATOR
+     */
+    public static final char ARGUMENT_SEPARATOR_CHAR = ' ';
+
+    private static final String USAGE_OPTIONAL_OPEN = "[";
+    private static final String USAGE_OPTIONAL_CLOSE = "]";
+    private static final String USAGE_REQUIRED_OPEN = "(";
+    private static final String USAGE_REQUIRED_CLOSE = ")";
+    private static final String USAGE_OR = "|";
+
+    private final RootCommandNode<S> root;
+
+    private final Predicate<CommandNode<S>> hasCommand = new Predicate<CommandNode<S>>() {
+        @Override
+        public boolean test(final CommandNode<S> input) {
+            return input != null && (input.getCommand() != null || input.getChildren().stream().anyMatch(hasCommand));
+        }
+    };
+    private ResultConsumer<S> consumer = (c, s, r) -> {
+    };
+
+    /**
+     * Create a new {@link CommandDispatcher} with the specified root node.
+     *
+     * <p>This is often useful to copy existing or pre-defined command trees.</p>
+     *
+     * @param root the existing {@link RootCommandNode} to use as the basis for this tree
+     */
+    public CommandDispatcher(final RootCommandNode<S> root) {
+        this.root = root;
+    }
+
+    /**
+     * Creates a new {@link CommandDispatcher} with an empty command tree.
+     */
+    public CommandDispatcher() {
+        this(new RootCommandNode<>());
+    }
+
+    /**
+     * Utility method for registering new commands.
+     *
+     * <p>This is a shortcut for calling {@link RootCommandNode#addChild(CommandNode)} after building the provided {@code command}.</p>
+     *
+     * <p>As {@link RootCommandNode} can only hold literals, this method will only allow literal arguments.</p>
+     *
+     * @param command a literal argument builder to add to this command tree
+     * @return the node added to this tree
+     */
+    public LiteralCommandNode<S> register(final LiteralArgumentBuilder<S> command) {
+        final LiteralCommandNode<S> build = command.build();
+        root.addChild(build);
+        return build;
+    }
+
+    /**
+     * Sets a callback to be informed of the result of every command.
+     *
+     * @param consumer the new result consumer to be called
+     */
+    public void setConsumer(final ResultConsumer<S> consumer) {
+        this.consumer = consumer;
+    }
+
+    /**
+     * Parses and executes a given command.
+     *
+     * <p>This is a shortcut to first {@link #parse(StringReader, Object)} and then {@link #execute(ParseResults)}.</p>
+     *
+     * <p>It is recommended to parse and execute as separate steps, as parsing is often the most expensive step, and easiest to cache.</p>
+     *
+     * <p>If this command returns a value, then it successfully executed something. If it could not parse the command, or the execution was a failure,
+     * then an exception will be thrown. Most exceptions will be of type {@link CommandSyntaxException}, but it is possible that a {@link RuntimeException}
+     * may bubble up from the result of a command. The meaning behind the returned result is arbitrary, and will depend
+     * entirely on what command was performed.</p>
+     *
+     * <p>If the command passes through a node that is {@link CommandNode#isFork()} then it will be 'forked'.
+     * A forked command will not bubble up any {@link CommandSyntaxException}s, and the 'result' returned will turn into
+     * 'amount of successful commands executes'.</p>
+     *
+     * <p>After each and any command is ran, a registered callback given to {@link #setConsumer(ResultConsumer)}
+     * will be notified of the result and success of the command. You can use that method to gather more meaningful
+     * results than this method will return, especially when a command forks.</p>
+     *
+     * @param input a command string to parse &amp; execute
+     * @param source a custom "source" object, usually representing the originator of this command
+     * @return a numeric result from a "command" that was performed
+     * @throws CommandSyntaxException if the command failed to parse or execute
+     * @throws RuntimeException if the command failed to execute and was not handled gracefully
+     * @see #parse(String, Object)
+     * @see #parse(StringReader, Object)
+     * @see #execute(ParseResults)
+     * @see #execute(StringReader, Object)
+     */
+    public int execute(final String input, final S source) throws CommandSyntaxException {
+        return execute(new StringReader(input), source);
+    }
+
+    /**
+     * Parses and executes a given command.
+     *
+     * <p>This is a shortcut to first {@link #parse(StringReader, Object)} and then {@link #execute(ParseResults)}.</p>
+     *
+     * <p>It is recommended to parse and execute as separate steps, as parsing is often the most expensive step, and easiest to cache.</p>
+     *
+     * <p>If this command returns a value, then it successfully executed something. If it could not parse the command, or the execution was a failure,
+     * then an exception will be thrown. Most exceptions will be of type {@link CommandSyntaxException}, but it is possible that a {@link RuntimeException}
+     * may bubble up from the result of a command. The meaning behind the returned result is arbitrary, and will depend
+     * entirely on what command was performed.</p>
+     *
+     * <p>If the command passes through a node that is {@link CommandNode#isFork()} then it will be 'forked'.
+     * A forked command will not bubble up any {@link CommandSyntaxException}s, and the 'result' returned will turn into
+     * 'amount of successful commands executes'.</p>
+     *
+     * <p>After each and any command is ran, a registered callback given to {@link #setConsumer(ResultConsumer)}
+     * will be notified of the result and success of the command. You can use that method to gather more meaningful
+     * results than this method will return, especially when a command forks.</p>
+     *
+     * @param input a command string to parse &amp; execute
+     * @param source a custom "source" object, usually representing the originator of this command
+     * @return a numeric result from a "command" that was performed
+     * @throws CommandSyntaxException if the command failed to parse or execute
+     * @throws RuntimeException if the command failed to execute and was not handled gracefully
+     * @see #parse(String, Object)
+     * @see #parse(StringReader, Object)
+     * @see #execute(ParseResults)
+     * @see #execute(String, Object)
+     */
+    public int execute(final StringReader input, final S source) throws CommandSyntaxException {
+        final ParseResults<S> parse = parse(input, source);
+        return execute(parse);
+    }
+
+    /**
+     * Executes a given pre-parsed command.
+     *
+     * <p>If this command returns a value, then it successfully executed something. If the execution was a failure,
+     * then an exception will be thrown.
+     * Most exceptions will be of type {@link CommandSyntaxException}, but it is possible that a {@link RuntimeException}
+     * may bubble up from the result of a command. The meaning behind the returned result is arbitrary, and will depend
+     * entirely on what command was performed.</p>
+     *
+     * <p>If the command passes through a node that is {@link CommandNode#isFork()} then it will be 'forked'.
+     * A forked command will not bubble up any {@link CommandSyntaxException}s, and the 'result' returned will turn into
+     * 'amount of successful commands executes'.</p>
+     *
+     * <p>After each and any command is ran, a registered callback given to {@link #setConsumer(ResultConsumer)}
+     * will be notified of the result and success of the command. You can use that method to gather more meaningful
+     * results than this method will return, especially when a command forks.</p>
+     *
+     * @param parse the result of a successful {@link #parse(StringReader, Object)}
+     * @return a numeric result from a "command" that was performed.
+     * @throws CommandSyntaxException if the command failed to parse or execute
+     * @throws RuntimeException if the command failed to execute and was not handled gracefully
+     * @see #parse(String, Object)
+     * @see #parse(StringReader, Object)
+     * @see #execute(String, Object)
+     * @see #execute(StringReader, Object)
+     */
+    public int execute(final ParseResults<S> parse) throws CommandSyntaxException {
+        if (parse.getReader().canRead()) {
+            if (parse.getExceptions().size() == 1) {
+                throw parse.getExceptions().values().iterator().next();
+            } else if (parse.getContext().getRange().isEmpty()) {
+                throw CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(parse.getReader());
+            } else {
+                throw CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownArgument().createWithContext(parse.getReader());
+            }
+        }
+
+        int result = 0;
+        int successfulForks = 0;
+        boolean forked = false;
+        boolean foundCommand = false;
+        final String command = parse.getReader().getString();
+        final CommandContext<S> original = parse.getContext().build(command);
+        List<CommandContext<S>> contexts = Collections.singletonList(original);
+        ArrayList<CommandContext<S>> next = null;
+
+        while (contexts != null) {
+            final int size = contexts.size();
+            for (int i = 0; i < size; i++) {
+                final CommandContext<S> context = contexts.get(i);
+                final CommandContext<S> child = context.getChild();
+                if (child != null) {
+                    forked |= context.isForked();
+                    if (child.hasNodes()) {
+                        foundCommand = true;
+                        final RedirectModifier<S> modifier = context.getRedirectModifier();
+                        if (modifier == null) {
+                            if (next == null) {
+                                next = new ArrayList<>(1);
+                            }
+                            next.add(child.copyFor(context.getSource()));
+                        } else {
+                            try {
+                                final Collection<S> results = modifier.apply(context);
+                                if (!results.isEmpty()) {
+                                    if (next == null) {
+                                        next = new ArrayList<>(results.size());
+                                    }
+                                    for (final S source : results) {
+                                        next.add(child.copyFor(source));
+                                    }
+                                }
+                            } catch (final CommandSyntaxException ex) {
+                                consumer.onCommandComplete(context, false, 0);
+                                if (!forked) {
+                                    throw ex;
+                                }
+                            }
+                        }
+                    }
+                } else if (context.getCommand() != null) {
+                    foundCommand = true;
+                    try {
+                        final int value = context.getCommand().run(context);
+                        result += value;
+                        consumer.onCommandComplete(context, true, value);
+                        successfulForks++;
+                    } catch (final CommandSyntaxException ex) {
+                        consumer.onCommandComplete(context, false, 0);
+                        if (!forked) {
+                            throw ex;
+                        }
+                    }
+                }
+            }
+
+            contexts = next;
+            next = null;
+        }
+
+        if (!foundCommand) {
+            consumer.onCommandComplete(original, false, 0);
+            throw CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(parse.getReader());
+        }
+
+        return forked ? successfulForks : result;
+    }
+
+    /**
+     * Parses a given command.
+     *
+     * <p>The result of this method can be cached, and it is advised to do so where appropriate. Parsing is often the
+     * most expensive step, and this allows you to essentially "precompile" a command if it will be ran often.</p>
+     *
+     * <p>If the command passes through a node that is {@link CommandNode#isFork()} then the resulting context will be marked as 'forked'.
+     * Forked contexts may contain child contexts, which may be modified by the {@link RedirectModifier} attached to the fork.</p>
+     *
+     * <p>Parsing a command can never fail, you will always be provided with a new {@link ParseResults}.
+     * However, that does not mean that it will always parse into a valid command. You should inspect the returned results
+     * to check for validity. If its {@link ParseResults#getReader()} {@link StringReader#canRead()} then it did not finish
+     * parsing successfully. You can use that position as an indicator to the user where the command stopped being valid.
+     * You may inspect {@link ParseResults#getExceptions()} if you know the parse failed, as it will explain why it could
+     * not find any valid commands. It may contain multiple exceptions, one for each "potential node" that it could have visited,
+     * explaining why it did not go down that node.</p>
+     *
+     * <p>When you eventually call {@link #execute(ParseResults)} with the result of this method, the above error checking
+     * will occur. You only need to inspect it yourself if you wish to handle that yourself.</p>
+     *
+     * @param command a command string to parse
+     * @param source a custom "source" object, usually representing the originator of this command
+     * @return the result of parsing this command
+     * @see #parse(StringReader, Object)
+     * @see #execute(ParseResults)
+     * @see #execute(String, Object)
+     */
+    public ParseResults<S> parse(final String command, final S source) {
+        return parse(new StringReader(command), source);
+    }
+
+    /**
+     * Parses a given command.
+     *
+     * <p>The result of this method can be cached, and it is advised to do so where appropriate. Parsing is often the
+     * most expensive step, and this allows you to essentially "precompile" a command if it will be ran often.</p>
+     *
+     * <p>If the command passes through a node that is {@link CommandNode#isFork()} then the resulting context will be marked as 'forked'.
+     * Forked contexts may contain child contexts, which may be modified by the {@link RedirectModifier} attached to the fork.</p>
+     *
+     * <p>Parsing a command can never fail, you will always be provided with a new {@link ParseResults}.
+     * However, that does not mean that it will always parse into a valid command. You should inspect the returned results
+     * to check for validity. If its {@link ParseResults#getReader()} {@link StringReader#canRead()} then it did not finish
+     * parsing successfully. You can use that position as an indicator to the user where the command stopped being valid.
+     * You may inspect {@link ParseResults#getExceptions()} if you know the parse failed, as it will explain why it could
+     * not find any valid commands. It may contain multiple exceptions, one for each "potential node" that it could have visited,
+     * explaining why it did not go down that node.</p>
+     *
+     * <p>When you eventually call {@link #execute(ParseResults)} with the result of this method, the above error checking
+     * will occur. You only need to inspect it yourself if you wish to handle that yourself.</p>
+     *
+     * @param command a command string to parse
+     * @param source a custom "source" object, usually representing the originator of this command
+     * @return the result of parsing this command
+     * @see #parse(String, Object)
+     * @see #execute(ParseResults)
+     * @see #execute(String, Object)
+     */
+    public ParseResults<S> parse(final StringReader command, final S source) {
+        final CommandContextBuilder<S> context = new CommandContextBuilder<>(this, source, root, command.getCursor());
+        return parseNodes(root, command, context);
+    }
+
+    private ParseResults<S> parseNodes(final CommandNode<S> node, final StringReader originalReader, final CommandContextBuilder<S> contextSoFar) {
+        final S source = contextSoFar.getSource();
+        Map<CommandNode<S>, CommandSyntaxException> errors = null;
+        List<ParseResults<S>> potentials = null;
+        final int cursor = originalReader.getCursor();
+
+        for (final CommandNode<S> child : node.getRelevantNodes(originalReader)) {
+            if (!child.canUse(source)) {
+                continue;
+            }
+            final CommandContextBuilder<S> context = contextSoFar.copy();
+            final StringReader reader = new StringReader(originalReader);
+            try {
+                try {
+                    child.parse(reader, context);
+                } catch (final RuntimeException ex) {
+                    throw CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherParseException().createWithContext(reader, ex.getMessage());
+                }
+                if (reader.canRead()) {
+                    if (reader.peek() != ARGUMENT_SEPARATOR_CHAR) {
+                        throw CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherExpectedArgumentSeparator().createWithContext(reader);
+                    }
+                }
+            } catch (final CommandSyntaxException ex) {
+                if (errors == null) {
+                    errors = new LinkedHashMap<>();
+                }
+                errors.put(child, ex);
+                reader.setCursor(cursor);
+                continue;
+            }
+
+            context.withCommand(child.getCommand());
+            if (reader.canRead(child.getRedirect() == null ? 2 : 1)) {
+                reader.skip();
+                if (child.getRedirect() != null) {
+                    final CommandContextBuilder<S> childContext = new CommandContextBuilder<>(this, source, child.getRedirect(), reader.getCursor());
+                    final ParseResults<S> parse = parseNodes(child.getRedirect(), reader, childContext);
+                    context.withChild(parse.getContext());
+                    return new ParseResults<>(context, parse.getReader(), parse.getExceptions());
+                } else {
+                    final ParseResults<S> parse = parseNodes(child, reader, context);
+                    if (potentials == null) {
+                        potentials = new ArrayList<>(1);
+                    }
+                    potentials.add(parse);
+                }
+            } else {
+                if (potentials == null) {
+                    potentials = new ArrayList<>(1);
+                }
+                potentials.add(new ParseResults<>(context, reader, Collections.emptyMap()));
+            }
+        }
+
+        if (potentials != null) {
+            if (potentials.size() > 1) {
+                potentials.sort((a, b) -> {
+                    if (!a.getReader().canRead() && b.getReader().canRead()) {
+                        return -1;
+                    }
+                    if (a.getReader().canRead() && !b.getReader().canRead()) {
+                        return 1;
+                    }
+                    if (a.getExceptions().isEmpty() && !b.getExceptions().isEmpty()) {
+                        return -1;
+                    }
+                    if (!a.getExceptions().isEmpty() && b.getExceptions().isEmpty()) {
+                        return 1;
+                    }
+                    return 0;
+                });
+            }
+            return potentials.get(0);
+        }
+
+        return new ParseResults<>(contextSoFar, originalReader, errors == null ? Collections.emptyMap() : errors);
+    }
+
+    /**
+     * Gets all possible executable commands following the given node.
+     *
+     * <p>You may use {@link #getRoot()} as a target to get all usage data for the entire command tree.</p>
+     *
+     * <p>The returned syntax will be in "simple" form: {@code <param>} and {@code literal}. "Optional" nodes will be
+     * listed as multiple entries: the parent node, and the child nodes.
+     * For example, a required literal "foo" followed by an optional param "int" will be two nodes:</p>
+     * <ul>
+     *     <li>{@code foo}</li>
+     *     <li>{@code foo <int>}</li>
+     * </ul>
+     *
+     * <p>The path to the specified node will <b>not</b> be prepended to the output, as there can theoretically be many
+     * ways to reach a given node. It will only give you paths relative to the specified node, not absolute from root.</p>
+     *
+     * @param node target node to get child usage strings for
+     * @param source a custom "source" object, usually representing the originator of this command
+     * @param restricted if true, commands that the {@code source} cannot access will not be mentioned
+     * @return array of full usage strings under the target node
+     */
+    public String[] getAllUsage(final CommandNode<S> node, final S source, final boolean restricted) {
+        final ArrayList<String> result = new ArrayList<>();
+        getAllUsage(node, source, result, "", restricted);
+        return result.toArray(new String[result.size()]);
+    }
+
+    private void getAllUsage(final CommandNode<S> node, final S source, final ArrayList<String> result, final String prefix, final boolean restricted) {
+        if (restricted && !node.canUse(source)) {
+            return;
+        }
+
+        if (node.getCommand() != null) {
+            result.add(prefix);
+        }
+
+        if (node.getRedirect() != null) {
+            final String redirect = node.getRedirect() == root ? "..." : "-> " + node.getRedirect().getUsageText();
+            result.add(prefix.isEmpty() ? node.getUsageText() + ARGUMENT_SEPARATOR + redirect : prefix + ARGUMENT_SEPARATOR + redirect);
+        } else if (!node.getChildren().isEmpty()) {
+            for (final CommandNode<S> child : node.getChildren()) {
+                getAllUsage(child, source, result, prefix.isEmpty() ? child.getUsageText() : prefix + ARGUMENT_SEPARATOR + child.getUsageText(), restricted);
+            }
+        }
+    }
+
+    /**
+     * Gets the possible executable commands from a specified node.
+     *
+     * <p>You may use {@link #getRoot()} as a target to get usage data for the entire command tree.</p>
+     *
+     * <p>The returned syntax will be in "smart" form: {@code <param>}, {@code literal}, {@code [optional]} and {@code (either|or)}.
+     * These forms may be mixed and matched to provide as much information about the child nodes as it can, without being too verbose.
+     * For example, a required literal "foo" followed by an optional param "int" can be compressed into one string:</p>
+     * <ul>
+     *     <li>{@code foo [<int>]}</li>
+     * </ul>
+     *
+     * <p>The path to the specified node will <b>not</b> be prepended to the output, as there can theoretically be many
+     * ways to reach a given node. It will only give you paths relative to the specified node, not absolute from root.</p>
+     *
+     * <p>The returned usage will be restricted to only commands that the provided {@code source} can use.</p>
+     *
+     * @param node target node to get child usage strings for
+     * @param source a custom "source" object, usually representing the originator of this command
+     * @return array of full usage strings under the target node
+     */
+    public Map<CommandNode<S>, String> getSmartUsage(final CommandNode<S> node, final S source) {
+        final Map<CommandNode<S>, String> result = new LinkedHashMap<>();
+
+        final boolean optional = node.getCommand() != null;
+        for (final CommandNode<S> child : node.getChildren()) {
+            final String usage = getSmartUsage(child, source, optional, false);
+            if (usage != null) {
+                result.put(child, usage);
+            }
+        }
+        return result;
+    }
+
+    private String getSmartUsage(final CommandNode<S> node, final S source, final boolean optional, final boolean deep) {
+        if (!node.canUse(source)) {
+            return null;
+        }
+
+        final String self = optional ? USAGE_OPTIONAL_OPEN + node.getUsageText() + USAGE_OPTIONAL_CLOSE : node.getUsageText();
+        final boolean childOptional = node.getCommand() != null;
+        final String open = childOptional ? USAGE_OPTIONAL_OPEN : USAGE_REQUIRED_OPEN;
+        final String close = childOptional ? USAGE_OPTIONAL_CLOSE : USAGE_REQUIRED_CLOSE;
+
+        if (!deep) {
+            if (node.getRedirect() != null) {
+                final String redirect = node.getRedirect() == root ? "..." : "-> " + node.getRedirect().getUsageText();
+                return self + ARGUMENT_SEPARATOR + redirect;
+            } else {
+                final Collection<CommandNode<S>> children = node.getChildren().stream().filter(c -> c.canUse(source)).collect(Collectors.toList());
+                if (children.size() == 1) {
+                    final String usage = getSmartUsage(children.iterator().next(), source, childOptional, childOptional);
+                    if (usage != null) {
+                        return self + ARGUMENT_SEPARATOR + usage;
+                    }
+                } else if (children.size() > 1) {
+                    final Set<String> childUsage = new LinkedHashSet<>();
+                    for (final CommandNode<S> child : children) {
+                        final String usage = getSmartUsage(child, source, childOptional, true);
+                        if (usage != null) {
+                            childUsage.add(usage);
+                        }
+                    }
+                    if (childUsage.size() == 1) {
+                        final String usage = childUsage.iterator().next();
+                        return self + ARGUMENT_SEPARATOR + (childOptional ? USAGE_OPTIONAL_OPEN + usage + USAGE_OPTIONAL_CLOSE : usage);
+                    } else if (childUsage.size() > 1) {
+                        final StringBuilder builder = new StringBuilder(open);
+                        int count = 0;
+                        for (final CommandNode<S> child : children) {
+                            if (count > 0) {
+                                builder.append(USAGE_OR);
+                            }
+                            builder.append(child.getUsageText());
+                            count++;
+                        }
+                        if (count > 0) {
+                            builder.append(close);
+                            return self + ARGUMENT_SEPARATOR + builder.toString();
+                        }
+                    }
+                }
+            }
+        }
+
+        return self;
+    }
+
+    /**
+     * Gets suggestions for a parsed input string on what comes next.
+     *
+     * <p>As it is ultimately up to custom argument types to provide suggestions, it may be an asynchronous operation,
+     * for example getting in-game data or player names etc. As such, this method returns a future and no guarantees
+     * are made to when or how the future completes.</p>
+     *
+     * <p>The suggestions provided will be in the context of the end of the parsed input string, but may suggest
+     * new or replacement strings for earlier in the input string. For example, if the end of the string was
+     * {@code foobar} but an argument preferred it to be {@code minecraft:foobar}, it will suggest a replacement for that
+     * whole segment of the input.</p>
+     *
+     * @param parse the result of a {@link #parse(StringReader, Object)}
+     * @return a future that will eventually resolve into a {@link Suggestions} object
+     */
+    public CompletableFuture<Suggestions> getCompletionSuggestions(final ParseResults<S> parse) {
+        return getCompletionSuggestions(parse, parse.getReader().getTotalLength());
+    }
+
+    public CompletableFuture<Suggestions> getCompletionSuggestions(final ParseResults<S> parse, int cursor) {
+        final CommandContextBuilder<S> context = parse.getContext();
+
+        final SuggestionContext<S> nodeBeforeCursor = context.findSuggestionContext(cursor);
+        final CommandNode<S> parent = nodeBeforeCursor.parent;
+        final int start = Math.min(nodeBeforeCursor.startPos, cursor);
+
+        final String fullInput = parse.getReader().getString();
+        final String truncatedInput = fullInput.substring(0, cursor);
+        @SuppressWarnings("unchecked") final CompletableFuture<Suggestions>[] futures = new CompletableFuture[parent.getChildren().size()];
+        int i = 0;
+        for (final CommandNode<S> node : parent.getChildren()) {
+            CompletableFuture<Suggestions> future = Suggestions.empty();
+            try {
+                future = node.listSuggestions(context.build(truncatedInput), new SuggestionsBuilder(truncatedInput, start));
+            } catch (final CommandSyntaxException ignored) {
+            }
+            futures[i++] = future;
+        }
+
+        final CompletableFuture<Suggestions> result = new CompletableFuture<>();
+        CompletableFuture.allOf(futures).thenRun(() -> {
+            final List<Suggestions> suggestions = new ArrayList<>();
+            for (final CompletableFuture<Suggestions> future : futures) {
+                suggestions.add(future.join());
+            }
+            result.complete(Suggestions.merge(fullInput, suggestions));
+        });
+
+        return result;
+    }
+
+    /**
+     * Gets the root of this command tree.
+     *
+     * <p>This is often useful as a target of a {@link com.mojang.brigadier.builder.ArgumentBuilder#redirect(CommandNode)},
+     * {@link #getAllUsage(CommandNode, Object, boolean)} or {@link #getSmartUsage(CommandNode, Object)}.
+     * You may also use it to clone the command tree via {@link #CommandDispatcher(RootCommandNode)}.</p>
+     *
+     * @return root of the command tree
+     */
+    public RootCommandNode<S> getRoot() {
+        return root;
+    }
+
+    /**
+     * Finds a valid path to a given node on the command tree.
+     *
+     * <p>There may theoretically be multiple paths to a node on the tree, especially with the use of forking or redirecting.
+     * As such, this method makes no guarantees about which path it finds. It will not look at forks or redirects,
+     * and find the first instance of the target node on the tree.</p>
+     *
+     * <p>The only guarantee made is that for the same command tree and the same version of this library, the result of
+     * this method will <b>always</b> be a valid input for {@link #findNode(Collection)}, which should return the same node
+     * as provided to this method.</p>
+     *
+     * @param target the target node you are finding a path for
+     * @return a path to the resulting node, or an empty list if it was not found
+     */
+    public Collection<String> getPath(final CommandNode<S> target) {
+        final List<List<CommandNode<S>>> nodes = new ArrayList<>();
+        addPaths(root, nodes, new ArrayList<>());
+
+        for (final List<CommandNode<S>> list : nodes) {
+            if (list.get(list.size() - 1) == target) {
+                final List<String> result = new ArrayList<>(list.size());
+                for (final CommandNode<S> node : list) {
+                    if (node != root) {
+                        result.add(node.getName());
+                    }
+                }
+                return result;
+            }
+        }
+
+        return Collections.emptyList();
+    }
+
+    /**
+     * Finds a node by its path
+     *
+     * <p>Paths may be generated with {@link #getPath(CommandNode)}, and are guaranteed (for the same tree, and the
+     * same version of this library) to always produce the same valid node by this method.</p>
+     *
+     * <p>If a node could not be found at the specified path, then {@code null} will be returned.</p>
+     *
+     * @param path a generated path to a node
+     * @return the node at the given path, or null if not found
+     */
+    public CommandNode<S> findNode(final Collection<String> path) {
+        CommandNode<S> node = root;
+        for (final String name : path) {
+            node = node.getChild(name);
+            if (node == null) {
+                return null;
+            }
+        }
+        return node;
+    }
+
+    /**
+     * Scans the command tree for potential ambiguous commands.
+     *
+     * <p>This is a shortcut for {@link CommandNode#findAmbiguities(AmbiguityConsumer)} on {@link #getRoot()}.</p>
+     *
+     * <p>Ambiguities are detected by testing every {@link CommandNode#getExamples()} on one node verses every sibling
+     * node. This is not fool proof, and relies a lot on the providers of the used argument types to give good examples.</p>
+     *
+     * @param consumer a callback to be notified of potential ambiguities
+     */
+    public void findAmbiguities(final AmbiguityConsumer<S> consumer) {
+        root.findAmbiguities(consumer);
+    }
+
+    private void addPaths(final CommandNode<S> node, final List<List<CommandNode<S>>> result, final List<CommandNode<S>> parents) {
+        final List<CommandNode<S>> current = new ArrayList<>(parents);
+        current.add(node);
+        result.add(current);
+
+        for (final CommandNode<S> child : node.getChildren()) {
+            addPaths(child, result, current);
+        }
+    }
+}
diff --git a/src/main/java/com/mojang/brigadier/arguments/BoolArgumentType.java b/src/main/java/com/mojang/brigadier/arguments/BoolArgumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb993ca102402d9c19ea9fa04e5db09c21205896
--- /dev/null
+++ b/src/main/java/com/mojang/brigadier/arguments/BoolArgumentType.java
@@ -0,0 +1,50 @@
+// Copyright (c) Microsoft Corporation. All rights reserved.
+// Licensed under the MIT license.
+
+package com.mojang.brigadier.arguments;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.concurrent.CompletableFuture;
+
+public class BoolArgumentType implements ArgumentType<Boolean> {
+    private static final Collection<String> EXAMPLES = Arrays.asList("true", "false");
+
+    private BoolArgumentType() {
+    }
+
+    public static BoolArgumentType bool() {
+        return new BoolArgumentType();
+    }
+
+    public static boolean getBool(final CommandContext<?> context, final String name) {
+        return context.getArgument(name, Boolean.class);
+    }
+
+    @Override
+    public Boolean parse(final StringReader reader) throws CommandSyntaxException {
+        return reader.readBoolean();
+    }
+
+    @Override
+    public <S> CompletableFuture<Suggestions> listSuggestions(final CommandContext<S> context, final SuggestionsBuilder builder) {
+        if ("true".startsWith(builder.getRemaining().toLowerCase())) {
+            builder.suggest("true");
+        }
+        if ("false".startsWith(builder.getRemaining().toLowerCase())) {
+            builder.suggest("false");
+        }
+        return builder.buildFuture();
+    }
+
+    @Override
+    public Collection<String> getExamples() {
+        return EXAMPLES;
+    }
+}
diff --git a/src/main/java/com/mojang/brigadier/suggestion/SuggestionsBuilder.java b/src/main/java/com/mojang/brigadier/suggestion/SuggestionsBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..bc0024adb804ac055a4f8afb7f85d00ec13931e9
--- /dev/null
+++ b/src/main/java/com/mojang/brigadier/suggestion/SuggestionsBuilder.java
@@ -0,0 +1,83 @@
+// Copyright (c) Microsoft Corporation. All rights reserved.
+// Licensed under the MIT license.
+
+package com.mojang.brigadier.suggestion;
+
+import com.mojang.brigadier.Message;
+import com.mojang.brigadier.context.StringRange;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+public class SuggestionsBuilder {
+    private final String input;
+    private final int start;
+    private final String remaining;
+    private final List<Suggestion> result = new ArrayList<>();
+
+    public SuggestionsBuilder(final String input, final int start) {
+        this.input = input;
+        this.start = start;
+        this.remaining = input.substring(start);
+    }
+
+    public String getInput() {
+        return input;
+    }
+
+    public int getStart() {
+        return start;
+    }
+
+    public String getRemaining() {
+        return remaining;
+    }
+
+    public Suggestions build() {
+        return Suggestions.create(input, result);
+    }
+
+    public CompletableFuture<Suggestions> buildFuture() {
+        return CompletableFuture.completedFuture(build());
+    }
+
+    public SuggestionsBuilder suggest(final String text) {
+        if (text.equals(remaining)) {
+            return this;
+        }
+        result.add(new Suggestion(StringRange.between(start, input.length()), text));
+        return this;
+    }
+
+    public SuggestionsBuilder suggest(final String text, final Message tooltip) {
+        if (text.equals(remaining)) {
+            return this;
+        }
+        result.add(new Suggestion(StringRange.between(start, input.length()), text, tooltip));
+        return this;
+    }
+
+    public SuggestionsBuilder suggest(final int value) {
+        result.add(new IntegerSuggestion(StringRange.between(start, input.length()), value));
+        return this;
+    }
+
+    public SuggestionsBuilder suggest(final int value, final Message tooltip) {
+        result.add(new IntegerSuggestion(StringRange.between(start, input.length()), value, tooltip));
+        return this;
+    }
+
+    public SuggestionsBuilder add(final SuggestionsBuilder other) {
+        result.addAll(other.result);
+        return this;
+    }
+
+    public SuggestionsBuilder createOffset(final int start) {
+        return new SuggestionsBuilder(input, start);
+    }
+
+    public SuggestionsBuilder restart() {
+        return new SuggestionsBuilder(input, start);
+    }
+}
diff --git a/src/main/java/com/mojang/brigadier/tree/LiteralCommandNode.java b/src/main/java/com/mojang/brigadier/tree/LiteralCommandNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..7720578796e28d28e8c0c9aa40155cd205c17d54
--- /dev/null
+++ b/src/main/java/com/mojang/brigadier/tree/LiteralCommandNode.java
@@ -0,0 +1,129 @@
+// Copyright (c) Microsoft Corporation. All rights reserved.
+// Licensed under the MIT license.
+
+package com.mojang.brigadier.tree;
+
+import com.mojang.brigadier.Command;
+import com.mojang.brigadier.RedirectModifier;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.context.CommandContextBuilder;
+import com.mojang.brigadier.context.StringRange;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Predicate;
+
+public class LiteralCommandNode<S> extends CommandNode<S> {
+    private final String literal;
+
+    public LiteralCommandNode(final String literal, final Command<S> command, final Predicate<S> requirement, final CommandNode<S> redirect, final RedirectModifier<S> modifier, final boolean forks) {
+        super(command, requirement, redirect, modifier, forks);
+        this.literal = literal;
+    }
+
+    public String getLiteral() {
+        return literal;
+    }
+
+    @Override
+    public String getName() {
+        return literal;
+    }
+
+    @Override
+    public void parse(final StringReader reader, final CommandContextBuilder<S> contextBuilder) throws CommandSyntaxException {
+        final int start = reader.getCursor();
+        final int end = parse(reader);
+        if (end > -1) {
+            contextBuilder.withNode(this, StringRange.between(start, end));
+            return;
+        }
+
+        throw CommandSyntaxException.BUILT_IN_EXCEPTIONS.literalIncorrect().createWithContext(reader, literal);
+    }
+
+    private int parse(final StringReader reader) {
+        final int start = reader.getCursor();
+        if (reader.canRead(literal.length())) {
+            final int end = start + literal.length();
+            if (reader.getString().substring(start, end).equals(literal)) {
+                reader.setCursor(end);
+                if (!reader.canRead() || reader.peek() == ' ') {
+                    return end;
+                } else {
+                    reader.setCursor(start);
+                }
+            }
+        }
+        return -1;
+    }
+
+    @Override
+    public CompletableFuture<Suggestions> listSuggestions(final CommandContext<S> context, final SuggestionsBuilder builder) {
+        if (literal.toLowerCase().startsWith(builder.getRemaining().toLowerCase())) {
+            return builder.suggest(literal).buildFuture();
+        } else {
+            return Suggestions.empty();
+        }
+    }
+
+    @Override
+    public boolean isValidInput(final String input) {
+        return parse(new StringReader(input)) > -1;
+    }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (this == o) return true;
+        if (!(o instanceof LiteralCommandNode)) return false;
+
+        final LiteralCommandNode that = (LiteralCommandNode) o;
+
+        if (!literal.equals(that.literal)) return false;
+        return super.equals(o);
+    }
+
+    @Override
+    public String getUsageText() {
+        return literal;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = literal.hashCode();
+        result = 31 * result + super.hashCode();
+        return result;
+    }
+
+    @Override
+    public LiteralArgumentBuilder<S> createBuilder() {
+        final LiteralArgumentBuilder<S> builder = LiteralArgumentBuilder.literal(this.literal);
+        builder.requires(getRequirement());
+        builder.forward(getRedirect(), getRedirectModifier(), isFork());
+        if (getCommand() != null) {
+            builder.executes(getCommand());
+        }
+        return builder;
+    }
+
+    @Override
+    protected String getSortedKey() {
+        return literal;
+    }
+
+    @Override
+    public Collection<String> getExamples() {
+        return Collections.singleton(literal);
+    }
+
+    @Override
+    public String toString() {
+        return "<literal " + literal + ">";
+    }
+}
diff --git a/src/main/java/com/mojang/datafixers/DataFixerBuilder.java b/src/main/java/com/mojang/datafixers/DataFixerBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..edb77982d273e9492ab1a669ca1ad89da2ec3c3e
--- /dev/null
+++ b/src/main/java/com/mojang/datafixers/DataFixerBuilder.java
@@ -0,0 +1,84 @@
+// Copyright (c) Microsoft Corporation. All rights reserved.
+// Licensed under the MIT license.
+package com.mojang.datafixers;
+
+import com.google.common.collect.Lists;
+import com.mojang.datafixers.schemas.Schema;
+import com.mojang.datafixers.types.Type;
+import it.unimi.dsi.fastutil.ints.Int2ObjectAVLTreeMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectSortedMap;
+import it.unimi.dsi.fastutil.ints.IntAVLTreeSet;
+import it.unimi.dsi.fastutil.ints.IntBidirectionalIterator;
+import it.unimi.dsi.fastutil.ints.IntSortedSet;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.function.BiFunction;
+
+public class DataFixerBuilder {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private final int dataVersion;
+    private final Int2ObjectSortedMap<Schema> schemas = new Int2ObjectAVLTreeMap<>();
+    private final List<DataFix> globalList = Lists.newArrayList();
+    private final IntSortedSet fixerVersions = new IntAVLTreeSet();
+
+    public DataFixerBuilder(final int dataVersion) {
+        this.dataVersion = dataVersion;
+    }
+
+    public Schema addSchema(final int version, final BiFunction<Integer, Schema, Schema> factory) {
+        return addSchema(version, 0, factory);
+    }
+
+    public Schema addSchema(final int version, final int subVersion, final BiFunction<Integer, Schema, Schema> factory) {
+        final int key = DataFixUtils.makeKey(version, subVersion);
+        final Schema parent = schemas.isEmpty() ? null : schemas.get(DataFixerUpper.getLowestSchemaSameVersion(schemas, key - 1));
+        final Schema schema = factory.apply(DataFixUtils.makeKey(version, subVersion), parent);
+        addSchema(schema);
+        return schema;
+    }
+
+    public void addSchema(final Schema schema) {
+        schemas.put(schema.getVersionKey(), schema);
+    }
+
+    public void addFixer(final DataFix fix) {
+        final int version = DataFixUtils.getVersion(fix.getVersionKey());
+
+        if (version > dataVersion) {
+            LOGGER.warn("Ignored fix registered for version: {} as the DataVersion of the game is: {}", version, dataVersion);
+            return;
+        }
+
+        globalList.add(fix);
+        fixerVersions.add(fix.getVersionKey());
+    }
+
+    public DataFixer build(final Executor executor) {
+        final DataFixerUpper fixerUpper = new DataFixerUpper(new Int2ObjectAVLTreeMap<>(schemas), new ArrayList<>(globalList), new IntAVLTreeSet(fixerVersions));
+
+        final IntBidirectionalIterator iterator = fixerUpper.fixerVersions().iterator();
+        while (iterator.hasNext()) {
+            final int versionKey = iterator.nextInt();
+            final Schema schema = schemas.get(versionKey);
+            for (final String typeName : schema.types()) {
+                CompletableFuture.runAsync(() -> {
+                    final Type<?> dataType = schema.getType(() -> typeName);
+                    final TypeRewriteRule rule = fixerUpper.getRule(DataFixUtils.getVersion(versionKey), dataVersion);
+                    dataType.rewrite(rule, DataFixerUpper.OPTIMIZATION_RULE);
+                }, executor).exceptionally(e -> {
+                    LOGGER.error("Unable to build datafixers", e);
+                    Runtime.getRuntime().exit(1);
+                    return null;
+                });
+            }
+        }
+
+        return fixerUpper;
+    }
+}
diff --git a/src/main/java/com/mojang/datafixers/util/Either.java b/src/main/java/com/mojang/datafixers/util/Either.java
new file mode 100644
index 0000000000000000000000000000000000000000..a90adac7bd7ebd423f480e9ae0f44cb9d521fa4f
--- /dev/null
+++ b/src/main/java/com/mojang/datafixers/util/Either.java
@@ -0,0 +1,244 @@
+// Copyright (c) Microsoft Corporation. All rights reserved.
+// Licensed under the MIT license.
+package com.mojang.datafixers.util;
+
+import com.mojang.datafixers.kinds.App;
+import com.mojang.datafixers.kinds.Applicative;
+import com.mojang.datafixers.kinds.CocartesianLike;
+import com.mojang.datafixers.kinds.K1;
+import com.mojang.datafixers.kinds.Traversable;
+
+import java.util.Objects;
+import java.util.Optional;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
+    public static final class Mu<R> implements K1 {}
+
+    public static <L, R> Either<L, R> unbox(final App<Mu<R>, L> box) {
+        return (Either<L, R>) box;
+    }
+
+    private static final class Left<L, R> extends Either<L, R> {
+        private final L value;
+
+        public Left(final L value) {
+            this.value = value;
+        }
+
+        @Override
+        public <C, D> Either<C, D> mapBoth(final Function<? super L, ? extends C> f1, final Function<? super R, ? extends D> f2) {
+            return new Left<>(f1.apply(value));
+        }
+
+        @Override
+        public <T> T map(final Function<? super L, ? extends T> l, final Function<? super R, ? extends T> r) {
+            return l.apply(value);
+        }
+
+        @Override
+        public Either<L, R> ifLeft(Consumer<? super L> consumer) {
+            consumer.accept(value);
+            return this;
+        }
+
+        @Override
+        public Either<L, R> ifRight(Consumer<? super R> consumer) {
+            return this;
+        }
+
+        @Override
+        public Optional<L> left() {
+            return Optional.of(value);
+        }
+
+        @Override
+        public Optional<R> right() {
+            return Optional.empty();
+        }
+
+        @Override
+        public String toString() {
+            return "Left[" + value + "]";
+        }
+
+        @Override
+        public boolean equals(final Object o) {
+            if (this == o) {
+                return true;
+            }
+            if (o == null || getClass() != o.getClass()) {
+                return false;
+            }
+            final Left<?, ?> left = (Left<?, ?>) o;
+            return Objects.equals(value, left.value);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(value);
+        }
+    }
+
+    private static final class Right<L, R> extends Either<L, R> {
+        private final R value;
+
+        public Right(final R value) {
+            this.value = value;
+        }
+
+        @Override
+        public <C, D> Either<C, D> mapBoth(final Function<? super L, ? extends C> f1, final Function<? super R, ? extends D> f2) {
+            return new Right<>(f2.apply(value));
+        }
+
+        @Override
+        public <T> T map(final Function<? super L, ? extends T> l, final Function<? super R, ? extends T> r) {
+            return r.apply(value);
+        }
+
+        @Override
+        public Either<L, R> ifLeft(Consumer<? super L> consumer) {
+            return this;
+        }
+
+        @Override
+        public Either<L, R> ifRight(Consumer<? super R> consumer) {
+            consumer.accept(value);
+            return this;
+        }
+
+        @Override
+        public Optional<L> left() {
+            return Optional.empty();
+        }
+
+        @Override
+        public Optional<R> right() {
+            return Optional.of(value);
+        }
+
+        @Override
+        public String toString() {
+            return "Right[" + value + "]";
+        }
+
+        @Override
+        public boolean equals(final Object o) {
+            if (this == o) {
+                return true;
+            }
+            if (o == null || getClass() != o.getClass()) {
+                return false;
+            }
+            final Right<?, ?> right = (Right<?, ?>) o;
+            return Objects.equals(value, right.value);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(value);
+        }
+    }
+
+    private Either() {
+    }
+
+    public abstract <C, D> Either<C, D> mapBoth(final Function<? super L, ? extends C> f1, final Function<? super R, ? extends D> f2);
+
+    public abstract <T> T map(final Function<? super L, ? extends T> l, Function<? super R, ? extends T> r);
+
+    public abstract Either<L, R> ifLeft(final Consumer<? super L> consumer);
+
+    public abstract Either<L, R> ifRight(final Consumer<? super R> consumer);
+
+    public abstract Optional<L> left();
+
+    public abstract Optional<R> right();
+
+    public <T> Either<T, R> mapLeft(final Function<? super L, ? extends T> l) {
+        return map(t -> left(l.apply(t)), Either::right);
+    }
+
+    public <T> Either<L, T> mapRight(final Function<? super R, ? extends T> l) {
+        return map(Either::left, t -> right(l.apply(t)));
+    }
+
+    public static <L, R> Either<L, R> left(final L value) {
+        return new Left<>(value);
+    }
+
+    public static <L, R> Either<L, R> right(final R value) {
+        return new Right<>(value);
+    }
+
+    public L orThrow() {
+        return map(l -> l, r -> {
+            if (r instanceof Throwable) {
+                throw new RuntimeException((Throwable) r);
+            }
+            throw new RuntimeException(r.toString());
+        });
+    }
+
+    public Either<R, L> swap() {
+        return map(Either::right, Either::left);
+    }
+
+    public <L2> Either<L2, R> flatMap(final Function<L, Either<L2, R>> function) {
+        return map(function, Either::right);
+    }
+
+    public static final class Instance<R2> implements Applicative<Mu<R2>, Instance.Mu<R2>>, Traversable<Mu<R2>, Instance.Mu<R2>>, CocartesianLike<Mu<R2>, R2, Instance.Mu<R2>> {
+        public static final class Mu<R2> implements Applicative.Mu, Traversable.Mu, CocartesianLike.Mu {}
+
+        @Override
+        public <T, R> App<Either.Mu<R2>, R> map(final Function<? super T, ? extends R> func, final App<Either.Mu<R2>, T> ts) {
+            return Either.unbox(ts).mapLeft(func);
+        }
+
+        @Override
+        public <A> App<Either.Mu<R2>, A> point(final A a) {
+            return left(a);
+        }
+
+        @Override
+        public <A, R> Function<App<Either.Mu<R2>, A>, App<Either.Mu<R2>, R>> lift1(final App<Either.Mu<R2>, Function<A, R>> function) {
+            return a -> Either.unbox(function).flatMap(f -> Either.unbox(a).mapLeft(f));
+        }
+
+        @Override
+        public <A, B, R> BiFunction<App<Either.Mu<R2>, A>, App<Either.Mu<R2>, B>, App<Either.Mu<R2>, R>> lift2(final App<Either.Mu<R2>, BiFunction<A, B, R>> function) {
+            return (a, b) -> Either.unbox(function).flatMap(
+                f -> Either.unbox(a).flatMap(
+                    av -> Either.unbox(b).mapLeft(
+                        bv -> f.apply(av, bv)
+                    )
+                )
+            );
+        }
+
+        @Override
+        public <F extends K1, A, B> App<F, App<Either.Mu<R2>, B>> traverse(final Applicative<F, ?> applicative, final Function<A, App<F, B>> function, final App<Either.Mu<R2>, A> input) {
+            return Either.unbox(input).map(
+                l -> {
+                    final App<F, B> b = function.apply(l);
+                    return applicative.ap(Either::left, b);
+                },
+                r -> applicative.point(right(r))
+            );
+        }
+
+        @Override
+        public <A> App<Either.Mu<R2>, A> to(final App<Either.Mu<R2>, A> input) {
+            return input;
+        }
+
+        @Override
+        public <A> App<Either.Mu<R2>, A> from(final App<Either.Mu<R2>, A> input) {
+            return input;
+        }
+    }
+}
diff --git a/src/main/java/com/mojang/serialization/Dynamic.java b/src/main/java/com/mojang/serialization/Dynamic.java
new file mode 100644
index 0000000000000000000000000000000000000000..a75d3db046dc985a03b4b870c91f41de1bd66bad
--- /dev/null
+++ b/src/main/java/com/mojang/serialization/Dynamic.java
@@ -0,0 +1,196 @@
+// Copyright (c) Microsoft Corporation. All rights reserved.
+// Licensed under the MIT license.
+package com.mojang.serialization;
+
+import com.google.common.collect.ImmutableMap;
+import com.mojang.datafixers.DataFixUtils;
+import com.mojang.datafixers.util.Pair;
+
+import javax.annotation.Nullable;
+import java.nio.ByteBuffer;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Function;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
+import java.util.stream.Stream;
+
+@SuppressWarnings("unused")
+public class Dynamic<T> extends DynamicLike<T> {
+    private final T value;
+
+    public Dynamic(final DynamicOps<T> ops) {
+        this(ops, ops.empty());
+    }
+
+    public Dynamic(final DynamicOps<T> ops, @Nullable final T value) {
+        super(ops);
+        this.value = value == null ? ops.empty() : value;
+    }
+
+    public T getValue() {
+        return value;
+    }
+
+    public Dynamic<T> map(final Function<? super T, ? extends T> function) {
+        return new Dynamic<>(ops, function.apply(value));
+    }
+
+    @SuppressWarnings("unchecked")
+    public <U> Dynamic<U> castTyped(final DynamicOps<U> ops) {
+        if (!Objects.equals(this.ops, ops)) {
+            throw new IllegalStateException("Dynamic type doesn't match");
+        }
+        return (Dynamic<U>) this;
+    }
+
+    public <U> U cast(final DynamicOps<U> ops) {
+        return castTyped(ops).getValue();
+    }
+
+    public OptionalDynamic<T> merge(final Dynamic<?> value) {
+        final DataResult<T> merged = ops.mergeToList(this.value, value.cast(ops));
+        return new OptionalDynamic<>(ops, merged.map(m -> new Dynamic<>(ops, m)));
+    }
+
+    public OptionalDynamic<T> merge(final Dynamic<?> key, final Dynamic<?> value) {
+        final DataResult<T> merged = ops.mergeToMap(this.value, key.cast(ops), value.cast(ops));
+        return new OptionalDynamic<>(ops, merged.map(m -> new Dynamic<>(ops, m)));
+    }
+
+    public DataResult<Map<Dynamic<T>, Dynamic<T>>> getMapValues() {
+        return ops.getMapValues(value).map(map -> {
+            final ImmutableMap.Builder<Dynamic<T>, Dynamic<T>> builder = ImmutableMap.builder();
+            map.forEach(entry -> builder.put(new Dynamic<>(ops, entry.getFirst()), new Dynamic<>(ops, entry.getSecond())));
+            return builder.build();
+        });
+    }
+
+    public Dynamic<T> updateMapValues(final Function<Pair<Dynamic<?>, Dynamic<?>>, Pair<Dynamic<?>, Dynamic<?>>> updater) {
+        return DataFixUtils.orElse(getMapValues().map(map -> map.entrySet().stream().map(e -> {
+            final Pair<Dynamic<?>, Dynamic<?>> pair = updater.apply(Pair.of(e.getKey(), e.getValue()));
+            return Pair.of(pair.getFirst().castTyped(ops), pair.getSecond().castTyped(ops));
+        }).collect(Pair.toMap())).map(this::createMap).result(), this);
+    }
+
+    @Override
+    public DataResult<Number> asNumber() {
+        return ops.getNumberValue(value);
+    }
+
+    @Override
+    public DataResult<String> asString() {
+        return ops.getStringValue(value);
+    }
+
+    @Override
+    public DataResult<Stream<Dynamic<T>>> asStreamOpt() {
+        return ops.getStream(value).map(s -> s.map(e -> new Dynamic<>(ops, e)));
+    }
+
+    @Override
+    public DataResult<Stream<Pair<Dynamic<T>, Dynamic<T>>>> asMapOpt() {
+        return ops.getMapValues(value).map(s -> s.map(p -> Pair.of(new Dynamic<>(ops, p.getFirst()), new Dynamic<>(ops, p.getSecond()))));
+    }
+
+    @Override
+    public DataResult<ByteBuffer> asByteBufferOpt() {
+        return ops.getByteBuffer(value);
+    }
+
+    @Override
+    public DataResult<IntStream> asIntStreamOpt() {
+        return ops.getIntStream(value);
+    }
+
+    @Override
+    public DataResult<LongStream> asLongStreamOpt() {
+        return ops.getLongStream(value);
+    }
+
+    @Override
+    public OptionalDynamic<T> get(final String key) {
+        return new OptionalDynamic<>(ops, ops.getMap(value).flatMap(m -> {
+            final T value = m.get(key);
+            if (value == null) {
+                return DataResult.error("key missing: " + key + " in " + this.value);
+            }
+            return DataResult.success(new Dynamic<>(ops, value));
+        }));
+    }
+
+    @Override
+    public DataResult<T> getGeneric(final T key) {
+        return ops.getGeneric(value, key);
+    }
+
+    public Dynamic<T> remove(final String key) {
+        return map(v -> ops.remove(v, key));
+    }
+
+    public Dynamic<T> set(final String key, final Dynamic<?> value) {
+        return map(v -> ops.set(v, key, value.cast(ops)));
+    }
+
+    public Dynamic<T> update(final String key, final Function<Dynamic<?>, Dynamic<?>> function) {
+        return map(v -> ops.update(v, key, value -> function.apply(new Dynamic<>(ops, value)).cast(ops)));
+    }
+
+    public Dynamic<T> updateGeneric(final T key, final Function<T, T> function) {
+        return map(v -> ops.updateGeneric(v, key, function));
+    }
+
+    @Override
+    public DataResult<T> getElement(final String key) {
+        return getElementGeneric(ops.createString(key));
+    }
+
+    @Override
+    public DataResult<T> getElementGeneric(final T key) {
+        return ops.getGeneric(value, key);
+    }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        final Dynamic<?> dynamic = (Dynamic<?>) o;
+        return Objects.equals(ops, dynamic.ops) && Objects.equals(value, dynamic.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(ops, value);
+    }
+
+    @Override
+    public String toString() {
+        return String.format("%s[%s]", ops, value);
+    }
+
+    public <R> Dynamic<R> convert(final DynamicOps<R> outOps) {
+        return new Dynamic<>(outOps, convert(ops, outOps, value));
+    }
+
+    public <V> V into(final Function<? super Dynamic<T>, ? extends V> action) {
+        return action.apply(this);
+    }
+
+    @Override
+    public <A> DataResult<Pair<A, T>> decode(final Decoder<? extends A> decoder) {
+        return decoder.decode(ops, value).map(p -> p.mapFirst(Function.identity()));
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <S, T> T convert(final DynamicOps<S> inOps, final DynamicOps<T> outOps, final S input) {
+        if (Objects.equals(inOps, outOps)) {
+            return (T) input;
+        }
+
+        return inOps.convertTo(outOps, input);
+    }
+}
diff --git a/src/main/java/com/mojang/serialization/codecs/KeyDispatchCodec.java b/src/main/java/com/mojang/serialization/codecs/KeyDispatchCodec.java
new file mode 100644
index 0000000000000000000000000000000000000000..de7d1e5e0319c65775d932144c268c2d55bb7dc7
--- /dev/null
+++ b/src/main/java/com/mojang/serialization/codecs/KeyDispatchCodec.java
@@ -0,0 +1,130 @@
+package com.mojang.serialization.codecs;
+
+import com.mojang.datafixers.util.Pair;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Decoder;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.Encoder;
+import com.mojang.serialization.MapCodec;
+import com.mojang.serialization.MapLike;
+import com.mojang.serialization.RecordBuilder;
+
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+public class KeyDispatchCodec<K, V> extends MapCodec<V> {
+    private final String typeKey;
+    private final Codec<K> keyCodec;
+    private final String valueKey = "value";
+    private final Function<? super V, ? extends DataResult<? extends K>> type;
+    private final Function<? super K, ? extends DataResult<? extends Decoder<? extends V>>> decoder;
+    private final Function<? super V, ? extends DataResult<? extends Encoder<V>>> encoder;
+
+    private final boolean assumeMap;
+
+    /**
+     * Will assume that the result of all elements is a map
+     */
+    public static <K, V> KeyDispatchCodec<K, V> unsafe(final String typeKey, final Codec<K> keyCodec, final Function<? super V, ? extends DataResult<? extends K>> type, final Function<? super K, ? extends DataResult<? extends Decoder<? extends V>>> decoder, final Function<? super V, ? extends DataResult<? extends Encoder<V>>> encoder) {
+        return new KeyDispatchCodec<>(typeKey, keyCodec, type, decoder, encoder, true);
+    }
+
+    protected KeyDispatchCodec(final String typeKey, final Codec<K> keyCodec, final Function<? super V, ? extends DataResult<? extends K>> type, final Function<? super K, ? extends DataResult<? extends Decoder<? extends V>>> decoder, final Function<? super V, ? extends DataResult<? extends Encoder<V>>> encoder, final boolean assumeMap) {
+        this.typeKey = typeKey;
+        this.keyCodec = keyCodec;
+        this.type = type;
+        this.decoder = decoder;
+        this.encoder = encoder;
+        this.assumeMap = assumeMap;
+    }
+
+    /**
+     * Assumes codec(type(V)) is Codec<V>
+     */
+    public KeyDispatchCodec(final String typeKey, final Codec<K> keyCodec, final Function<? super V, ? extends DataResult<? extends K>> type, final Function<? super K, ? extends DataResult<? extends Codec<? extends V>>> codec) {
+        this(typeKey, keyCodec, type, codec, v -> getCodec(type, codec, v), false);
+    }
+
+    @Override
+    public <T> DataResult<V> decode(final DynamicOps<T> ops, final MapLike<T> input) {
+        final T elementName = input.get(typeKey);
+        if (elementName == null) {
+            return DataResult.error("Input does not contain a key [" + typeKey + "]: " + input);
+        }
+
+        return keyCodec.decode(ops, elementName).flatMap(type -> {
+            final DataResult<? extends Decoder<? extends V>> elementDecoder = decoder.apply(type.getFirst());
+            return elementDecoder.flatMap(c -> {
+                if (ops.compressMaps()) {
+                    final T value = input.get(ops.createString(valueKey));
+                    if (value == null) {
+                        return DataResult.error("Input does not have a \"value\" entry: " + input);
+                    }
+                    return c.parse(ops, value).map(Function.identity());
+                }
+                if (c instanceof MapCodecCodec<?>) {
+                    return ((MapCodecCodec<? extends V>) c).codec().decode(ops, input).map(Function.identity());
+                }
+                if (assumeMap) {
+                    return c.decode(ops, ops.createMap(input.entries())).map(Pair::getFirst);
+                }
+                return c.decode(ops, input.get(valueKey)).map(Pair::getFirst);
+            });
+        });
+    }
+
+    @Override
+    public <T> RecordBuilder<T> encode(final V input, final DynamicOps<T> ops, final RecordBuilder<T> prefix) {
+        final DataResult<? extends Encoder<V>> elementEncoder = encoder.apply(input);
+        final RecordBuilder<T> builder = prefix.withErrorsFrom(elementEncoder);
+        if (!elementEncoder.result().isPresent()) {
+            return builder;
+        }
+
+        final Encoder<V> c = elementEncoder.result().get();
+        if (ops.compressMaps()) {
+            return prefix
+                .add(typeKey, type.apply(input).flatMap(t -> keyCodec.encodeStart(ops, t)))
+                .add(valueKey, c.encodeStart(ops, input));
+        }
+        if (c instanceof MapCodecCodec<?>) {
+            return ((MapCodecCodec<V>) c).codec().encode(input, ops, prefix)
+                .add(typeKey, type.apply(input).flatMap(t -> keyCodec.encodeStart(ops, t)));
+        }
+
+        final T typeString = ops.createString(typeKey);
+
+        final DataResult<T> result = c.encodeStart(ops, input);
+        if (assumeMap) {
+            final DataResult<MapLike<T>> element = result.flatMap(ops::getMap);
+            return element.map(map -> {
+                prefix.add(typeString, type.apply(input).flatMap(t -> keyCodec.encodeStart(ops, t)));
+                map.entries().forEach(pair -> {
+                    if (!pair.getFirst().equals(typeString)) {
+                        prefix.add(pair.getFirst(), pair.getSecond());
+                    }
+                });
+                return prefix;
+            }).result().orElseGet(() -> prefix.withErrorsFrom(element));
+        }
+        prefix.add(typeString, type.apply(input).flatMap(t -> keyCodec.encodeStart(ops, t)));
+        prefix.add(valueKey, result);
+        return prefix;
+    }
+
+    @Override
+    public <T> Stream<T> keys(final DynamicOps<T> ops) {
+        return Stream.of(typeKey, valueKey).map(ops::createString);
+    }
+
+    @SuppressWarnings("unchecked")
+    private static <K, V> DataResult<? extends Encoder<V>> getCodec(final Function<? super V, ? extends DataResult<? extends K>> type, final Function<? super K, ? extends DataResult<? extends Encoder<? extends V>>> encoder, final V input) {
+        return type.apply(input).<Encoder<? extends V>>flatMap(k -> encoder.apply(k).map(Function.identity())).map(c -> ((Encoder<V>) c));
+    }
+
+    @Override
+    public String toString() {
+        return "KeyDispatchCodec[" + keyCodec.toString() + " " + type + " " + decoder + "]";
+    }
+}
diff --git a/src/main/java/net/minecraft/EnumChatFormat.java b/src/main/java/net/minecraft/EnumChatFormat.java
new file mode 100644
index 0000000000000000000000000000000000000000..75e38f05c10713f773a8763100dfc0777521dba6
--- /dev/null
+++ b/src/main/java/net/minecraft/EnumChatFormat.java
@@ -0,0 +1,122 @@
+package net.minecraft;
+
+import com.google.common.collect.Lists;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
+
+public enum EnumChatFormat {
+
+    BLACK("BLACK", '0', 0, 0), DARK_BLUE("DARK_BLUE", '1', 1, 170), DARK_GREEN("DARK_GREEN", '2', 2, 43520), DARK_AQUA("DARK_AQUA", '3', 3, 43690), DARK_RED("DARK_RED", '4', 4, 11141120), DARK_PURPLE("DARK_PURPLE", '5', 5, 11141290), GOLD("GOLD", '6', 6, 16755200), GRAY("GRAY", '7', 7, 11184810), DARK_GRAY("DARK_GRAY", '8', 8, 5592405), BLUE("BLUE", '9', 9, 5592575), GREEN("GREEN", 'a', 10, 5635925), AQUA("AQUA", 'b', 11, 5636095), RED("RED", 'c', 12, 16733525), LIGHT_PURPLE("LIGHT_PURPLE", 'd', 13, 16733695), YELLOW("YELLOW", 'e', 14, 16777045), WHITE("WHITE", 'f', 15, 16777215), OBFUSCATED("OBFUSCATED", 'k', true), BOLD("BOLD", 'l', true), STRIKETHROUGH("STRIKETHROUGH", 'm', true), UNDERLINE("UNDERLINE", 'n', true), ITALIC("ITALIC", 'o', true), RESET("RESET", 'r', -1, (Integer) null);
+
+    private static final Map<String, EnumChatFormat> w = (Map) Arrays.stream(values()).collect(Collectors.toMap((enumchatformat) -> {
+        return c(enumchatformat.y);
+    }, (enumchatformat) -> {
+        return enumchatformat;
+    }));
+    private static final Pattern x = Pattern.compile("(?i)\u00a7[0-9A-FK-OR]");
+    private final String y;
+    public final char character;
+    private final boolean A;
+    private final String B;
+    private final int C;
+    @Nullable
+    private final Integer D;
+
+    private static String c(String s) {
+        return s.toLowerCase(Locale.ROOT).replaceAll("[^a-z]", "");
+    }
+
+    private EnumChatFormat(String s, char c0, int i, Integer integer) {
+        this(s, c0, false, i, integer);
+    }
+
+    private EnumChatFormat(String s, char c0, boolean flag) {
+        this(s, c0, flag, -1, (Integer) null);
+    }
+
+    private EnumChatFormat(String s, char c0, boolean flag, int i, Integer integer) {
+        this.y = s;
+        this.character = c0;
+        this.A = flag;
+        this.C = i;
+        this.D = integer;
+        this.B = "\u00a7" + c0;
+    }
+
+    public int b() {
+        return this.C;
+    }
+
+    public boolean isFormat() {
+        return this.A;
+    }
+
+    public boolean d() {
+        return !this.A && this != EnumChatFormat.RESET;
+    }
+
+    @Nullable
+    public Integer e() {
+        return this.D;
+    }
+
+    public String f() {
+        return this.name().toLowerCase(Locale.ROOT);
+    }
+
+    public String toString() {
+        return this.B;
+    }
+
+    @Nullable
+    public static String a(@Nullable String s) {
+        return s == null ? null : EnumChatFormat.x.matcher(s).replaceAll("");
+    }
+
+    @Nullable
+    public static EnumChatFormat b(@Nullable String s) {
+        return s == null ? null : (EnumChatFormat) EnumChatFormat.w.get(c(s));
+    }
+
+    @Nullable
+    public static EnumChatFormat a(int i) {
+        if (i < 0) {
+            return EnumChatFormat.RESET;
+        } else {
+            EnumChatFormat[] aenumchatformat = values();
+            int j = aenumchatformat.length;
+
+            for (int k = 0; k < j; ++k) {
+                EnumChatFormat enumchatformat = aenumchatformat[k];
+
+                if (enumchatformat.b() == i) {
+                    return enumchatformat;
+                }
+            }
+
+            return null;
+        }
+    }
+
+    public static Collection<String> a(boolean flag, boolean flag1) {
+        List<String> list = Lists.newArrayList();
+        EnumChatFormat[] aenumchatformat = values();
+        int i = aenumchatformat.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumChatFormat enumchatformat = aenumchatformat[j];
+
+            if ((!enumchatformat.d() || flag) && (!enumchatformat.isFormat() || flag1)) {
+                list.add(enumchatformat.f());
+            }
+        }
+
+        return list;
+    }
+}
diff --git a/src/main/java/net/minecraft/SharedConstants.java b/src/main/java/net/minecraft/SharedConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..b92975aa85fd79c70d6bec014284e8f55d0d3a4b
--- /dev/null
+++ b/src/main/java/net/minecraft/SharedConstants.java
@@ -0,0 +1,56 @@
+package net.minecraft;
+
+import com.mojang.bridge.game.GameVersion;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import io.netty.util.ResourceLeakDetector;
+import io.netty.util.ResourceLeakDetector.Level;
+import java.time.Duration;
+import net.minecraft.commands.CommandExceptionProvider;
+
+public class SharedConstants {
+
+    public static final Level a = Level.DISABLED;
+    public static final long b = Duration.ofMillis(300L).toNanos();
+    public static boolean c = true;
+    public static boolean d;
+    public static final char[] allowedCharacters = new char[]{'/', '\n', '\r', '\t', '\u0000', '\f', '`', '?', '*', '\\', '<', '>', '|', '"', ':'};
+    private static GameVersion f;
+
+    public static boolean isAllowedChatCharacter(char c0) {
+        return c0 != 167 && c0 >= ' ' && c0 != 127;
+    }
+
+    public static String a(String s) {
+        StringBuilder stringbuilder = new StringBuilder();
+        char[] achar = s.toCharArray();
+        int i = achar.length;
+
+        for (int j = 0; j < i; ++j) {
+            char c0 = achar[j];
+
+            if (isAllowedChatCharacter(c0)) {
+                stringbuilder.append(c0);
+            }
+        }
+
+        return stringbuilder.toString();
+    }
+
+    public static GameVersion getGameVersion() {
+        if (SharedConstants.f == null) {
+            SharedConstants.f = MinecraftVersion.a();
+        }
+
+        return SharedConstants.f;
+    }
+
+    public static int b() {
+        return 754;
+    }
+
+    static {
+        ResourceLeakDetector.setLevel(SharedConstants.a);
+        CommandSyntaxException.ENABLE_COMMAND_STACK_TRACES = false;
+        CommandSyntaxException.BUILT_IN_EXCEPTIONS = new CommandExceptionProvider();
+    }
+}
diff --git a/src/main/java/net/minecraft/SystemUtils.java b/src/main/java/net/minecraft/SystemUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..14b1a51b9b675aa175c32990402551fa43ec1599
--- /dev/null
+++ b/src/main/java/net/minecraft/SystemUtils.java
@@ -0,0 +1,504 @@
+package net.minecraft;
+
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.mojang.datafixers.DSL.TypeReference;
+import com.mojang.datafixers.DataFixUtils;
+import com.mojang.datafixers.types.Type;
+import com.mojang.serialization.DataResult;
+import it.unimi.dsi.fastutil.Hash.Strategy;
+import java.io.File;
+import java.io.IOException;
+import java.lang.management.ManagementFactory;
+import java.lang.management.RuntimeMXBean;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
+import java.time.Instant;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.Random;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinWorkerThread;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
+import java.util.function.LongSupplier;
+import java.util.function.Supplier;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.server.DispenserRegistry;
+import net.minecraft.util.MathHelper;
+import net.minecraft.util.datafix.DataConverterRegistry;
+import net.minecraft.world.level.block.state.properties.IBlockState;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class SystemUtils {
+
+    private static final AtomicInteger c = new AtomicInteger(1);
+    private static final ExecutorService d = a("Bootstrap");
+    private static final ExecutorService e = a("Main");
+    private static final ExecutorService f = n();
+    public static LongSupplier a = System::nanoTime;
+    public static final UUID b = new UUID(0L, 0L);
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static <K, V> Collector<Entry<? extends K, ? extends V>, ?, Map<K, V>> a() {
+        return Collectors.toMap(Entry::getKey, Entry::getValue);
+    }
+
+    public static <T extends Comparable<T>> String a(IBlockState<T> iblockstate, Object object) {
+        return iblockstate.a((Comparable) object);
+    }
+
+    public static String a(String s, @Nullable MinecraftKey minecraftkey) {
+        return minecraftkey == null ? s + ".unregistered_sadface" : s + '.' + minecraftkey.getNamespace() + '.' + minecraftkey.getKey().replace('/', '.');
+    }
+
+    public static long getMonotonicMillis() {
+        return getMonotonicNanos() / 1000000L;
+    }
+
+    public static long getMonotonicNanos() {
+        return SystemUtils.a.getAsLong();
+    }
+
+    public static long getTimeMillis() {
+        return Instant.now().toEpochMilli();
+    }
+
+    private static ExecutorService a(String s) {
+        int i = MathHelper.clamp(Runtime.getRuntime().availableProcessors() - 1, 1, 7);
+        Object object;
+
+        if (i <= 0) {
+            object = MoreExecutors.newDirectExecutorService();
+        } else {
+            object = new ForkJoinPool(i, (forkjoinpool) -> {
+                ForkJoinWorkerThread forkjoinworkerthread = new ForkJoinWorkerThread(forkjoinpool) {
+                    protected void onTermination(Throwable throwable) {
+                        if (throwable != null) {
+                            SystemUtils.LOGGER.warn("{} died", this.getName(), throwable);
+                        } else {
+                            SystemUtils.LOGGER.debug("{} shutdown", this.getName());
+                        }
+
+                        super.onTermination(throwable);
+                    }
+                };
+
+                forkjoinworkerthread.setName("Worker-" + s + "-" + SystemUtils.c.getAndIncrement());
+                return forkjoinworkerthread;
+            }, SystemUtils::a, true);
+        }
+
+        return (ExecutorService) object;
+    }
+
+    public static Executor e() {
+        return SystemUtils.d;
+    }
+
+    public static Executor f() {
+        return SystemUtils.e;
+    }
+
+    public static Executor g() {
+        return SystemUtils.f;
+    }
+
+    public static void h() {
+        a(SystemUtils.e);
+        a(SystemUtils.f);
+    }
+
+    private static void a(ExecutorService executorservice) {
+        executorservice.shutdown();
+
+        boolean flag;
+
+        try {
+            flag = executorservice.awaitTermination(3L, TimeUnit.SECONDS);
+        } catch (InterruptedException interruptedexception) {
+            flag = false;
+        }
+
+        if (!flag) {
+            executorservice.shutdownNow();
+        }
+
+    }
+
+    private static ExecutorService n() {
+        return Executors.newCachedThreadPool((runnable) -> {
+            Thread thread = new Thread(runnable);
+
+            thread.setName("IO-Worker-" + SystemUtils.c.getAndIncrement());
+            thread.setUncaughtExceptionHandler(SystemUtils::a);
+            return thread;
+        });
+    }
+
+    private static void a(Thread thread, Throwable throwable) {
+        c(throwable);
+        if (throwable instanceof CompletionException) {
+            throwable = throwable.getCause();
+        }
+
+        if (throwable instanceof ReportedException) {
+            DispenserRegistry.a(((ReportedException) throwable).a().e());
+            System.exit(-1);
+        }
+
+        SystemUtils.LOGGER.error(String.format("Caught exception in thread %s", thread), throwable);
+    }
+
+    @Nullable
+    public static Type<?> a(TypeReference typereference, String s) {
+        return !SharedConstants.c ? null : b(typereference, s);
+    }
+
+    @Nullable
+    private static Type<?> b(TypeReference typereference, String s) {
+        Type type = null;
+
+        try {
+            type = DataConverterRegistry.a().getSchema(DataFixUtils.makeKey(SharedConstants.getGameVersion().getWorldVersion())).getChoiceType(typereference, s);
+        } catch (IllegalArgumentException illegalargumentexception) {
+            SystemUtils.LOGGER.error("No data fixer registered for {}", s);
+            if (SharedConstants.d) {
+                throw illegalargumentexception;
+            }
+        }
+
+        return type;
+    }
+
+    public static SystemUtils.OS i() {
+        String s = System.getProperty("os.name").toLowerCase(Locale.ROOT);
+
+        return s.contains("win") ? SystemUtils.OS.WINDOWS : (s.contains("mac") ? SystemUtils.OS.OSX : (s.contains("solaris") ? SystemUtils.OS.SOLARIS : (s.contains("sunos") ? SystemUtils.OS.SOLARIS : (s.contains("linux") ? SystemUtils.OS.LINUX : (s.contains("unix") ? SystemUtils.OS.LINUX : SystemUtils.OS.UNKNOWN)))));
+    }
+
+    public static Stream<String> j() {
+        RuntimeMXBean runtimemxbean = ManagementFactory.getRuntimeMXBean();
+
+        return runtimemxbean.getInputArguments().stream().filter((s) -> {
+            return s.startsWith("-X");
+        });
+    }
+
+    public static <T> T a(List<T> list) {
+        return list.get(list.size() - 1);
+    }
+
+    public static <T> T a(Iterable<T> iterable, @Nullable T t0) {
+        Iterator<T> iterator = iterable.iterator();
+        T t1 = iterator.next();
+
+        if (t0 != null) {
+            Object object = t1;
+
+            while (object != t0) {
+                if (iterator.hasNext()) {
+                    object = iterator.next();
+                }
+            }
+
+            if (iterator.hasNext()) {
+                return iterator.next();
+            }
+        }
+
+        return t1;
+    }
+
+    public static <T> T b(Iterable<T> iterable, @Nullable T t0) {
+        Iterator<T> iterator = iterable.iterator();
+
+        Object object;
+        Object object1;
+
+        for (object1 = null; iterator.hasNext(); object1 = object) {
+            object = iterator.next();
+            if (object == t0) {
+                if (object1 == null) {
+                    object1 = iterator.hasNext() ? Iterators.getLast(iterator) : t0;
+                }
+                break;
+            }
+        }
+
+        return object1;
+    }
+
+    public static <T> T a(Supplier<T> supplier) {
+        return supplier.get();
+    }
+
+    public static <T> T a(T t0, Consumer<T> consumer) {
+        consumer.accept(t0);
+        return t0;
+    }
+
+    public static <K> Strategy<K> k() {
+        return SystemUtils.IdentityHashingStrategy.INSTANCE;
+    }
+
+    public static <V> CompletableFuture<List<V>> b(List<? extends CompletableFuture<? extends V>> list) {
+        List<V> list1 = Lists.newArrayListWithCapacity(list.size());
+        CompletableFuture<?>[] acompletablefuture = new CompletableFuture[list.size()];
+        CompletableFuture<Void> completablefuture = new CompletableFuture();
+
+        list.forEach((completablefuture1) -> {
+            int i = list1.size();
+
+            list1.add((Object) null);
+            acompletablefuture[i] = completablefuture1.whenComplete((object, throwable) -> {
+                if (throwable != null) {
+                    completablefuture.completeExceptionally(throwable);
+                } else {
+                    list1.set(i, object);
+                }
+
+            });
+        });
+        return CompletableFuture.allOf(acompletablefuture).applyToEither(completablefuture, (ovoid) -> {
+            return list1;
+        });
+    }
+
+    public static <T> Stream<T> a(Optional<? extends T> optional) {
+        return (Stream) DataFixUtils.orElseGet(optional.map(Stream::of), Stream::empty);
+    }
+
+    public static <T> Optional<T> a(Optional<T> optional, Consumer<T> consumer, Runnable runnable) {
+        if (optional.isPresent()) {
+            consumer.accept(optional.get());
+        } else {
+            runnable.run();
+        }
+
+        return optional;
+    }
+
+    public static Runnable a(Runnable runnable, Supplier<String> supplier) {
+        return runnable;
+    }
+
+    public static <T extends Throwable> T c(T t0) {
+        if (SharedConstants.d) {
+            SystemUtils.LOGGER.error("Trying to throw a fatal exception, pausing in IDE", t0);
+
+            while (true) {
+                try {
+                    Thread.sleep(1000L);
+                    SystemUtils.LOGGER.error("paused");
+                } catch (InterruptedException interruptedexception) {
+                    return t0;
+                }
+            }
+        } else {
+            return t0;
+        }
+    }
+
+    public static String d(Throwable throwable) {
+        return throwable.getCause() != null ? d(throwable.getCause()) : (throwable.getMessage() != null ? throwable.getMessage() : throwable.toString());
+    }
+
+    public static <T> T a(T[] at, Random random) {
+        return at[random.nextInt(at.length)];
+    }
+
+    public static int a(int[] aint, Random random) {
+        return aint[random.nextInt(aint.length)];
+    }
+
+    private static BooleanSupplier a(final Path path, final Path path1) {
+        return new BooleanSupplier() {
+            public boolean getAsBoolean() {
+                try {
+                    Files.move(path, path1);
+                    return true;
+                } catch (IOException ioexception) {
+                    SystemUtils.LOGGER.error("Failed to rename", ioexception);
+                    return false;
+                }
+            }
+
+            public String toString() {
+                return "rename " + path + " to " + path1;
+            }
+        };
+    }
+
+    private static BooleanSupplier a(final Path path) {
+        return new BooleanSupplier() {
+            public boolean getAsBoolean() {
+                try {
+                    Files.deleteIfExists(path);
+                    return true;
+                } catch (IOException ioexception) {
+                    SystemUtils.LOGGER.warn("Failed to delete", ioexception);
+                    return false;
+                }
+            }
+
+            public String toString() {
+                return "delete old " + path;
+            }
+        };
+    }
+
+    private static BooleanSupplier b(final Path path) {
+        return new BooleanSupplier() {
+            public boolean getAsBoolean() {
+                return !Files.exists(path, new LinkOption[0]);
+            }
+
+            public String toString() {
+                return "verify that " + path + " is deleted";
+            }
+        };
+    }
+
+    private static BooleanSupplier c(final Path path) {
+        return new BooleanSupplier() {
+            public boolean getAsBoolean() {
+                return Files.isRegularFile(path, new LinkOption[0]);
+            }
+
+            public String toString() {
+                return "verify that " + path + " is present";
+            }
+        };
+    }
+
+    private static boolean a(BooleanSupplier... abooleansupplier) {
+        BooleanSupplier[] abooleansupplier1 = abooleansupplier;
+        int i = abooleansupplier.length;
+
+        for (int j = 0; j < i; ++j) {
+            BooleanSupplier booleansupplier = abooleansupplier1[j];
+
+            if (!booleansupplier.getAsBoolean()) {
+                SystemUtils.LOGGER.warn("Failed to execute {}", booleansupplier);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private static boolean a(int i, String s, BooleanSupplier... abooleansupplier) {
+        for (int j = 0; j < i; ++j) {
+            if (a(abooleansupplier)) {
+                return true;
+            }
+
+            SystemUtils.LOGGER.error("Failed to {}, retrying {}/{}", s, j, i);
+        }
+
+        SystemUtils.LOGGER.error("Failed to {}, aborting, progress might be lost", s);
+        return false;
+    }
+
+    public static void a(File file, File file1, File file2) {
+        a(file.toPath(), file1.toPath(), file2.toPath());
+    }
+
+    public static void a(Path path, Path path1, Path path2) {
+        boolean flag = true;
+
+        if (!Files.exists(path, new LinkOption[0]) || a(10, "create backup " + path2, a(path2), a(path, path2), c(path2))) {
+            if (a(10, "remove old " + path, a(path), b(path))) {
+                if (!a(10, "replace " + path + " with " + path1, a(path1, path), c(path))) {
+                    a(10, "restore " + path + " from " + path2, a(path2, path), c(path));
+                }
+
+            }
+        }
+    }
+
+    public static Consumer<String> a(String s, Consumer<String> consumer) {
+        return (s1) -> {
+            consumer.accept(s + s1);
+        };
+    }
+
+    public static DataResult<int[]> a(IntStream intstream, int i) {
+        int[] aint = intstream.limit((long) (i + 1)).toArray();
+
+        if (aint.length != i) {
+            String s = "Input is not a list of " + i + " ints";
+
+            return aint.length >= i ? DataResult.error(s, Arrays.copyOf(aint, i)) : DataResult.error(s);
+        } else {
+            return DataResult.success(aint);
+        }
+    }
+
+    public static void l() {
+        Thread thread = new Thread("Timer hack thread") {
+            public void run() {
+                while (true) {
+                    try {
+                        Thread.sleep(2147483647L);
+                    } catch (InterruptedException interruptedexception) {
+                        SystemUtils.LOGGER.warn("Timer hack thread interrupted, that really should not happen");
+                        return;
+                    }
+                }
+            }
+        };
+
+        thread.setDaemon(true);
+        thread.setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(SystemUtils.LOGGER));
+        thread.start();
+    }
+
+    static enum IdentityHashingStrategy implements Strategy<Object> {
+
+        INSTANCE;
+
+        private IdentityHashingStrategy() {}
+
+        public int hashCode(Object object) {
+            return System.identityHashCode(object);
+        }
+
+        public boolean equals(Object object, Object object1) {
+            return object == object1;
+        }
+    }
+
+    public static enum OS {
+
+        LINUX, SOLARIS, WINDOWS {
+        },
+        OSX {
+        },
+        UNKNOWN;
+
+        private OS() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/advancements/critereon/CriterionTriggerAbstract.java b/src/main/java/net/minecraft/advancements/critereon/CriterionTriggerAbstract.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2ee816af000f0c94782d704e6372cd93fd34bb3
--- /dev/null
+++ b/src/main/java/net/minecraft/advancements/critereon/CriterionTriggerAbstract.java
@@ -0,0 +1,92 @@
+package net.minecraft.advancements.critereon;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.gson.JsonObject;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Predicate;
+import net.minecraft.advancements.CriterionTrigger;
+import net.minecraft.server.AdvancementDataPlayer;
+import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.world.level.storage.loot.LootTableInfo;
+
+public abstract class CriterionTriggerAbstract<T extends CriterionInstanceAbstract> implements CriterionTrigger<T> {
+
+    private final Map<AdvancementDataPlayer, Set<CriterionTrigger.a<T>>> a = Maps.newIdentityHashMap();
+
+    public CriterionTriggerAbstract() {}
+
+    @Override
+    public final void a(AdvancementDataPlayer advancementdataplayer, CriterionTrigger.a<T> criteriontrigger_a) {
+        ((Set) this.a.computeIfAbsent(advancementdataplayer, (advancementdataplayer1) -> {
+            return Sets.newHashSet();
+        })).add(criteriontrigger_a);
+    }
+
+    @Override
+    public final void b(AdvancementDataPlayer advancementdataplayer, CriterionTrigger.a<T> criteriontrigger_a) {
+        Set<CriterionTrigger.a<T>> set = (Set) this.a.get(advancementdataplayer);
+
+        if (set != null) {
+            set.remove(criteriontrigger_a);
+            if (set.isEmpty()) {
+                this.a.remove(advancementdataplayer);
+            }
+        }
+
+    }
+
+    @Override
+    public final void a(AdvancementDataPlayer advancementdataplayer) {
+        this.a.remove(advancementdataplayer);
+    }
+
+    protected abstract T b(JsonObject jsonobject, CriterionConditionEntity.b criterionconditionentity_b, LootDeserializationContext lootdeserializationcontext);
+
+    @Override
+    public final T a(JsonObject jsonobject, LootDeserializationContext lootdeserializationcontext) {
+        CriterionConditionEntity.b criterionconditionentity_b = CriterionConditionEntity.b.a(jsonobject, "player", lootdeserializationcontext);
+
+        return this.b(jsonobject, criterionconditionentity_b, lootdeserializationcontext);
+    }
+
+    protected void a(EntityPlayer entityplayer, Predicate<T> predicate) {
+        AdvancementDataPlayer advancementdataplayer = entityplayer.getAdvancementData();
+        Set<CriterionTrigger.a<T>> set = (Set) this.a.get(advancementdataplayer);
+
+        if (set != null && !set.isEmpty()) {
+            LootTableInfo loottableinfo = CriterionConditionEntity.b(entityplayer, entityplayer);
+            List<CriterionTrigger.a<T>> list = null;
+            Iterator iterator = set.iterator();
+
+            CriterionTrigger.a criteriontrigger_a;
+
+            while (iterator.hasNext()) {
+                criteriontrigger_a = (CriterionTrigger.a) iterator.next();
+                T t0 = (CriterionInstanceAbstract) criteriontrigger_a.a();
+
+                if (t0.b().a(loottableinfo) && predicate.test(t0)) {
+                    if (list == null) {
+                        list = Lists.newArrayList();
+                    }
+
+                    list.add(criteriontrigger_a);
+                }
+            }
+
+            if (list != null) {
+                iterator = list.iterator();
+
+                while (iterator.hasNext()) {
+                    criteriontrigger_a = (CriterionTrigger.a) iterator.next();
+                    criteriontrigger_a.a(advancementdataplayer);
+                }
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/commands/CustomFunction.java b/src/main/java/net/minecraft/commands/CustomFunction.java
new file mode 100644
index 0000000000000000000000000000000000000000..f96b132bb51c2d97703964a70fcb058f0649ac13
--- /dev/null
+++ b/src/main/java/net/minecraft/commands/CustomFunction.java
@@ -0,0 +1,156 @@
+package net.minecraft.commands;
+
+import com.google.common.collect.Lists;
+import com.mojang.brigadier.ParseResults;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import java.util.ArrayDeque;
+import java.util.List;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.server.CustomFunctionData;
+
+public class CustomFunction {
+
+    private final CustomFunction.c[] a;
+    private final MinecraftKey b;
+
+    public CustomFunction(MinecraftKey minecraftkey, CustomFunction.c[] acustomfunction_c) {
+        this.b = minecraftkey;
+        this.a = acustomfunction_c;
+    }
+
+    public MinecraftKey a() {
+        return this.b;
+    }
+
+    public CustomFunction.c[] b() {
+        return this.a;
+    }
+
+    public static CustomFunction a(MinecraftKey minecraftkey, com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> com_mojang_brigadier_commanddispatcher, CommandListenerWrapper commandlistenerwrapper, List<String> list) {
+        List<CustomFunction.c> list1 = Lists.newArrayListWithCapacity(list.size());
+
+        for (int i = 0; i < list.size(); ++i) {
+            int j = i + 1;
+            String s = ((String) list.get(i)).trim();
+            StringReader stringreader = new StringReader(s);
+
+            if (stringreader.canRead() && stringreader.peek() != '#') {
+                if (stringreader.peek() == '/') {
+                    stringreader.skip();
+                    if (stringreader.peek() == '/') {
+                        throw new IllegalArgumentException("Unknown or invalid command '" + s + "' on line " + j + " (if you intended to make a comment, use '#' not '//')");
+                    }
+
+                    String s1 = stringreader.readUnquotedString();
+
+                    throw new IllegalArgumentException("Unknown or invalid command '" + s + "' on line " + j + " (did you mean '" + s1 + "'? Do not use a preceding forwards slash.)");
+                }
+
+                try {
+                    ParseResults<CommandListenerWrapper> parseresults = com_mojang_brigadier_commanddispatcher.parse(stringreader, commandlistenerwrapper);
+
+                    if (parseresults.getReader().canRead()) {
+                        throw CommandDispatcher.a(parseresults);
+                    }
+
+                    list1.add(new CustomFunction.b(parseresults));
+                } catch (CommandSyntaxException commandsyntaxexception) {
+                    throw new IllegalArgumentException("Whilst parsing command on line " + j + ": " + commandsyntaxexception.getMessage());
+                }
+            }
+        }
+
+        return new CustomFunction(minecraftkey, (CustomFunction.c[]) list1.toArray(new CustomFunction.c[0]));
+    }
+
+    public static class a {
+
+        public static final CustomFunction.a a = new CustomFunction.a((MinecraftKey) null);
+        @Nullable
+        private final MinecraftKey b;
+        private boolean c;
+        private Optional<CustomFunction> d = Optional.empty();
+
+        public a(@Nullable MinecraftKey minecraftkey) {
+            this.b = minecraftkey;
+        }
+
+        public a(CustomFunction customfunction) {
+            this.c = true;
+            this.b = null;
+            this.d = Optional.of(customfunction);
+        }
+
+        public Optional<CustomFunction> a(CustomFunctionData customfunctiondata) {
+            if (!this.c) {
+                if (this.b != null) {
+                    this.d = customfunctiondata.a(this.b);
+                }
+
+                this.c = true;
+            }
+
+            return this.d;
+        }
+
+        @Nullable
+        public MinecraftKey a() {
+            return (MinecraftKey) this.d.map((customfunction) -> {
+                return customfunction.b;
+            }).orElse(this.b);
+        }
+    }
+
+    public static class d implements CustomFunction.c {
+
+        private final CustomFunction.a a;
+
+        public d(CustomFunction customfunction) {
+            this.a = new CustomFunction.a(customfunction);
+        }
+
+        @Override
+        public void a(CustomFunctionData customfunctiondata, CommandListenerWrapper commandlistenerwrapper, ArrayDeque<CustomFunctionData.a> arraydeque, int i) {
+            this.a.a(customfunctiondata).ifPresent((customfunction) -> {
+                CustomFunction.c[] acustomfunction_c = customfunction.b();
+                int j = i - arraydeque.size();
+                int k = Math.min(acustomfunction_c.length, j);
+
+                for (int l = k - 1; l >= 0; --l) {
+                    arraydeque.addFirst(new CustomFunctionData.a(customfunctiondata, commandlistenerwrapper, acustomfunction_c[l]));
+                }
+
+            });
+        }
+
+        public String toString() {
+            return "function " + this.a.a();
+        }
+    }
+
+    public static class b implements CustomFunction.c {
+
+        private final ParseResults<CommandListenerWrapper> a;
+
+        public b(ParseResults<CommandListenerWrapper> parseresults) {
+            this.a = parseresults;
+        }
+
+        @Override
+        public void a(CustomFunctionData customfunctiondata, CommandListenerWrapper commandlistenerwrapper, ArrayDeque<CustomFunctionData.a> arraydeque, int i) throws CommandSyntaxException {
+            customfunctiondata.getCommandDispatcher().execute(new ParseResults(this.a.getContext().withSource(commandlistenerwrapper), this.a.getReader(), this.a.getExceptions()));
+        }
+
+        public String toString() {
+            return this.a.getReader().getString();
+        }
+    }
+
+    public interface c {
+
+        void a(CustomFunctionData customfunctiondata, CommandListenerWrapper commandlistenerwrapper, ArrayDeque<CustomFunctionData.a> arraydeque, int i) throws CommandSyntaxException;
+    }
+}
diff --git a/src/main/java/net/minecraft/core/BaseBlockPosition.java b/src/main/java/net/minecraft/core/BaseBlockPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe3a3ce150de0e689c452b67d480b9d69471b330
--- /dev/null
+++ b/src/main/java/net/minecraft/core/BaseBlockPosition.java
@@ -0,0 +1,143 @@
+package net.minecraft.core;
+
+import com.google.common.base.MoreObjects;
+import com.mojang.serialization.Codec;
+import java.util.stream.IntStream;
+import javax.annotation.concurrent.Immutable;
+import net.minecraft.SystemUtils;
+import net.minecraft.util.MathHelper;
+
+@Immutable
+public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
+
+    public static final Codec<BaseBlockPosition> c = Codec.INT_STREAM.comapFlatMap((intstream) -> {
+        return SystemUtils.a(intstream, 3).map((aint) -> {
+            return new BaseBlockPosition(aint[0], aint[1], aint[2]);
+        });
+    }, (baseblockposition) -> {
+        return IntStream.of(new int[]{baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ()});
+    });
+    public static final BaseBlockPosition ZERO = new BaseBlockPosition(0, 0, 0);
+    private int a;
+    private int b;
+    private int e;
+
+    public BaseBlockPosition(int i, int j, int k) {
+        this.a = i;
+        this.b = j;
+        this.e = k;
+    }
+
+    public BaseBlockPosition(double d0, double d1, double d2) {
+        this(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof BaseBlockPosition)) {
+            return false;
+        } else {
+            BaseBlockPosition baseblockposition = (BaseBlockPosition) object;
+
+            return this.getX() != baseblockposition.getX() ? false : (this.getY() != baseblockposition.getY() ? false : this.getZ() == baseblockposition.getZ());
+        }
+    }
+
+    public int hashCode() {
+        return (this.getY() + this.getZ() * 31) * 31 + this.getX();
+    }
+
+    public int compareTo(BaseBlockPosition baseblockposition) {
+        return this.getY() == baseblockposition.getY() ? (this.getZ() == baseblockposition.getZ() ? this.getX() - baseblockposition.getX() : this.getZ() - baseblockposition.getZ()) : this.getY() - baseblockposition.getY();
+    }
+
+    public int getX() {
+        return this.a;
+    }
+
+    public int getY() {
+        return this.b;
+    }
+
+    public int getZ() {
+        return this.e;
+    }
+
+    protected void o(int i) {
+        this.a = i;
+    }
+
+    protected void p(int i) {
+        this.b = i;
+    }
+
+    protected void q(int i) {
+        this.e = i;
+    }
+
+    public BaseBlockPosition up() {
+        return this.up(1);
+    }
+
+    public BaseBlockPosition up(int i) {
+        return this.shift(EnumDirection.UP, i);
+    }
+
+    public BaseBlockPosition down() {
+        return this.down(1);
+    }
+
+    public BaseBlockPosition down(int i) {
+        return this.shift(EnumDirection.DOWN, i);
+    }
+
+    public BaseBlockPosition shift(EnumDirection enumdirection, int i) {
+        return i == 0 ? this : new BaseBlockPosition(this.getX() + enumdirection.getAdjacentX() * i, this.getY() + enumdirection.getAdjacentY() * i, this.getZ() + enumdirection.getAdjacentZ() * i);
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return new BaseBlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public boolean a(BaseBlockPosition baseblockposition, double d0) {
+        return this.distanceSquared((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ(), false) < d0 * d0;
+    }
+
+    public boolean a(IPosition iposition, double d0) {
+        return this.distanceSquared(iposition.getX(), iposition.getY(), iposition.getZ(), true) < d0 * d0;
+    }
+
+    public double j(BaseBlockPosition baseblockposition) {
+        return this.distanceSquared((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ(), true);
+    }
+
+    public double a(IPosition iposition, boolean flag) {
+        return this.distanceSquared(iposition.getX(), iposition.getY(), iposition.getZ(), flag);
+    }
+
+    public double distanceSquared(double d0, double d1, double d2, boolean flag) {
+        double d3 = flag ? 0.5D : 0.0D;
+        double d4 = (double) this.getX() + d3 - d0;
+        double d5 = (double) this.getY() + d3 - d1;
+        double d6 = (double) this.getZ() + d3 - d2;
+
+        return d4 * d4 + d5 * d5 + d6 * d6;
+    }
+
+    public int k(BaseBlockPosition baseblockposition) {
+        float f = (float) Math.abs(baseblockposition.getX() - this.getX());
+        float f1 = (float) Math.abs(baseblockposition.getY() - this.getY());
+        float f2 = (float) Math.abs(baseblockposition.getZ() - this.getZ());
+
+        return (int) (f + f1 + f2);
+    }
+
+    public int a(EnumDirection.EnumAxis enumdirection_enumaxis) {
+        return enumdirection_enumaxis.a(this.a, this.b, this.e);
+    }
+
+    public String toString() {
+        return MoreObjects.toStringHelper(this).add("x", this.getX()).add("y", this.getY()).add("z", this.getZ()).toString();
+    }
+}
diff --git a/src/main/java/net/minecraft/core/BlockPosition.java b/src/main/java/net/minecraft/core/BlockPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..f85889a232998520761731a17f3d293d3360fe2c
--- /dev/null
+++ b/src/main/java/net/minecraft/core/BlockPosition.java
@@ -0,0 +1,519 @@
+package net.minecraft.core;
+
+import com.google.common.collect.AbstractIterator;
+import com.mojang.serialization.Codec;
+import java.util.Optional;
+import java.util.Random;
+import java.util.function.Predicate;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import javax.annotation.concurrent.Immutable;
+import net.minecraft.SystemUtils;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.level.block.EnumBlockRotation;
+import net.minecraft.world.level.levelgen.structure.StructureBoundingBox;
+import net.minecraft.world.phys.AxisAlignedBB;
+import net.minecraft.world.phys.Vec3D;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+@Immutable
+public class BlockPosition extends BaseBlockPosition {
+
+    public static final Codec<BlockPosition> a = Codec.INT_STREAM.comapFlatMap((intstream) -> {
+        return SystemUtils.a(intstream, 3).map((aint) -> {
+            return new BlockPosition(aint[0], aint[1], aint[2]);
+        });
+    }, (blockposition) -> {
+        return IntStream.of(new int[]{blockposition.getX(), blockposition.getY(), blockposition.getZ()});
+    }).stable();
+    private static final Logger LOGGER = LogManager.getLogger();
+    public static final BlockPosition ZERO = new BlockPosition(0, 0, 0);
+    private static final int f = 1 + MathHelper.f(MathHelper.c(30000000));
+    private static final int g = BlockPosition.f;
+    private static final int h = 64 - BlockPosition.f - BlockPosition.g;
+    private static final long i = (1L << BlockPosition.f) - 1L;
+    private static final long j = (1L << BlockPosition.h) - 1L;
+    private static final long k = (1L << BlockPosition.g) - 1L;
+    private static final int l = BlockPosition.h;
+    private static final int m = BlockPosition.h + BlockPosition.g;
+
+    public BlockPosition(int i, int j, int k) {
+        super(i, j, k);
+    }
+
+    public BlockPosition(double d0, double d1, double d2) {
+        super(d0, d1, d2);
+    }
+
+    public BlockPosition(Vec3D vec3d) {
+        this(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public BlockPosition(IPosition iposition) {
+        this(iposition.getX(), iposition.getY(), iposition.getZ());
+    }
+
+    public BlockPosition(BaseBlockPosition baseblockposition) {
+        this(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public static long a(long i, EnumDirection enumdirection) {
+        return a(i, enumdirection.getAdjacentX(), enumdirection.getAdjacentY(), enumdirection.getAdjacentZ());
+    }
+
+    public static long a(long i, int j, int k, int l) {
+        return a(b(i) + j, c(i) + k, d(i) + l);
+    }
+
+    public static int b(long i) {
+        return (int) (i << 64 - BlockPosition.m - BlockPosition.f >> 64 - BlockPosition.f);
+    }
+
+    public static int c(long i) {
+        return (int) (i << 64 - BlockPosition.h >> 64 - BlockPosition.h);
+    }
+
+    public static int d(long i) {
+        return (int) (i << 64 - BlockPosition.l - BlockPosition.g >> 64 - BlockPosition.g);
+    }
+
+    public static BlockPosition fromLong(long i) {
+        return new BlockPosition(b(i), c(i), d(i));
+    }
+
+    public long asLong() {
+        return a(this.getX(), this.getY(), this.getZ());
+    }
+
+    public static long a(int i, int j, int k) {
+        long l = 0L;
+
+        l |= ((long) i & BlockPosition.i) << BlockPosition.m;
+        l |= ((long) j & BlockPosition.j) << 0;
+        l |= ((long) k & BlockPosition.k) << BlockPosition.l;
+        return l;
+    }
+
+    public static long f(long i) {
+        return i & -16L;
+    }
+
+    public BlockPosition a(double d0, double d1, double d2) {
+        return d0 == 0.0D && d1 == 0.0D && d2 == 0.0D ? this : new BlockPosition((double) this.getX() + d0, (double) this.getY() + d1, (double) this.getZ() + d2);
+    }
+
+    public BlockPosition b(int i, int j, int k) {
+        return i == 0 && j == 0 && k == 0 ? this : new BlockPosition(this.getX() + i, this.getY() + j, this.getZ() + k);
+    }
+
+    public BlockPosition a(BaseBlockPosition baseblockposition) {
+        return this.b(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public BlockPosition b(BaseBlockPosition baseblockposition) {
+        return this.b(-baseblockposition.getX(), -baseblockposition.getY(), -baseblockposition.getZ());
+    }
+
+    @Override
+    public BlockPosition up() {
+        return this.shift(EnumDirection.UP);
+    }
+
+    @Override
+    public BlockPosition up(int i) {
+        return this.shift(EnumDirection.UP, i);
+    }
+
+    @Override
+    public BlockPosition down() {
+        return this.shift(EnumDirection.DOWN);
+    }
+
+    @Override
+    public BlockPosition down(int i) {
+        return this.shift(EnumDirection.DOWN, i);
+    }
+
+    public BlockPosition north() {
+        return this.shift(EnumDirection.NORTH);
+    }
+
+    public BlockPosition north(int i) {
+        return this.shift(EnumDirection.NORTH, i);
+    }
+
+    public BlockPosition south() {
+        return this.shift(EnumDirection.SOUTH);
+    }
+
+    public BlockPosition south(int i) {
+        return this.shift(EnumDirection.SOUTH, i);
+    }
+
+    public BlockPosition west() {
+        return this.shift(EnumDirection.WEST);
+    }
+
+    public BlockPosition west(int i) {
+        return this.shift(EnumDirection.WEST, i);
+    }
+
+    public BlockPosition east() {
+        return this.shift(EnumDirection.EAST);
+    }
+
+    public BlockPosition east(int i) {
+        return this.shift(EnumDirection.EAST, i);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection) {
+        return new BlockPosition(this.getX() + enumdirection.getAdjacentX(), this.getY() + enumdirection.getAdjacentY(), this.getZ() + enumdirection.getAdjacentZ());
+    }
+
+    @Override
+    public BlockPosition shift(EnumDirection enumdirection, int i) {
+        return i == 0 ? this : new BlockPosition(this.getX() + enumdirection.getAdjacentX() * i, this.getY() + enumdirection.getAdjacentY() * i, this.getZ() + enumdirection.getAdjacentZ() * i);
+    }
+
+    public BlockPosition a(EnumDirection.EnumAxis enumdirection_enumaxis, int i) {
+        if (i == 0) {
+            return this;
+        } else {
+            int j = enumdirection_enumaxis == EnumDirection.EnumAxis.X ? i : 0;
+            int k = enumdirection_enumaxis == EnumDirection.EnumAxis.Y ? i : 0;
+            int l = enumdirection_enumaxis == EnumDirection.EnumAxis.Z ? i : 0;
+
+            return new BlockPosition(this.getX() + j, this.getY() + k, this.getZ() + l);
+        }
+    }
+
+    public BlockPosition a(EnumBlockRotation enumblockrotation) {
+        switch (enumblockrotation) {
+            case NONE:
+            default:
+                return this;
+            case CLOCKWISE_90:
+                return new BlockPosition(-this.getZ(), this.getY(), this.getX());
+            case CLOCKWISE_180:
+                return new BlockPosition(-this.getX(), this.getY(), -this.getZ());
+            case COUNTERCLOCKWISE_90:
+                return new BlockPosition(this.getZ(), this.getY(), -this.getX());
+        }
+    }
+
+    @Override
+    public BlockPosition d(BaseBlockPosition baseblockposition) {
+        return new BlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public BlockPosition immutableCopy() {
+        return this;
+    }
+
+    public BlockPosition.MutableBlockPosition i() {
+        return new BlockPosition.MutableBlockPosition(this.getX(), this.getY(), this.getZ());
+    }
+
+    public static Iterable<BlockPosition> a(Random random, int i, int j, int k, int l, int i1, int j1, int k1) {
+        int l1 = i1 - j + 1;
+        int i2 = j1 - k + 1;
+        int j2 = k1 - l + 1;
+
+        return () -> {
+            return new AbstractIterator<BlockPosition>() {
+                final BlockPosition.MutableBlockPosition a = new BlockPosition.MutableBlockPosition();
+                int b = i;
+
+                protected BlockPosition computeNext() {
+                    if (this.b <= 0) {
+                        return (BlockPosition) this.endOfData();
+                    } else {
+                        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = this.a.d(j + random.nextInt(l1), k + random.nextInt(i2), l + random.nextInt(j2));
+
+                        --this.b;
+                        return blockposition_mutableblockposition;
+                    }
+                }
+            };
+        };
+    }
+
+    public static Iterable<BlockPosition> a(BlockPosition blockposition, int i, int j, int k) {
+        int l = i + j + k;
+        int i1 = blockposition.getX();
+        int j1 = blockposition.getY();
+        int k1 = blockposition.getZ();
+
+        return () -> {
+            return new AbstractIterator<BlockPosition>() {
+                private final BlockPosition.MutableBlockPosition h = new BlockPosition.MutableBlockPosition();
+                private int i;
+                private int j;
+                private int k;
+                private int l;
+                private int m;
+                private boolean n;
+
+                protected BlockPosition computeNext() {
+                    if (this.n) {
+                        this.n = false;
+                        this.h.q(k1 - (this.h.getZ() - k1));
+                        return this.h;
+                    } else {
+                        BlockPosition.MutableBlockPosition blockposition_mutableblockposition;
+
+                        for (blockposition_mutableblockposition = null; blockposition_mutableblockposition == null; ++this.m) {
+                            if (this.m > this.k) {
+                                ++this.l;
+                                if (this.l > this.j) {
+                                    ++this.i;
+                                    if (this.i > l) {
+                                        return (BlockPosition) this.endOfData();
+                                    }
+
+                                    this.j = Math.min(i, this.i);
+                                    this.l = -this.j;
+                                }
+
+                                this.k = Math.min(j, this.i - Math.abs(this.l));
+                                this.m = -this.k;
+                            }
+
+                            int l1 = this.l;
+                            int i2 = this.m;
+                            int j2 = this.i - Math.abs(l1) - Math.abs(i2);
+
+                            if (j2 <= k) {
+                                this.n = j2 != 0;
+                                blockposition_mutableblockposition = this.h.d(i1 + l1, j1 + i2, k1 + j2);
+                            }
+                        }
+
+                        return blockposition_mutableblockposition;
+                    }
+                }
+            };
+        };
+    }
+
+    public static Optional<BlockPosition> a(BlockPosition blockposition, int i, int j, Predicate<BlockPosition> predicate) {
+        return b(blockposition, i, j, i).filter(predicate).findFirst();
+    }
+
+    public static Stream<BlockPosition> b(BlockPosition blockposition, int i, int j, int k) {
+        return StreamSupport.stream(a(blockposition, i, j, k).spliterator(), false);
+    }
+
+    public static Iterable<BlockPosition> a(BlockPosition blockposition, BlockPosition blockposition1) {
+        return b(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()), Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+    }
+
+    public static Stream<BlockPosition> b(BlockPosition blockposition, BlockPosition blockposition1) {
+        return StreamSupport.stream(a(blockposition, blockposition1).spliterator(), false);
+    }
+
+    public static Stream<BlockPosition> a(StructureBoundingBox structureboundingbox) {
+        return a(Math.min(structureboundingbox.a, structureboundingbox.d), Math.min(structureboundingbox.b, structureboundingbox.e), Math.min(structureboundingbox.c, structureboundingbox.f), Math.max(structureboundingbox.a, structureboundingbox.d), Math.max(structureboundingbox.b, structureboundingbox.e), Math.max(structureboundingbox.c, structureboundingbox.f));
+    }
+
+    public static Stream<BlockPosition> a(AxisAlignedBB axisalignedbb) {
+        return a(MathHelper.floor(axisalignedbb.minX), MathHelper.floor(axisalignedbb.minY), MathHelper.floor(axisalignedbb.minZ), MathHelper.floor(axisalignedbb.maxX), MathHelper.floor(axisalignedbb.maxY), MathHelper.floor(axisalignedbb.maxZ));
+    }
+
+    public static Stream<BlockPosition> a(int i, int j, int k, int l, int i1, int j1) {
+        return StreamSupport.stream(b(i, j, k, l, i1, j1).spliterator(), false);
+    }
+
+    public static Iterable<BlockPosition> b(int i, int j, int k, int l, int i1, int j1) {
+        int k1 = l - i + 1;
+        int l1 = i1 - j + 1;
+        int i2 = j1 - k + 1;
+        int j2 = k1 * l1 * i2;
+
+        return () -> {
+            return new AbstractIterator<BlockPosition>() {
+                private final BlockPosition.MutableBlockPosition g = new BlockPosition.MutableBlockPosition();
+                private int h;
+
+                protected BlockPosition computeNext() {
+                    if (this.h == j2) {
+                        return (BlockPosition) this.endOfData();
+                    } else {
+                        int k2 = this.h % k1;
+                        int l2 = this.h / k1;
+                        int i3 = l2 % l1;
+                        int j3 = l2 / l1;
+
+                        ++this.h;
+                        return this.g.d(i + k2, j + i3, k + j3);
+                    }
+                }
+            };
+        };
+    }
+
+    public static Iterable<BlockPosition.MutableBlockPosition> a(BlockPosition blockposition, int i, EnumDirection enumdirection, EnumDirection enumdirection1) {
+        Validate.validState(enumdirection.n() != enumdirection1.n(), "The two directions cannot be on the same axis", new Object[0]);
+        return () -> {
+            return new AbstractIterator<BlockPosition.MutableBlockPosition>() {
+                private final EnumDirection[] e = new EnumDirection[]{enumdirection, enumdirection1, enumdirection.opposite(), enumdirection1.opposite()};
+                private final BlockPosition.MutableBlockPosition f = blockposition.i().c(enumdirection1);
+                private final int g = 4 * i;
+                private int h = -1;
+                private int i;
+                private int j;
+                private int k;
+                private int l;
+                private int m;
+
+                {
+                    this.k = this.f.getX();
+                    this.l = this.f.getY();
+                    this.m = this.f.getZ();
+                }
+
+                protected BlockPosition.MutableBlockPosition computeNext() {
+                    this.f.d(this.k, this.l, this.m).c(this.e[(this.h + 4) % 4]);
+                    this.k = this.f.getX();
+                    this.l = this.f.getY();
+                    this.m = this.f.getZ();
+                    if (this.j >= this.i) {
+                        if (this.h >= this.g) {
+                            return (BlockPosition.MutableBlockPosition) this.endOfData();
+                        }
+
+                        ++this.h;
+                        this.j = 0;
+                        this.i = this.h / 2 + 1;
+                    }
+
+                    ++this.j;
+                    return this.f;
+                }
+            };
+        };
+    }
+
+    public static class MutableBlockPosition extends BlockPosition {
+
+        public MutableBlockPosition() {
+            this(0, 0, 0);
+        }
+
+        public MutableBlockPosition(int i, int j, int k) {
+            super(i, j, k);
+        }
+
+        public MutableBlockPosition(double d0, double d1, double d2) {
+            this(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        @Override
+        public BlockPosition a(double d0, double d1, double d2) {
+            return super.a(d0, d1, d2).immutableCopy();
+        }
+
+        @Override
+        public BlockPosition b(int i, int j, int k) {
+            return super.b(i, j, k).immutableCopy();
+        }
+
+        @Override
+        public BlockPosition shift(EnumDirection enumdirection, int i) {
+            return super.shift(enumdirection, i).immutableCopy();
+        }
+
+        @Override
+        public BlockPosition a(EnumDirection.EnumAxis enumdirection_enumaxis, int i) {
+            return super.a(enumdirection_enumaxis, i).immutableCopy();
+        }
+
+        @Override
+        public BlockPosition a(EnumBlockRotation enumblockrotation) {
+            return super.a(enumblockrotation).immutableCopy();
+        }
+
+        public BlockPosition.MutableBlockPosition d(int i, int j, int k) {
+            this.o(i);
+            this.p(j);
+            this.q(k);
+            return this;
+        }
+
+        public BlockPosition.MutableBlockPosition c(double d0, double d1, double d2) {
+            return this.d(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
+            return this.d(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+        }
+
+        public BlockPosition.MutableBlockPosition g(long i) {
+            return this.d(b(i), c(i), d(i));
+        }
+
+        public BlockPosition.MutableBlockPosition a(EnumAxisCycle enumaxiscycle, int i, int j, int k) {
+            return this.d(enumaxiscycle.a(i, j, k, EnumDirection.EnumAxis.X), enumaxiscycle.a(i, j, k, EnumDirection.EnumAxis.Y), enumaxiscycle.a(i, j, k, EnumDirection.EnumAxis.Z));
+        }
+
+        public BlockPosition.MutableBlockPosition a(BaseBlockPosition baseblockposition, EnumDirection enumdirection) {
+            return this.d(baseblockposition.getX() + enumdirection.getAdjacentX(), baseblockposition.getY() + enumdirection.getAdjacentY(), baseblockposition.getZ() + enumdirection.getAdjacentZ());
+        }
+
+        public BlockPosition.MutableBlockPosition a(BaseBlockPosition baseblockposition, int i, int j, int k) {
+            return this.d(baseblockposition.getX() + i, baseblockposition.getY() + j, baseblockposition.getZ() + k);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection) {
+            return this.c(enumdirection, 1);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection, int i) {
+            return this.d(this.getX() + enumdirection.getAdjacentX() * i, this.getY() + enumdirection.getAdjacentY() * i, this.getZ() + enumdirection.getAdjacentZ() * i);
+        }
+
+        public BlockPosition.MutableBlockPosition e(int i, int j, int k) {
+            return this.d(this.getX() + i, this.getY() + j, this.getZ() + k);
+        }
+
+        public BlockPosition.MutableBlockPosition h(BaseBlockPosition baseblockposition) {
+            return this.d(this.getX() + baseblockposition.getX(), this.getY() + baseblockposition.getY(), this.getZ() + baseblockposition.getZ());
+        }
+
+        public BlockPosition.MutableBlockPosition a(EnumDirection.EnumAxis enumdirection_enumaxis, int i, int j) {
+            switch (enumdirection_enumaxis) {
+                case X:
+                    return this.d(MathHelper.clamp(this.getX(), i, j), this.getY(), this.getZ());
+                case Y:
+                    return this.d(this.getX(), MathHelper.clamp(this.getY(), i, j), this.getZ());
+                case Z:
+                    return this.d(this.getX(), this.getY(), MathHelper.clamp(this.getZ(), i, j));
+                default:
+                    throw new IllegalStateException("Unable to clamp axis " + enumdirection_enumaxis);
+            }
+        }
+
+        @Override
+        public void o(int i) {
+            super.o(i);
+        }
+
+        @Override
+        public void p(int i) {
+            super.p(i);
+        }
+
+        @Override
+        public void q(int i) {
+            super.q(i);
+        }
+
+        @Override
+        public BlockPosition immutableCopy() {
+            return new BlockPosition(this);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/core/EnumDirection.java b/src/main/java/net/minecraft/core/EnumDirection.java
new file mode 100644
index 0000000000000000000000000000000000000000..a699005582293326076eaa80655c5343e6c22ff0
--- /dev/null
+++ b/src/main/java/net/minecraft/core/EnumDirection.java
@@ -0,0 +1,410 @@
+package net.minecraft.core;
+
+import com.google.common.collect.Iterators;
+import com.mojang.serialization.Codec;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Random;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.util.INamable;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+
+public enum EnumDirection implements INamable {
+
+    DOWN(0, 1, -1, "down", EnumDirection.EnumAxisDirection.NEGATIVE, EnumDirection.EnumAxis.Y, new BaseBlockPosition(0, -1, 0)), UP(1, 0, -1, "up", EnumDirection.EnumAxisDirection.POSITIVE, EnumDirection.EnumAxis.Y, new BaseBlockPosition(0, 1, 0)), NORTH(2, 3, 2, "north", EnumDirection.EnumAxisDirection.NEGATIVE, EnumDirection.EnumAxis.Z, new BaseBlockPosition(0, 0, -1)), SOUTH(3, 2, 0, "south", EnumDirection.EnumAxisDirection.POSITIVE, EnumDirection.EnumAxis.Z, new BaseBlockPosition(0, 0, 1)), WEST(4, 5, 1, "west", EnumDirection.EnumAxisDirection.NEGATIVE, EnumDirection.EnumAxis.X, new BaseBlockPosition(-1, 0, 0)), EAST(5, 4, 3, "east", EnumDirection.EnumAxisDirection.POSITIVE, EnumDirection.EnumAxis.X, new BaseBlockPosition(1, 0, 0));
+
+    private final int g;
+    private final int h;
+    private final int i;
+    private final String j;
+    private final EnumDirection.EnumAxis k;
+    private final EnumDirection.EnumAxisDirection l;
+    private final BaseBlockPosition m;
+    private static final EnumDirection[] n = values();
+    private static final Map<String, EnumDirection> o = (Map) Arrays.stream(EnumDirection.n).collect(Collectors.toMap(EnumDirection::m, (enumdirection) -> {
+        return enumdirection;
+    }));
+    private static final EnumDirection[] p = (EnumDirection[]) Arrays.stream(EnumDirection.n).sorted(Comparator.comparingInt((enumdirection) -> {
+        return enumdirection.g;
+    })).toArray((i) -> {
+        return new EnumDirection[i];
+    });
+    private static final EnumDirection[] q = (EnumDirection[]) Arrays.stream(EnumDirection.n).filter((enumdirection) -> {
+        return enumdirection.n().d();
+    }).sorted(Comparator.comparingInt((enumdirection) -> {
+        return enumdirection.i;
+    })).toArray((i) -> {
+        return new EnumDirection[i];
+    });
+    private static final Long2ObjectMap<EnumDirection> r = (Long2ObjectMap) Arrays.stream(EnumDirection.n).collect(Collectors.toMap((enumdirection) -> {
+        return (new BlockPosition(enumdirection.p())).asLong();
+    }, (enumdirection) -> {
+        return enumdirection;
+    }, (enumdirection, enumdirection1) -> {
+        throw new IllegalArgumentException("Duplicate keys");
+    }, Long2ObjectOpenHashMap::new));
+
+    private EnumDirection(int i, int j, int k, String s, EnumDirection.EnumAxisDirection enumdirection_enumaxisdirection, EnumDirection.EnumAxis enumdirection_enumaxis, BaseBlockPosition baseblockposition) {
+        this.g = i;
+        this.i = k;
+        this.h = j;
+        this.j = s;
+        this.k = enumdirection_enumaxis;
+        this.l = enumdirection_enumaxisdirection;
+        this.m = baseblockposition;
+    }
+
+    public static EnumDirection[] a(Entity entity) {
+        float f = entity.g(1.0F) * 0.017453292F;
+        float f1 = -entity.h(1.0F) * 0.017453292F;
+        float f2 = MathHelper.sin(f);
+        float f3 = MathHelper.cos(f);
+        float f4 = MathHelper.sin(f1);
+        float f5 = MathHelper.cos(f1);
+        boolean flag = f4 > 0.0F;
+        boolean flag1 = f2 < 0.0F;
+        boolean flag2 = f5 > 0.0F;
+        float f6 = flag ? f4 : -f4;
+        float f7 = flag1 ? -f2 : f2;
+        float f8 = flag2 ? f5 : -f5;
+        float f9 = f6 * f3;
+        float f10 = f8 * f3;
+        EnumDirection enumdirection = flag ? EnumDirection.EAST : EnumDirection.WEST;
+        EnumDirection enumdirection1 = flag1 ? EnumDirection.UP : EnumDirection.DOWN;
+        EnumDirection enumdirection2 = flag2 ? EnumDirection.SOUTH : EnumDirection.NORTH;
+
+        return f6 > f8 ? (f7 > f9 ? a(enumdirection1, enumdirection, enumdirection2) : (f10 > f7 ? a(enumdirection, enumdirection2, enumdirection1) : a(enumdirection, enumdirection1, enumdirection2))) : (f7 > f10 ? a(enumdirection1, enumdirection2, enumdirection) : (f9 > f7 ? a(enumdirection2, enumdirection, enumdirection1) : a(enumdirection2, enumdirection1, enumdirection)));
+    }
+
+    private static EnumDirection[] a(EnumDirection enumdirection, EnumDirection enumdirection1, EnumDirection enumdirection2) {
+        return new EnumDirection[]{enumdirection, enumdirection1, enumdirection2, enumdirection2.opposite(), enumdirection1.opposite(), enumdirection.opposite()};
+    }
+
+    public int c() {
+        return this.g;
+    }
+
+    public int get2DRotationValue() {
+        return this.i;
+    }
+
+    public EnumDirection.EnumAxisDirection e() {
+        return this.l;
+    }
+
+    public EnumDirection opposite() {
+        return fromType1(this.h);
+    }
+
+    public EnumDirection g() {
+        switch (this) {
+            case NORTH:
+                return EnumDirection.EAST;
+            case SOUTH:
+                return EnumDirection.WEST;
+            case WEST:
+                return EnumDirection.NORTH;
+            case EAST:
+                return EnumDirection.SOUTH;
+            default:
+                throw new IllegalStateException("Unable to get Y-rotated facing of " + this);
+        }
+    }
+
+    public EnumDirection h() {
+        switch (this) {
+            case NORTH:
+                return EnumDirection.WEST;
+            case SOUTH:
+                return EnumDirection.EAST;
+            case WEST:
+                return EnumDirection.SOUTH;
+            case EAST:
+                return EnumDirection.NORTH;
+            default:
+                throw new IllegalStateException("Unable to get CCW facing of " + this);
+        }
+    }
+
+    public int getAdjacentX() {
+        return this.m.getX();
+    }
+
+    public int getAdjacentY() {
+        return this.m.getY();
+    }
+
+    public int getAdjacentZ() {
+        return this.m.getZ();
+    }
+
+    public String m() {
+        return this.j;
+    }
+
+    public EnumDirection.EnumAxis n() {
+        return this.k;
+    }
+
+    public static EnumDirection fromType1(int i) {
+        return EnumDirection.p[MathHelper.a(i % EnumDirection.p.length)];
+    }
+
+    public static EnumDirection fromType2(int i) {
+        return EnumDirection.q[MathHelper.a(i % EnumDirection.q.length)];
+    }
+
+    @Nullable
+    public static EnumDirection a(int i, int j, int k) {
+        return (EnumDirection) EnumDirection.r.get(BlockPosition.a(i, j, k));
+    }
+
+    public static EnumDirection fromAngle(double d0) {
+        return fromType2(MathHelper.floor(d0 / 90.0D + 0.5D) & 3);
+    }
+
+    public static EnumDirection a(EnumDirection.EnumAxis enumdirection_enumaxis, EnumDirection.EnumAxisDirection enumdirection_enumaxisdirection) {
+        switch (enumdirection_enumaxis) {
+            case X:
+                return enumdirection_enumaxisdirection == EnumDirection.EnumAxisDirection.POSITIVE ? EnumDirection.EAST : EnumDirection.WEST;
+            case Y:
+                return enumdirection_enumaxisdirection == EnumDirection.EnumAxisDirection.POSITIVE ? EnumDirection.UP : EnumDirection.DOWN;
+            case Z:
+            default:
+                return enumdirection_enumaxisdirection == EnumDirection.EnumAxisDirection.POSITIVE ? EnumDirection.SOUTH : EnumDirection.NORTH;
+        }
+    }
+
+    public float o() {
+        return (float) ((this.i & 3) * 90);
+    }
+
+    public static EnumDirection a(Random random) {
+        return (EnumDirection) SystemUtils.a((Object[]) EnumDirection.n, random);
+    }
+
+    public static EnumDirection a(double d0, double d1, double d2) {
+        return a((float) d0, (float) d1, (float) d2);
+    }
+
+    public static EnumDirection a(float f, float f1, float f2) {
+        EnumDirection enumdirection = EnumDirection.NORTH;
+        float f3 = Float.MIN_VALUE;
+        EnumDirection[] aenumdirection = EnumDirection.n;
+        int i = aenumdirection.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDirection enumdirection1 = aenumdirection[j];
+            float f4 = f * (float) enumdirection1.m.getX() + f1 * (float) enumdirection1.m.getY() + f2 * (float) enumdirection1.m.getZ();
+
+            if (f4 > f3) {
+                f3 = f4;
+                enumdirection = enumdirection1;
+            }
+        }
+
+        return enumdirection;
+    }
+
+    public String toString() {
+        return this.j;
+    }
+
+    @Override
+    public String getName() {
+        return this.j;
+    }
+
+    public static EnumDirection a(EnumDirection.EnumAxisDirection enumdirection_enumaxisdirection, EnumDirection.EnumAxis enumdirection_enumaxis) {
+        EnumDirection[] aenumdirection = EnumDirection.n;
+        int i = aenumdirection.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDirection enumdirection = aenumdirection[j];
+
+            if (enumdirection.e() == enumdirection_enumaxisdirection && enumdirection.n() == enumdirection_enumaxis) {
+                return enumdirection;
+            }
+        }
+
+        throw new IllegalArgumentException("No such direction: " + enumdirection_enumaxisdirection + " " + enumdirection_enumaxis);
+    }
+
+    public BaseBlockPosition p() {
+        return this.m;
+    }
+
+    public boolean a(float f) {
+        float f1 = f * 0.017453292F;
+        float f2 = -MathHelper.sin(f1);
+        float f3 = MathHelper.cos(f1);
+
+        return (float) this.m.getX() * f2 + (float) this.m.getZ() * f3 > 0.0F;
+    }
+
+    public static enum EnumDirectionLimit implements Iterable<EnumDirection>, Predicate<EnumDirection> {
+
+        HORIZONTAL(new EnumDirection[]{EnumDirection.NORTH, EnumDirection.EAST, EnumDirection.SOUTH, EnumDirection.WEST}, new EnumDirection.EnumAxis[]{EnumDirection.EnumAxis.X, EnumDirection.EnumAxis.Z}), VERTICAL(new EnumDirection[]{EnumDirection.UP, EnumDirection.DOWN}, new EnumDirection.EnumAxis[]{EnumDirection.EnumAxis.Y});
+
+        private final EnumDirection[] c;
+        private final EnumDirection.EnumAxis[] d;
+
+        private EnumDirectionLimit(EnumDirection[] aenumdirection, EnumDirection.EnumAxis[] aenumdirection_enumaxis) {
+            this.c = aenumdirection;
+            this.d = aenumdirection_enumaxis;
+        }
+
+        public EnumDirection a(Random random) {
+            return (EnumDirection) SystemUtils.a((Object[]) this.c, random);
+        }
+
+        public EnumDirection.EnumAxis b(Random random) {
+            return (EnumDirection.EnumAxis) SystemUtils.a((Object[]) this.d, random);
+        }
+
+        public boolean test(@Nullable EnumDirection enumdirection) {
+            return enumdirection != null && enumdirection.n().e() == this;
+        }
+
+        public Iterator<EnumDirection> iterator() {
+            return Iterators.forArray(this.c);
+        }
+
+        public Stream<EnumDirection> a() {
+            return Arrays.stream(this.c);
+        }
+    }
+
+    public static enum EnumAxisDirection {
+
+        POSITIVE(1, "Towards positive"), NEGATIVE(-1, "Towards negative");
+
+        private final int c;
+        private final String d;
+
+        private EnumAxisDirection(int i, String s) {
+            this.c = i;
+            this.d = s;
+        }
+
+        public int a() {
+            return this.c;
+        }
+
+        public String toString() {
+            return this.d;
+        }
+
+        public EnumDirection.EnumAxisDirection c() {
+            return this == EnumDirection.EnumAxisDirection.POSITIVE ? EnumDirection.EnumAxisDirection.NEGATIVE : EnumDirection.EnumAxisDirection.POSITIVE;
+        }
+    }
+
+    public static enum EnumAxis implements INamable, Predicate<EnumDirection> {
+
+        X("x") {
+            @Override
+            public int a(int i, int j, int k) {
+                return i;
+            }
+
+            @Override
+            public double a(double d0, double d1, double d2) {
+                return d0;
+            }
+        },
+        Y("y") {
+            @Override
+            public int a(int i, int j, int k) {
+                return j;
+            }
+
+            @Override
+            public double a(double d0, double d1, double d2) {
+                return d1;
+            }
+        },
+        Z("z") {
+            @Override
+            public int a(int i, int j, int k) {
+                return k;
+            }
+
+            @Override
+            public double a(double d0, double d1, double d2) {
+                return d2;
+            }
+        };
+
+        private static final EnumDirection.EnumAxis[] e = values();
+        public static final Codec<EnumDirection.EnumAxis> d = INamable.a(EnumDirection.EnumAxis::values, EnumDirection.EnumAxis::a);
+        private static final Map<String, EnumDirection.EnumAxis> f = (Map) Arrays.stream(EnumDirection.EnumAxis.e).collect(Collectors.toMap(EnumDirection.EnumAxis::b, (enumdirection_enumaxis) -> {
+            return enumdirection_enumaxis;
+        }));
+        private final String g;
+
+        private EnumAxis(String s) {
+            this.g = s;
+        }
+
+        @Nullable
+        public static EnumDirection.EnumAxis a(String s) {
+            return (EnumDirection.EnumAxis) EnumDirection.EnumAxis.f.get(s.toLowerCase(Locale.ROOT));
+        }
+
+        public String b() {
+            return this.g;
+        }
+
+        public boolean c() {
+            return this == EnumDirection.EnumAxis.Y;
+        }
+
+        public boolean d() {
+            return this == EnumDirection.EnumAxis.X || this == EnumDirection.EnumAxis.Z;
+        }
+
+        public String toString() {
+            return this.g;
+        }
+
+        public static EnumDirection.EnumAxis a(Random random) {
+            return (EnumDirection.EnumAxis) SystemUtils.a((Object[]) EnumDirection.EnumAxis.e, random);
+        }
+
+        public boolean test(@Nullable EnumDirection enumdirection) {
+            return enumdirection != null && enumdirection.n() == this;
+        }
+
+        public EnumDirection.EnumDirectionLimit e() {
+            switch (this) {
+                case X:
+                case Z:
+                    return EnumDirection.EnumDirectionLimit.HORIZONTAL;
+                case Y:
+                    return EnumDirection.EnumDirectionLimit.VERTICAL;
+                default:
+                    throw new Error("Someone's been tampering with the universe!");
+            }
+        }
+
+        @Override
+        public String getName() {
+            return this.g;
+        }
+
+        public abstract int a(int i, int j, int k);
+
+        public abstract double a(double d0, double d1, double d2);
+    }
+}
diff --git a/src/main/java/net/minecraft/core/IRegistry.java b/src/main/java/net/minecraft/core/IRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e9ebeffdf66f8a959630b344149d17137c6901c
--- /dev/null
+++ b/src/main/java/net/minecraft/core/IRegistry.java
@@ -0,0 +1,448 @@
+package net.minecraft.core;
+
+import com.google.common.collect.Maps;
+import com.mojang.datafixers.util.Pair;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.Keyable;
+import com.mojang.serialization.Lifecycle;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import javax.annotation.Nullable;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.particles.Particle;
+import net.minecraft.core.particles.Particles;
+import net.minecraft.data.RegistryGeneration;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.stats.StatisticList;
+import net.minecraft.stats.StatisticWrapper;
+import net.minecraft.world.effect.MobEffectList;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.ai.attributes.AttributeBase;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.sensing.SensorType;
+import net.minecraft.world.entity.ai.village.poi.VillagePlaceType;
+import net.minecraft.world.entity.decoration.Paintings;
+import net.minecraft.world.entity.npc.VillagerProfession;
+import net.minecraft.world.entity.npc.VillagerType;
+import net.minecraft.world.entity.schedule.Activity;
+import net.minecraft.world.entity.schedule.Schedule;
+import net.minecraft.world.inventory.Containers;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.alchemy.PotionRegistry;
+import net.minecraft.world.item.alchemy.Potions;
+import net.minecraft.world.item.crafting.RecipeSerializer;
+import net.minecraft.world.item.crafting.Recipes;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.biome.WorldChunkManager;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.TileEntityTypes;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.dimension.DimensionManager;
+import net.minecraft.world.level.dimension.WorldDimension;
+import net.minecraft.world.level.levelgen.GeneratorSettingBase;
+import net.minecraft.world.level.levelgen.carver.WorldGenCarverAbstract;
+import net.minecraft.world.level.levelgen.carver.WorldGenCarverWrapper;
+import net.minecraft.world.level.levelgen.feature.StructureFeature;
+import net.minecraft.world.level.levelgen.feature.StructureGenerator;
+import net.minecraft.world.level.levelgen.feature.WorldGenFeatureConfigured;
+import net.minecraft.world.level.levelgen.feature.WorldGenFeatureStructurePieceType;
+import net.minecraft.world.level.levelgen.feature.WorldGenerator;
+import net.minecraft.world.level.levelgen.feature.blockplacers.WorldGenBlockPlacers;
+import net.minecraft.world.level.levelgen.feature.featuresize.FeatureSizeType;
+import net.minecraft.world.level.levelgen.feature.foliageplacers.WorldGenFoilagePlacers;
+import net.minecraft.world.level.levelgen.feature.stateproviders.WorldGenFeatureStateProviders;
+import net.minecraft.world.level.levelgen.feature.structures.WorldGenFeatureDefinedStructurePoolTemplate;
+import net.minecraft.world.level.levelgen.feature.structures.WorldGenFeatureDefinedStructurePools;
+import net.minecraft.world.level.levelgen.feature.treedecorators.WorldGenFeatureTrees;
+import net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacers;
+import net.minecraft.world.level.levelgen.placement.WorldGenDecorator;
+import net.minecraft.world.level.levelgen.structure.templatesystem.DefinedStructureRuleTestType;
+import net.minecraft.world.level.levelgen.structure.templatesystem.DefinedStructureStructureProcessorType;
+import net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTestType;
+import net.minecraft.world.level.levelgen.structure.templatesystem.ProcessorList;
+import net.minecraft.world.level.levelgen.surfacebuilders.WorldGenSurface;
+import net.minecraft.world.level.levelgen.surfacebuilders.WorldGenSurfaceComposite;
+import net.minecraft.world.level.material.FluidType;
+import net.minecraft.world.level.material.FluidTypes;
+import net.minecraft.world.level.storage.loot.entries.LootEntries;
+import net.minecraft.world.level.storage.loot.entries.LootEntryType;
+import net.minecraft.world.level.storage.loot.functions.LootItemFunctionType;
+import net.minecraft.world.level.storage.loot.functions.LootItemFunctions;
+import net.minecraft.world.level.storage.loot.predicates.LootItemConditionType;
+import net.minecraft.world.level.storage.loot.predicates.LootItemConditions;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public abstract class IRegistry<T> implements Codec<T>, Keyable, Registry<T> {
+
+    protected static final Logger LOGGER = LogManager.getLogger();
+    private static final Map<MinecraftKey, Supplier<?>> a = Maps.newLinkedHashMap();
+    public static final MinecraftKey d = new MinecraftKey("root");
+    protected static final IRegistryWritable<IRegistryWritable<?>> e = new RegistryMaterials<>(a("root"), Lifecycle.experimental());
+    public static final IRegistry<? extends IRegistry<?>> f = IRegistry.e;
+    public static final ResourceKey<IRegistry<SoundEffect>> g = a("sound_event");
+    public static final ResourceKey<IRegistry<FluidType>> h = a("fluid");
+    public static final ResourceKey<IRegistry<MobEffectList>> i = a("mob_effect");
+    public static final ResourceKey<IRegistry<Block>> j = a("block");
+    public static final ResourceKey<IRegistry<Enchantment>> k = a("enchantment");
+    public static final ResourceKey<IRegistry<EntityTypes<?>>> l = a("entity_type");
+    public static final ResourceKey<IRegistry<Item>> m = a("item");
+    public static final ResourceKey<IRegistry<PotionRegistry>> n = a("potion");
+    public static final ResourceKey<IRegistry<Particle<?>>> o = a("particle_type");
+    public static final ResourceKey<IRegistry<TileEntityTypes<?>>> p = a("block_entity_type");
+    public static final ResourceKey<IRegistry<Paintings>> q = a("motive");
+    public static final ResourceKey<IRegistry<MinecraftKey>> r = a("custom_stat");
+    public static final ResourceKey<IRegistry<ChunkStatus>> s = a("chunk_status");
+    public static final ResourceKey<IRegistry<DefinedStructureRuleTestType<?>>> t = a("rule_test");
+    public static final ResourceKey<IRegistry<PosRuleTestType<?>>> u = a("pos_rule_test");
+    public static final ResourceKey<IRegistry<Containers<?>>> v = a("menu");
+    public static final ResourceKey<IRegistry<Recipes<?>>> w = a("recipe_type");
+    public static final ResourceKey<IRegistry<RecipeSerializer<?>>> x = a("recipe_serializer");
+    public static final ResourceKey<IRegistry<AttributeBase>> y = a("attribute");
+    public static final ResourceKey<IRegistry<StatisticWrapper<?>>> z = a("stat_type");
+    public static final ResourceKey<IRegistry<VillagerType>> A = a("villager_type");
+    public static final ResourceKey<IRegistry<VillagerProfession>> B = a("villager_profession");
+    public static final ResourceKey<IRegistry<VillagePlaceType>> C = a("point_of_interest_type");
+    public static final ResourceKey<IRegistry<MemoryModuleType<?>>> D = a("memory_module_type");
+    public static final ResourceKey<IRegistry<SensorType<?>>> E = a("sensor_type");
+    public static final ResourceKey<IRegistry<Schedule>> F = a("schedule");
+    public static final ResourceKey<IRegistry<Activity>> G = a("activity");
+    public static final ResourceKey<IRegistry<LootEntryType>> H = a("loot_pool_entry_type");
+    public static final ResourceKey<IRegistry<LootItemFunctionType>> I = a("loot_function_type");
+    public static final ResourceKey<IRegistry<LootItemConditionType>> J = a("loot_condition_type");
+    public static final ResourceKey<IRegistry<DimensionManager>> K = a("dimension_type");
+    public static final ResourceKey<IRegistry<World>> L = a("dimension");
+    public static final ResourceKey<IRegistry<WorldDimension>> M = a("dimension");
+    public static final IRegistry<SoundEffect> SOUND_EVENT = a(IRegistry.g, () -> {
+        return SoundEffects.ENTITY_ITEM_PICKUP;
+    });
+    public static final RegistryBlocks<FluidType> FLUID = a(IRegistry.h, "empty", () -> {
+        return FluidTypes.EMPTY;
+    });
+    public static final IRegistry<MobEffectList> MOB_EFFECT = a(IRegistry.i, () -> {
+        return MobEffects.LUCK;
+    });
+    public static final RegistryBlocks<Block> BLOCK = a(IRegistry.j, "air", () -> {
+        return Blocks.AIR;
+    });
+    public static final IRegistry<Enchantment> ENCHANTMENT = a(IRegistry.k, () -> {
+        return Enchantments.LOOT_BONUS_BLOCKS;
+    });
+    public static final RegistryBlocks<EntityTypes<?>> ENTITY_TYPE = a(IRegistry.l, "pig", () -> {
+        return EntityTypes.PIG;
+    });
+    public static final RegistryBlocks<Item> ITEM = a(IRegistry.m, "air", () -> {
+        return Items.AIR;
+    });
+    public static final RegistryBlocks<PotionRegistry> POTION = a(IRegistry.n, "empty", () -> {
+        return Potions.EMPTY;
+    });
+    public static final IRegistry<Particle<?>> PARTICLE_TYPE = a(IRegistry.o, () -> {
+        return Particles.BLOCK;
+    });
+    public static final IRegistry<TileEntityTypes<?>> BLOCK_ENTITY_TYPE = a(IRegistry.p, () -> {
+        return TileEntityTypes.FURNACE;
+    });
+    public static final RegistryBlocks<Paintings> MOTIVE = a(IRegistry.q, "kebab", () -> {
+        return Paintings.a;
+    });
+    public static final IRegistry<MinecraftKey> CUSTOM_STAT = a(IRegistry.r, () -> {
+        return StatisticList.JUMP;
+    });
+    public static final RegistryBlocks<ChunkStatus> CHUNK_STATUS = a(IRegistry.s, "empty", () -> {
+        return ChunkStatus.EMPTY;
+    });
+    public static final IRegistry<DefinedStructureRuleTestType<?>> RULE_TEST = a(IRegistry.t, () -> {
+        return DefinedStructureRuleTestType.a;
+    });
+    public static final IRegistry<PosRuleTestType<?>> POS_RULE_TEST = a(IRegistry.u, () -> {
+        return PosRuleTestType.a;
+    });
+    public static final IRegistry<Containers<?>> MENU = a(IRegistry.v, () -> {
+        return Containers.ANVIL;
+    });
+    public static final IRegistry<Recipes<?>> RECIPE_TYPE = a(IRegistry.w, () -> {
+        return Recipes.CRAFTING;
+    });
+    public static final IRegistry<RecipeSerializer<?>> RECIPE_SERIALIZER = a(IRegistry.x, () -> {
+        return RecipeSerializer.b;
+    });
+    public static final IRegistry<AttributeBase> ATTRIBUTE = a(IRegistry.y, () -> {
+        return GenericAttributes.LUCK;
+    });
+    public static final IRegistry<StatisticWrapper<?>> STATS = a(IRegistry.z, () -> {
+        return StatisticList.ITEM_USED;
+    });
+    public static final RegistryBlocks<VillagerType> VILLAGER_TYPE = a(IRegistry.A, "plains", () -> {
+        return VillagerType.PLAINS;
+    });
+    public static final RegistryBlocks<VillagerProfession> VILLAGER_PROFESSION = a(IRegistry.B, "none", () -> {
+        return VillagerProfession.NONE;
+    });
+    public static final RegistryBlocks<VillagePlaceType> POINT_OF_INTEREST_TYPE = a(IRegistry.C, "unemployed", () -> {
+        return VillagePlaceType.c;
+    });
+    public static final RegistryBlocks<MemoryModuleType<?>> MEMORY_MODULE_TYPE = a(IRegistry.D, "dummy", () -> {
+        return MemoryModuleType.DUMMY;
+    });
+    public static final RegistryBlocks<SensorType<?>> SENSOR_TYPE = a(IRegistry.E, "dummy", () -> {
+        return SensorType.a;
+    });
+    public static final IRegistry<Schedule> SCHEDULE = a(IRegistry.F, () -> {
+        return Schedule.EMPTY;
+    });
+    public static final IRegistry<Activity> ACTIVITY = a(IRegistry.G, () -> {
+        return Activity.IDLE;
+    });
+    public static final IRegistry<LootEntryType> ao = a(IRegistry.H, () -> {
+        return LootEntries.a;
+    });
+    public static final IRegistry<LootItemFunctionType> ap = a(IRegistry.I, () -> {
+        return LootItemFunctions.b;
+    });
+    public static final IRegistry<LootItemConditionType> aq = a(IRegistry.J, () -> {
+        return LootItemConditions.a;
+    });
+    public static final ResourceKey<IRegistry<GeneratorSettingBase>> ar = a("worldgen/noise_settings");
+    public static final ResourceKey<IRegistry<WorldGenSurfaceComposite<?>>> as = a("worldgen/configured_surface_builder");
+    public static final ResourceKey<IRegistry<WorldGenCarverWrapper<?>>> at = a("worldgen/configured_carver");
+    public static final ResourceKey<IRegistry<WorldGenFeatureConfigured<?, ?>>> au = a("worldgen/configured_feature");
+    public static final ResourceKey<IRegistry<StructureFeature<?, ?>>> av = a("worldgen/configured_structure_feature");
+    public static final ResourceKey<IRegistry<ProcessorList>> aw = a("worldgen/processor_list");
+    public static final ResourceKey<IRegistry<WorldGenFeatureDefinedStructurePoolTemplate>> ax = a("worldgen/template_pool");
+    public static final ResourceKey<IRegistry<BiomeBase>> ay = a("worldgen/biome");
+    public static final ResourceKey<IRegistry<WorldGenSurface<?>>> az = a("worldgen/surface_builder");
+    public static final IRegistry<WorldGenSurface<?>> SURFACE_BUILDER = a(IRegistry.az, () -> {
+        return WorldGenSurface.v;
+    });
+    public static final ResourceKey<IRegistry<WorldGenCarverAbstract<?>>> aB = a("worldgen/carver");
+    public static final IRegistry<WorldGenCarverAbstract<?>> CARVER = a(IRegistry.aB, () -> {
+        return WorldGenCarverAbstract.a;
+    });
+    public static final ResourceKey<IRegistry<WorldGenerator<?>>> aD = a("worldgen/feature");
+    public static final IRegistry<WorldGenerator<?>> FEATURE = a(IRegistry.aD, () -> {
+        return WorldGenerator.ORE;
+    });
+    public static final ResourceKey<IRegistry<StructureGenerator<?>>> aF = a("worldgen/structure_feature");
+    public static final IRegistry<StructureGenerator<?>> STRUCTURE_FEATURE = a(IRegistry.aF, () -> {
+        return StructureGenerator.MINESHAFT;
+    });
+    public static final ResourceKey<IRegistry<WorldGenFeatureStructurePieceType>> aH = a("worldgen/structure_piece");
+    public static final IRegistry<WorldGenFeatureStructurePieceType> STRUCTURE_PIECE = a(IRegistry.aH, () -> {
+        return WorldGenFeatureStructurePieceType.c;
+    });
+    public static final ResourceKey<IRegistry<WorldGenDecorator<?>>> aJ = a("worldgen/decorator");
+    public static final IRegistry<WorldGenDecorator<?>> DECORATOR = a(IRegistry.aJ, () -> {
+        return WorldGenDecorator.a;
+    });
+    public static final ResourceKey<IRegistry<WorldGenFeatureStateProviders<?>>> aL = a("worldgen/block_state_provider_type");
+    public static final ResourceKey<IRegistry<WorldGenBlockPlacers<?>>> aM = a("worldgen/block_placer_type");
+    public static final ResourceKey<IRegistry<WorldGenFoilagePlacers<?>>> aN = a("worldgen/foliage_placer_type");
+    public static final ResourceKey<IRegistry<TrunkPlacers<?>>> aO = a("worldgen/trunk_placer_type");
+    public static final ResourceKey<IRegistry<WorldGenFeatureTrees<?>>> aP = a("worldgen/tree_decorator_type");
+    public static final ResourceKey<IRegistry<FeatureSizeType<?>>> aQ = a("worldgen/feature_size_type");
+    public static final ResourceKey<IRegistry<Codec<? extends WorldChunkManager>>> aR = a("worldgen/biome_source");
+    public static final ResourceKey<IRegistry<Codec<? extends ChunkGenerator>>> aS = a("worldgen/chunk_generator");
+    public static final ResourceKey<IRegistry<DefinedStructureStructureProcessorType<?>>> aT = a("worldgen/structure_processor");
+    public static final ResourceKey<IRegistry<WorldGenFeatureDefinedStructurePools<?>>> aU = a("worldgen/structure_pool_element");
+    public static final IRegistry<WorldGenFeatureStateProviders<?>> BLOCK_STATE_PROVIDER_TYPE = a(IRegistry.aL, () -> {
+        return WorldGenFeatureStateProviders.a;
+    });
+    public static final IRegistry<WorldGenBlockPlacers<?>> BLOCK_PLACER_TYPE = a(IRegistry.aM, () -> {
+        return WorldGenBlockPlacers.a;
+    });
+    public static final IRegistry<WorldGenFoilagePlacers<?>> FOLIAGE_PLACER_TYPE = a(IRegistry.aN, () -> {
+        return WorldGenFoilagePlacers.a;
+    });
+    public static final IRegistry<TrunkPlacers<?>> TRUNK_PLACER_TYPE = a(IRegistry.aO, () -> {
+        return TrunkPlacers.a;
+    });
+    public static final IRegistry<WorldGenFeatureTrees<?>> TREE_DECORATOR_TYPE = a(IRegistry.aP, () -> {
+        return WorldGenFeatureTrees.b;
+    });
+    public static final IRegistry<FeatureSizeType<?>> FEATURE_SIZE_TYPE = a(IRegistry.aQ, () -> {
+        return FeatureSizeType.a;
+    });
+    public static final IRegistry<Codec<? extends WorldChunkManager>> BIOME_SOURCE = a(IRegistry.aR, Lifecycle.stable(), () -> {
+        return WorldChunkManager.a;
+    });
+    public static final IRegistry<Codec<? extends ChunkGenerator>> CHUNK_GENERATOR = a(IRegistry.aS, Lifecycle.stable(), () -> {
+        return ChunkGenerator.a;
+    });
+    public static final IRegistry<DefinedStructureStructureProcessorType<?>> STRUCTURE_PROCESSOR = a(IRegistry.aT, () -> {
+        return DefinedStructureStructureProcessorType.a;
+    });
+    public static final IRegistry<WorldGenFeatureDefinedStructurePools<?>> STRUCTURE_POOL_ELEMENT = a(IRegistry.aU, () -> {
+        return WorldGenFeatureDefinedStructurePools.d;
+    });
+    private final ResourceKey<? extends IRegistry<T>> b;
+    private final Lifecycle bf;
+
+    private static <T> ResourceKey<IRegistry<T>> a(String s) {
+        return ResourceKey.a(new MinecraftKey(s));
+    }
+
+    public static <T extends IRegistryWritable<?>> void a(IRegistryWritable<T> iregistrywritable) {
+        iregistrywritable.forEach((iregistrywritable1) -> {
+            if (iregistrywritable1.keySet().isEmpty()) {
+                IRegistry.LOGGER.error("Registry '{}' was empty after loading", iregistrywritable.getKey(iregistrywritable1));
+                if (SharedConstants.d) {
+                    throw new IllegalStateException("Registry: '" + iregistrywritable.getKey(iregistrywritable1) + "' is empty, not allowed, fix me!");
+                }
+            }
+
+            if (iregistrywritable1 instanceof RegistryBlocks) {
+                MinecraftKey minecraftkey = ((RegistryBlocks) iregistrywritable1).a();
+
+                Validate.notNull(iregistrywritable1.get(minecraftkey), "Missing default of DefaultedMappedRegistry: " + minecraftkey, new Object[0]);
+            }
+
+        });
+    }
+
+    private static <T> IRegistry<T> a(ResourceKey<? extends IRegistry<T>> resourcekey, Supplier<T> supplier) {
+        return a(resourcekey, Lifecycle.experimental(), supplier);
+    }
+
+    private static <T> RegistryBlocks<T> a(ResourceKey<? extends IRegistry<T>> resourcekey, String s, Supplier<T> supplier) {
+        return a(resourcekey, s, Lifecycle.experimental(), supplier);
+    }
+
+    private static <T> IRegistry<T> a(ResourceKey<? extends IRegistry<T>> resourcekey, Lifecycle lifecycle, Supplier<T> supplier) {
+        return a(resourcekey, (IRegistryWritable) (new RegistryMaterials<>(resourcekey, lifecycle)), supplier, lifecycle);
+    }
+
+    private static <T> RegistryBlocks<T> a(ResourceKey<? extends IRegistry<T>> resourcekey, String s, Lifecycle lifecycle, Supplier<T> supplier) {
+        return (RegistryBlocks) a(resourcekey, (IRegistryWritable) (new RegistryBlocks<>(s, resourcekey, lifecycle)), supplier, lifecycle);
+    }
+
+    private static <T, R extends IRegistryWritable<T>> R a(ResourceKey<? extends IRegistry<T>> resourcekey, R r0, Supplier<T> supplier, Lifecycle lifecycle) {
+        MinecraftKey minecraftkey = resourcekey.a();
+
+        IRegistry.a.put(minecraftkey, supplier);
+        IRegistryWritable<R> iregistrywritable = IRegistry.e;
+
+        return (IRegistryWritable) iregistrywritable.a(resourcekey, (Object) r0, lifecycle);
+    }
+
+    protected IRegistry(ResourceKey<? extends IRegistry<T>> resourcekey, Lifecycle lifecycle) {
+        this.b = resourcekey;
+        this.bf = lifecycle;
+    }
+
+    public ResourceKey<? extends IRegistry<T>> f() {
+        return this.b;
+    }
+
+    public String toString() {
+        return "Registry[" + this.b + " (" + this.bf + ")]";
+    }
+
+    public <U> DataResult<Pair<T, U>> decode(DynamicOps<U> dynamicops, U u0) {
+        return dynamicops.compressMaps() ? dynamicops.getNumberValue(u0).flatMap((number) -> {
+            T t0 = this.fromId(number.intValue());
+
+            return t0 == null ? DataResult.error("Unknown registry id: " + number) : DataResult.success(t0, this.d(t0));
+        }).map((object) -> {
+            return Pair.of(object, dynamicops.empty());
+        }) : MinecraftKey.a.decode(dynamicops, u0).flatMap((pair) -> {
+            T t0 = this.get((MinecraftKey) pair.getFirst());
+
+            return t0 == null ? DataResult.error("Unknown registry key: " + pair.getFirst()) : DataResult.success(Pair.of(t0, pair.getSecond()), this.d(t0));
+        });
+    }
+
+    public <U> DataResult<U> encode(T t0, DynamicOps<U> dynamicops, U u0) {
+        MinecraftKey minecraftkey = this.getKey(t0);
+
+        return minecraftkey == null ? DataResult.error("Unknown registry element " + t0) : (dynamicops.compressMaps() ? dynamicops.mergeToPrimitive(u0, dynamicops.createInt(this.a(t0))).setLifecycle(this.bf) : dynamicops.mergeToPrimitive(u0, dynamicops.createString(minecraftkey.toString())).setLifecycle(this.bf));
+    }
+
+    public <U> Stream<U> keys(DynamicOps<U> dynamicops) {
+        return this.keySet().stream().map((minecraftkey) -> {
+            return dynamicops.createString(minecraftkey.toString());
+        });
+    }
+
+    @Nullable
+    public abstract MinecraftKey getKey(T t0);
+
+    public abstract Optional<ResourceKey<T>> c(T t0);
+
+    @Override
+    public abstract int a(@Nullable T t0);
+
+    @Nullable
+    public abstract T a(@Nullable ResourceKey<T> resourcekey);
+
+    @Nullable
+    public abstract T get(@Nullable MinecraftKey minecraftkey);
+
+    protected abstract Lifecycle d(T t0);
+
+    public abstract Lifecycle b();
+
+    public Optional<T> getOptional(@Nullable MinecraftKey minecraftkey) {
+        return Optional.ofNullable(this.get(minecraftkey));
+    }
+
+    public T d(ResourceKey<T> resourcekey) {
+        T t0 = this.a(resourcekey);
+
+        if (t0 == null) {
+            throw new IllegalStateException("Missing: " + resourcekey);
+        } else {
+            return t0;
+        }
+    }
+
+    public abstract Set<MinecraftKey> keySet();
+
+    public abstract Set<Entry<ResourceKey<T>, T>> d();
+
+    public Stream<T> g() {
+        return StreamSupport.stream(this.spliterator(), false);
+    }
+
+    public static <T> T a(IRegistry<? super T> iregistry, String s, T t0) {
+        return a(iregistry, new MinecraftKey(s), t0);
+    }
+
+    public static <V, T extends V> T a(IRegistry<V> iregistry, MinecraftKey minecraftkey, T t0) {
+        return ((IRegistryWritable) iregistry).a(ResourceKey.a(iregistry.b, minecraftkey), t0, Lifecycle.stable());
+    }
+
+    public static <V, T extends V> T a(IRegistry<V> iregistry, int i, String s, T t0) {
+        return ((IRegistryWritable) iregistry).a(i, ResourceKey.a(iregistry.b, new MinecraftKey(s)), t0, Lifecycle.stable());
+    }
+
+    static {
+        RegistryGeneration.a();
+        IRegistry.a.forEach((minecraftkey, supplier) -> {
+            if (supplier.get() == null) {
+                IRegistry.LOGGER.error("Unable to bootstrap registry '{}'", minecraftkey);
+            }
+
+        });
+        a(IRegistry.e);
+    }
+}
diff --git a/src/main/java/net/minecraft/core/RegistryBlockID.java b/src/main/java/net/minecraft/core/RegistryBlockID.java
new file mode 100644
index 0000000000000000000000000000000000000000..b173ed8a6abeee41ce48e03f6403f2eb4978155b
--- /dev/null
+++ b/src/main/java/net/minecraft/core/RegistryBlockID.java
@@ -0,0 +1,63 @@
+package net.minecraft.core;
+
+import com.google.common.base.Predicates;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+
+public class RegistryBlockID<T> implements Registry<T> {
+
+    private int a;
+    private final IdentityHashMap<T, Integer> b;
+    private final List<T> c;
+
+    public RegistryBlockID() {
+        this(512);
+    }
+
+    public RegistryBlockID(int i) {
+        this.c = Lists.newArrayListWithExpectedSize(i);
+        this.b = new IdentityHashMap(i);
+    }
+
+    public void a(T t0, int i) {
+        this.b.put(t0, i);
+
+        while (this.c.size() <= i) {
+            this.c.add((Object) null);
+        }
+
+        this.c.set(i, t0);
+        if (this.a <= i) {
+            this.a = i + 1;
+        }
+
+    }
+
+    public void b(T t0) {
+        this.a(t0, this.a);
+    }
+
+    public int getId(T t0) {
+        Integer integer = (Integer) this.b.get(t0);
+
+        return integer == null ? -1 : integer;
+    }
+
+    @Nullable
+    @Override
+    public final T fromId(int i) {
+        return i >= 0 && i < this.c.size() ? this.c.get(i) : null;
+    }
+
+    public Iterator<T> iterator() {
+        return Iterators.filter(this.c.iterator(), Predicates.notNull());
+    }
+
+    public int a() {
+        return this.b.size();
+    }
+}
diff --git a/src/main/java/net/minecraft/core/RegistryMaterials.java b/src/main/java/net/minecraft/core/RegistryMaterials.java
new file mode 100644
index 0000000000000000000000000000000000000000..f3f6ed83d509d228944d15fc2b2b4cb85b05e366
--- /dev/null
+++ b/src/main/java/net/minecraft/core/RegistryMaterials.java
@@ -0,0 +1,256 @@
+package net.minecraft.core;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableList.Builder;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Maps;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.Lifecycle;
+import com.mojang.serialization.MapCodec;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenCustomHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.OptionalInt;
+import java.util.Random;
+import java.util.Set;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.resources.RegistryDataPackCodec;
+import net.minecraft.resources.ResourceKey;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class RegistryMaterials<T> extends IRegistryWritable<T> {
+
+    protected static final Logger LOGGER = LogManager.getLogger();
+    private final ObjectList<T> bf = new ObjectArrayList(256);
+    private final Object2IntMap<T> bg = new Object2IntOpenCustomHashMap(SystemUtils.k());
+    private final BiMap<MinecraftKey, T> bh;
+    private final BiMap<ResourceKey<T>, T> bi;
+    private final Map<T, Lifecycle> bj;
+    private Lifecycle bk;
+    protected Object[] b;
+    private int bl;
+
+    public RegistryMaterials(ResourceKey<? extends IRegistry<T>> resourcekey, Lifecycle lifecycle) {
+        super(resourcekey, lifecycle);
+        this.bg.defaultReturnValue(-1);
+        this.bh = HashBiMap.create();
+        this.bi = HashBiMap.create();
+        this.bj = Maps.newIdentityHashMap();
+        this.bk = lifecycle;
+    }
+
+    public static <T> MapCodec<RegistryMaterials.a<T>> a(ResourceKey<? extends IRegistry<T>> resourcekey, MapCodec<T> mapcodec) {
+        return RecordCodecBuilder.mapCodec((instance) -> {
+            return instance.group(MinecraftKey.a.xmap(ResourceKey.b(resourcekey), ResourceKey::a).fieldOf("name").forGetter((registrymaterials_a) -> {
+                return registrymaterials_a.a;
+            }), Codec.INT.fieldOf("id").forGetter((registrymaterials_a) -> {
+                return registrymaterials_a.b;
+            }), mapcodec.forGetter((registrymaterials_a) -> {
+                return registrymaterials_a.c;
+            })).apply(instance, RegistryMaterials.a::new);
+        });
+    }
+
+    @Override
+    public <V extends T> V a(int i, ResourceKey<T> resourcekey, V v0, Lifecycle lifecycle) {
+        return this.a(i, resourcekey, v0, lifecycle, true);
+    }
+
+    private <V extends T> V a(int i, ResourceKey<T> resourcekey, V v0, Lifecycle lifecycle, boolean flag) {
+        Validate.notNull(resourcekey);
+        Validate.notNull(v0);
+        this.bf.size(Math.max(this.bf.size(), i + 1));
+        this.bf.set(i, v0);
+        this.bg.put(v0, i);
+        this.b = null;
+        if (flag && this.bi.containsKey(resourcekey)) {
+            RegistryMaterials.LOGGER.debug("Adding duplicate key '{}' to registry", resourcekey);
+        }
+
+        if (this.bh.containsValue(v0)) {
+            RegistryMaterials.LOGGER.error("Adding duplicate value '{}' to registry", v0);
+        }
+
+        this.bh.put(resourcekey.a(), v0);
+        this.bi.put(resourcekey, v0);
+        this.bj.put(v0, lifecycle);
+        this.bk = this.bk.add(lifecycle);
+        if (this.bl <= i) {
+            this.bl = i + 1;
+        }
+
+        return v0;
+    }
+
+    @Override
+    public <V extends T> V a(ResourceKey<T> resourcekey, V v0, Lifecycle lifecycle) {
+        return this.a(this.bl, resourcekey, v0, lifecycle);
+    }
+
+    @Override
+    public <V extends T> V a(OptionalInt optionalint, ResourceKey<T> resourcekey, V v0, Lifecycle lifecycle) {
+        Validate.notNull(resourcekey);
+        Validate.notNull(v0);
+        T t0 = this.bi.get(resourcekey);
+        int i;
+
+        if (t0 == null) {
+            i = optionalint.isPresent() ? optionalint.getAsInt() : this.bl;
+        } else {
+            i = this.bg.getInt(t0);
+            if (optionalint.isPresent() && optionalint.getAsInt() != i) {
+                throw new IllegalStateException("ID mismatch");
+            }
+
+            this.bg.removeInt(t0);
+            this.bj.remove(t0);
+        }
+
+        return this.a(i, resourcekey, v0, lifecycle, false);
+    }
+
+    @Nullable
+    @Override
+    public MinecraftKey getKey(T t0) {
+        return (MinecraftKey) this.bh.inverse().get(t0);
+    }
+
+    @Override
+    public Optional<ResourceKey<T>> c(T t0) {
+        return Optional.ofNullable(this.bi.inverse().get(t0));
+    }
+
+    @Override
+    public int a(@Nullable T t0) {
+        return this.bg.getInt(t0);
+    }
+
+    @Nullable
+    @Override
+    public T a(@Nullable ResourceKey<T> resourcekey) {
+        return this.bi.get(resourcekey);
+    }
+
+    @Nullable
+    @Override
+    public T fromId(int i) {
+        return i >= 0 && i < this.bf.size() ? this.bf.get(i) : null;
+    }
+
+    @Override
+    public Lifecycle d(T t0) {
+        return (Lifecycle) this.bj.get(t0);
+    }
+
+    @Override
+    public Lifecycle b() {
+        return this.bk;
+    }
+
+    public Iterator<T> iterator() {
+        return Iterators.filter(this.bf.iterator(), Objects::nonNull);
+    }
+
+    @Nullable
+    @Override
+    public T get(@Nullable MinecraftKey minecraftkey) {
+        return this.bh.get(minecraftkey);
+    }
+
+    @Override
+    public Set<MinecraftKey> keySet() {
+        return Collections.unmodifiableSet(this.bh.keySet());
+    }
+
+    @Override
+    public Set<Entry<ResourceKey<T>, T>> d() {
+        return Collections.unmodifiableMap(this.bi).entrySet();
+    }
+
+    @Nullable
+    public T a(Random random) {
+        if (this.b == null) {
+            Collection<?> collection = this.bh.values();
+
+            if (collection.isEmpty()) {
+                return null;
+            }
+
+            this.b = collection.toArray(new Object[collection.size()]);
+        }
+
+        return SystemUtils.a(this.b, random);
+    }
+
+    public static <T> Codec<RegistryMaterials<T>> a(ResourceKey<? extends IRegistry<T>> resourcekey, Lifecycle lifecycle, Codec<T> codec) {
+        return a(resourcekey, codec.fieldOf("element")).codec().listOf().xmap((list) -> {
+            RegistryMaterials<T> registrymaterials = new RegistryMaterials<>(resourcekey, lifecycle);
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                RegistryMaterials.a<T> registrymaterials_a = (RegistryMaterials.a) iterator.next();
+
+                registrymaterials.a(registrymaterials_a.b, registrymaterials_a.a, registrymaterials_a.c, lifecycle);
+            }
+
+            return registrymaterials;
+        }, (registrymaterials) -> {
+            Builder<RegistryMaterials.a<T>> builder = ImmutableList.builder();
+            Iterator iterator = registrymaterials.iterator();
+
+            while (iterator.hasNext()) {
+                T t0 = iterator.next();
+
+                builder.add(new RegistryMaterials.a<>((ResourceKey) registrymaterials.c(t0).get(), registrymaterials.a(t0), t0));
+            }
+
+            return builder.build();
+        });
+    }
+
+    public static <T> Codec<RegistryMaterials<T>> b(ResourceKey<? extends IRegistry<T>> resourcekey, Lifecycle lifecycle, Codec<T> codec) {
+        return RegistryDataPackCodec.a(resourcekey, lifecycle, codec);
+    }
+
+    public static <T> Codec<RegistryMaterials<T>> c(ResourceKey<? extends IRegistry<T>> resourcekey, Lifecycle lifecycle, Codec<T> codec) {
+        return Codec.unboundedMap(MinecraftKey.a.xmap(ResourceKey.b(resourcekey), ResourceKey::a), codec).xmap((map) -> {
+            RegistryMaterials<T> registrymaterials = new RegistryMaterials<>(resourcekey, lifecycle);
+
+            map.forEach((resourcekey1, object) -> {
+                registrymaterials.a(resourcekey1, object, lifecycle);
+            });
+            return registrymaterials;
+        }, (registrymaterials) -> {
+            return ImmutableMap.copyOf(registrymaterials.bi);
+        });
+    }
+
+    public static class a<T> {
+
+        public final ResourceKey<T> a;
+        public final int b;
+        public final T c;
+
+        public a(ResourceKey<T> resourcekey, int i, T t0) {
+            this.a = resourcekey;
+            this.b = i;
+            this.c = t0;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/core/SectionPosition.java b/src/main/java/net/minecraft/core/SectionPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..97126ae5a43bb7acb04a1ab14fb7f364c8c2675f
--- /dev/null
+++ b/src/main/java/net/minecraft/core/SectionPosition.java
@@ -0,0 +1,209 @@
+package net.minecraft.core;
+
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkCoordIntPair;
+
+public class SectionPosition extends BaseBlockPosition {
+
+    private SectionPosition(int i, int j, int k) {
+        super(i, j, k);
+    }
+
+    public static SectionPosition a(int i, int j, int k) {
+        return new SectionPosition(i, j, k);
+    }
+
+    public static SectionPosition a(BlockPosition blockposition) {
+        return new SectionPosition(a(blockposition.getX()), a(blockposition.getY()), a(blockposition.getZ()));
+    }
+
+    public static SectionPosition a(ChunkCoordIntPair chunkcoordintpair, int i) {
+        return new SectionPosition(chunkcoordintpair.x, i, chunkcoordintpair.z);
+    }
+
+    public static SectionPosition a(Entity entity) {
+        return new SectionPosition(a(MathHelper.floor(entity.locX())), a(MathHelper.floor(entity.locY())), a(MathHelper.floor(entity.locZ())));
+    }
+
+    public static SectionPosition a(long i) {
+        return new SectionPosition(b(i), c(i), d(i));
+    }
+
+    public static long a(long i, EnumDirection enumdirection) {
+        return a(i, enumdirection.getAdjacentX(), enumdirection.getAdjacentY(), enumdirection.getAdjacentZ());
+    }
+
+    public static long a(long i, int j, int k, int l) {
+        return b(b(i) + j, c(i) + k, d(i) + l);
+    }
+
+    public static int a(int i) {
+        return i >> 4;
+    }
+
+    public static int b(int i) {
+        return i & 15;
+    }
+
+    public static short b(BlockPosition blockposition) {
+        int i = b(blockposition.getX());
+        int j = b(blockposition.getY());
+        int k = b(blockposition.getZ());
+
+        return (short) (i << 8 | k << 4 | j << 0);
+    }
+
+    public static int a(short short0) {
+        return short0 >>> 8 & 15;
+    }
+
+    public static int b(short short0) {
+        return short0 >>> 0 & 15;
+    }
+
+    public static int c(short short0) {
+        return short0 >>> 4 & 15;
+    }
+
+    public int d(short short0) {
+        return this.d() + a(short0);
+    }
+
+    public int e(short short0) {
+        return this.e() + b(short0);
+    }
+
+    public int f(short short0) {
+        return this.f() + c(short0);
+    }
+
+    public BlockPosition g(short short0) {
+        return new BlockPosition(this.d(short0), this.e(short0), this.f(short0));
+    }
+
+    public static int c(int i) {
+        return i << 4;
+    }
+
+    public static int b(long i) {
+        return (int) (i << 0 >> 42);
+    }
+
+    public static int c(long i) {
+        return (int) (i << 44 >> 44);
+    }
+
+    public static int d(long i) {
+        return (int) (i << 22 >> 42);
+    }
+
+    public int a() {
+        return this.getX();
+    }
+
+    public int b() {
+        return this.getY();
+    }
+
+    public int c() {
+        return this.getZ();
+    }
+
+    public int d() {
+        return this.a() << 4;
+    }
+
+    public int e() {
+        return this.b() << 4;
+    }
+
+    public int f() {
+        return this.c() << 4;
+    }
+
+    public int g() {
+        return (this.a() << 4) + 15;
+    }
+
+    public int h() {
+        return (this.b() << 4) + 15;
+    }
+
+    public int i() {
+        return (this.c() << 4) + 15;
+    }
+
+    public static long e(long i) {
+        return b(a(BlockPosition.b(i)), a(BlockPosition.c(i)), a(BlockPosition.d(i)));
+    }
+
+    public static long f(long i) {
+        return i & -1048576L;
+    }
+
+    public BlockPosition p() {
+        return new BlockPosition(c(this.a()), c(this.b()), c(this.c()));
+    }
+
+    public BlockPosition q() {
+        boolean flag = true;
+
+        return this.p().b(8, 8, 8);
+    }
+
+    public ChunkCoordIntPair r() {
+        return new ChunkCoordIntPair(this.a(), this.c());
+    }
+
+    public static long b(int i, int j, int k) {
+        long l = 0L;
+
+        l |= ((long) i & 4194303L) << 42;
+        l |= ((long) j & 1048575L) << 0;
+        l |= ((long) k & 4194303L) << 20;
+        return l;
+    }
+
+    public long s() {
+        return b(this.a(), this.b(), this.c());
+    }
+
+    public Stream<BlockPosition> t() {
+        return BlockPosition.a(this.d(), this.e(), this.f(), this.g(), this.h(), this.i());
+    }
+
+    public static Stream<SectionPosition> a(SectionPosition sectionposition, int i) {
+        int j = sectionposition.a();
+        int k = sectionposition.b();
+        int l = sectionposition.c();
+
+        return a(j - i, k - i, l - i, j + i, k + i, l + i);
+    }
+
+    public static Stream<SectionPosition> b(ChunkCoordIntPair chunkcoordintpair, int i) {
+        int j = chunkcoordintpair.x;
+        int k = chunkcoordintpair.z;
+
+        return a(j - i, 0, k - i, j + i, 15, k + i);
+    }
+
+    public static Stream<SectionPosition> a(final int i, final int j, final int k, final int l, final int i1, final int j1) {
+        return StreamSupport.stream(new AbstractSpliterator<SectionPosition>((long) ((l - i + 1) * (i1 - j + 1) * (j1 - k + 1)), 64) {
+            final CursorPosition a = new CursorPosition(i, j, k, l, i1, j1);
+
+            public boolean tryAdvance(Consumer<? super SectionPosition> consumer) {
+                if (this.a.a()) {
+                    consumer.accept(new SectionPosition(this.a.b(), this.a.c(), this.a.d()));
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        }, false);
+    }
+}
diff --git a/src/main/java/net/minecraft/core/Vector3f.java b/src/main/java/net/minecraft/core/Vector3f.java
new file mode 100644
index 0000000000000000000000000000000000000000..93590ceb0bbe369a1bda987f0c4c21ea6a3b3a1a
--- /dev/null
+++ b/src/main/java/net/minecraft/core/Vector3f.java
@@ -0,0 +1,52 @@
+package net.minecraft.core;
+
+import net.minecraft.nbt.NBTTagFloat;
+import net.minecraft.nbt.NBTTagList;
+
+public class Vector3f {
+
+    protected final float x;
+    protected final float y;
+    protected final float z;
+
+    public Vector3f(float f, float f1, float f2) {
+        this.x = !Float.isInfinite(f) && !Float.isNaN(f) ? f % 360.0F : 0.0F;
+        this.y = !Float.isInfinite(f1) && !Float.isNaN(f1) ? f1 % 360.0F : 0.0F;
+        this.z = !Float.isInfinite(f2) && !Float.isNaN(f2) ? f2 % 360.0F : 0.0F;
+    }
+
+    public Vector3f(NBTTagList nbttaglist) {
+        this(nbttaglist.i(0), nbttaglist.i(1), nbttaglist.i(2));
+    }
+
+    public NBTTagList a() {
+        NBTTagList nbttaglist = new NBTTagList();
+
+        nbttaglist.add(NBTTagFloat.a(this.x));
+        nbttaglist.add(NBTTagFloat.a(this.y));
+        nbttaglist.add(NBTTagFloat.a(this.z));
+        return nbttaglist;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof Vector3f)) {
+            return false;
+        } else {
+            Vector3f vector3f = (Vector3f) object;
+
+            return this.x == vector3f.x && this.y == vector3f.y && this.z == vector3f.z;
+        }
+    }
+
+    public float getX() {
+        return this.x;
+    }
+
+    public float getY() {
+        return this.y;
+    }
+
+    public float getZ() {
+        return this.z;
+    }
+}
diff --git a/src/main/java/net/minecraft/data/RegistryGeneration.java b/src/main/java/net/minecraft/data/RegistryGeneration.java
new file mode 100644
index 0000000000000000000000000000000000000000..25762daca063ff5a422975d7fe64752a2deae163
--- /dev/null
+++ b/src/main/java/net/minecraft/data/RegistryGeneration.java
@@ -0,0 +1,97 @@
+package net.minecraft.data;
+
+import com.google.common.collect.Maps;
+import com.mojang.serialization.Lifecycle;
+import java.util.Map;
+import java.util.function.Supplier;
+import net.minecraft.core.IRegistry;
+import net.minecraft.core.IRegistryWritable;
+import net.minecraft.core.RegistryMaterials;
+import net.minecraft.data.worldgen.BiomeDecoratorGroups;
+import net.minecraft.data.worldgen.ProcessorLists;
+import net.minecraft.data.worldgen.StructureFeatures;
+import net.minecraft.data.worldgen.WorldGenCarvers;
+import net.minecraft.data.worldgen.WorldGenFeaturePieces;
+import net.minecraft.data.worldgen.WorldGenSurfaceComposites;
+import net.minecraft.data.worldgen.biome.BiomeRegistry;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.levelgen.GeneratorSettingBase;
+import net.minecraft.world.level.levelgen.carver.WorldGenCarverWrapper;
+import net.minecraft.world.level.levelgen.feature.StructureFeature;
+import net.minecraft.world.level.levelgen.feature.WorldGenFeatureConfigured;
+import net.minecraft.world.level.levelgen.feature.structures.WorldGenFeatureDefinedStructurePoolTemplate;
+import net.minecraft.world.level.levelgen.structure.templatesystem.ProcessorList;
+import net.minecraft.world.level.levelgen.surfacebuilders.WorldGenSurfaceComposite;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class RegistryGeneration {
+
+    protected static final Logger LOGGER = LogManager.getLogger();
+    private static final Map<MinecraftKey, Supplier<?>> k = Maps.newLinkedHashMap();
+    private static final IRegistryWritable<IRegistryWritable<?>> l = new RegistryMaterials<>(ResourceKey.a(new MinecraftKey("root")), Lifecycle.experimental());
+    public static final IRegistry<? extends IRegistry<?>> b = RegistryGeneration.l;
+    public static final IRegistry<WorldGenSurfaceComposite<?>> c = a(IRegistry.as, () -> {
+        return WorldGenSurfaceComposites.p;
+    });
+    public static final IRegistry<WorldGenCarverWrapper<?>> d = a(IRegistry.at, () -> {
+        return WorldGenCarvers.a;
+    });
+    public static final IRegistry<WorldGenFeatureConfigured<?, ?>> e = a(IRegistry.au, () -> {
+        return BiomeDecoratorGroups.OAK;
+    });
+    public static final IRegistry<StructureFeature<?, ?>> f = a(IRegistry.av, () -> {
+        return StructureFeatures.b;
+    });
+    public static final IRegistry<ProcessorList> g = a(IRegistry.aw, () -> {
+        return ProcessorLists.b;
+    });
+    public static final IRegistry<WorldGenFeatureDefinedStructurePoolTemplate> h = a(IRegistry.ax, WorldGenFeaturePieces::a);
+    public static final IRegistry<BiomeBase> WORLDGEN_BIOME = a(IRegistry.ay, () -> {
+        return BiomeRegistry.a;
+    });
+    public static final IRegistry<GeneratorSettingBase> j = a(IRegistry.ar, GeneratorSettingBase::i);
+
+    private static <T> IRegistry<T> a(ResourceKey<? extends IRegistry<T>> resourcekey, Supplier<T> supplier) {
+        return a(resourcekey, Lifecycle.stable(), supplier);
+    }
+
+    private static <T> IRegistry<T> a(ResourceKey<? extends IRegistry<T>> resourcekey, Lifecycle lifecycle, Supplier<T> supplier) {
+        return a(resourcekey, new RegistryMaterials<>(resourcekey, lifecycle), supplier, lifecycle);
+    }
+
+    private static <T, R extends IRegistryWritable<T>> R a(ResourceKey<? extends IRegistry<T>> resourcekey, R r0, Supplier<T> supplier, Lifecycle lifecycle) {
+        MinecraftKey minecraftkey = resourcekey.a();
+
+        RegistryGeneration.k.put(minecraftkey, supplier);
+        IRegistryWritable<R> iregistrywritable = RegistryGeneration.l;
+
+        return (IRegistryWritable) iregistrywritable.a(resourcekey, (Object) r0, lifecycle);
+    }
+
+    public static <T> T a(IRegistry<? super T> iregistry, String s, T t0) {
+        return a(iregistry, new MinecraftKey(s), t0);
+    }
+
+    public static <V, T extends V> T a(IRegistry<V> iregistry, MinecraftKey minecraftkey, T t0) {
+        return ((IRegistryWritable) iregistry).a(ResourceKey.a(iregistry.f(), minecraftkey), t0, Lifecycle.stable());
+    }
+
+    public static <V, T extends V> T a(IRegistry<V> iregistry, int i, ResourceKey<V> resourcekey, T t0) {
+        return ((IRegistryWritable) iregistry).a(i, resourcekey, t0, Lifecycle.stable());
+    }
+
+    public static void a() {}
+
+    static {
+        RegistryGeneration.k.forEach((minecraftkey, supplier) -> {
+            if (supplier.get() == null) {
+                RegistryGeneration.LOGGER.error("Unable to bootstrap registry '{}'", minecraftkey);
+            }
+
+        });
+        IRegistry.a(RegistryGeneration.l);
+    }
+}
diff --git a/src/main/java/net/minecraft/locale/LocaleLanguage.java b/src/main/java/net/minecraft/locale/LocaleLanguage.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b8d5e7e4c86a699e26b1b4d0b82e88887a44054
--- /dev/null
+++ b/src/main/java/net/minecraft/locale/LocaleLanguage.java
@@ -0,0 +1,97 @@
+package net.minecraft.locale;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableMap.Builder;
+import com.google.gson.Gson;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.function.BiConsumer;
+import java.util.regex.Pattern;
+import net.minecraft.util.ChatDeserializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public abstract class LocaleLanguage {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final Gson b = new Gson();
+    private static final Pattern c = Pattern.compile("%(\\d+\\$)?[\\d.]*[df]");
+    private static volatile LocaleLanguage d = c();
+
+    public LocaleLanguage() {}
+
+    private static LocaleLanguage c() {
+        Builder<String, String> builder = ImmutableMap.builder();
+        BiConsumer biconsumer = builder::put;
+
+        try {
+            InputStream inputstream = LocaleLanguage.class.getResourceAsStream("/assets/minecraft/lang/en_us.json");
+            Throwable throwable = null;
+
+            try {
+                a(inputstream, biconsumer);
+            } catch (Throwable throwable1) {
+                throwable = throwable1;
+                throw throwable1;
+            } finally {
+                if (inputstream != null) {
+                    if (throwable != null) {
+                        try {
+                            inputstream.close();
+                        } catch (Throwable throwable2) {
+                            throwable.addSuppressed(throwable2);
+                        }
+                    } else {
+                        inputstream.close();
+                    }
+                }
+
+            }
+        } catch (JsonParseException | IOException ioexception) {
+            LocaleLanguage.LOGGER.error("Couldn't read strings from /assets/minecraft/lang/en_us.json", ioexception);
+        }
+
+        final Map<String, String> map = builder.build();
+
+        return new LocaleLanguage() {
+            @Override
+            public String a(String s) {
+                return (String) map.getOrDefault(s, s);
+            }
+
+            @Override
+            public boolean b(String s) {
+                return map.containsKey(s);
+            }
+        };
+    }
+
+    public static void a(InputStream inputstream, BiConsumer<String, String> biconsumer) {
+        JsonObject jsonobject = (JsonObject) LocaleLanguage.b.fromJson(new InputStreamReader(inputstream, StandardCharsets.UTF_8), JsonObject.class);
+        Iterator iterator = jsonobject.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry<String, JsonElement> entry = (Entry) iterator.next();
+            String s = LocaleLanguage.c.matcher(ChatDeserializer.a((JsonElement) entry.getValue(), (String) entry.getKey())).replaceAll("%$1s");
+
+            biconsumer.accept(entry.getKey(), s);
+        }
+
+    }
+
+    public static LocaleLanguage a() {
+        return LocaleLanguage.d;
+    }
+
+    public abstract String a(String s);
+
+    public abstract boolean b(String s);
+}
diff --git a/src/main/java/net/minecraft/nbt/GameProfileSerializer.java b/src/main/java/net/minecraft/nbt/GameProfileSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..0560d115288c67e46d921ce529e603f424e601f5
--- /dev/null
+++ b/src/main/java/net/minecraft/nbt/GameProfileSerializer.java
@@ -0,0 +1,286 @@
+package net.minecraft.nbt;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.UnmodifiableIterator;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.properties.Property;
+import com.mojang.datafixers.DataFixer;
+import com.mojang.serialization.Dynamic;
+import java.util.Iterator;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.UUID;
+import javax.annotation.Nullable;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IRegistry;
+import net.minecraft.core.MinecraftSerializableUUID;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.util.UtilColor;
+import net.minecraft.util.datafix.DataFixTypes;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockStateList;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.IBlockDataHolder;
+import net.minecraft.world.level.block.state.properties.IBlockState;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public final class GameProfileSerializer {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    @Nullable
+    public static GameProfile deserialize(NBTTagCompound nbttagcompound) {
+        String s = null;
+        UUID uuid = null;
+
+        if (nbttagcompound.hasKeyOfType("Name", 8)) {
+            s = nbttagcompound.getString("Name");
+        }
+
+        if (nbttagcompound.b("Id")) {
+            uuid = nbttagcompound.a("Id");
+        }
+
+        try {
+            GameProfile gameprofile = new GameProfile(uuid, s);
+
+            if (nbttagcompound.hasKeyOfType("Properties", 10)) {
+                NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Properties");
+                Iterator iterator = nbttagcompound1.getKeys().iterator();
+
+                while (iterator.hasNext()) {
+                    String s1 = (String) iterator.next();
+                    NBTTagList nbttaglist = nbttagcompound1.getList(s1, 10);
+
+                    for (int i = 0; i < nbttaglist.size(); ++i) {
+                        NBTTagCompound nbttagcompound2 = nbttaglist.getCompound(i);
+                        String s2 = nbttagcompound2.getString("Value");
+
+                        if (nbttagcompound2.hasKeyOfType("Signature", 8)) {
+                            gameprofile.getProperties().put(s1, new Property(s1, s2, nbttagcompound2.getString("Signature")));
+                        } else {
+                            gameprofile.getProperties().put(s1, new Property(s1, s2));
+                        }
+                    }
+                }
+            }
+
+            return gameprofile;
+        } catch (Throwable throwable) {
+            return null;
+        }
+    }
+
+    public static NBTTagCompound serialize(NBTTagCompound nbttagcompound, GameProfile gameprofile) {
+        if (!UtilColor.b(gameprofile.getName())) {
+            nbttagcompound.setString("Name", gameprofile.getName());
+        }
+
+        if (gameprofile.getId() != null) {
+            nbttagcompound.a("Id", gameprofile.getId());
+        }
+
+        if (!gameprofile.getProperties().isEmpty()) {
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+            Iterator iterator = gameprofile.getProperties().keySet().iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+                NBTTagList nbttaglist = new NBTTagList();
+
+                NBTTagCompound nbttagcompound2;
+
+                for (Iterator iterator1 = gameprofile.getProperties().get(s).iterator(); iterator1.hasNext(); nbttaglist.add(nbttagcompound2)) {
+                    Property property = (Property) iterator1.next();
+
+                    nbttagcompound2 = new NBTTagCompound();
+                    nbttagcompound2.setString("Value", property.getValue());
+                    if (property.hasSignature()) {
+                        nbttagcompound2.setString("Signature", property.getSignature());
+                    }
+                }
+
+                nbttagcompound1.set(s, nbttaglist);
+            }
+
+            nbttagcompound.set("Properties", nbttagcompound1);
+        }
+
+        return nbttagcompound;
+    }
+
+    @VisibleForTesting
+    public static boolean a(@Nullable NBTBase nbtbase, @Nullable NBTBase nbtbase1, boolean flag) {
+        if (nbtbase == nbtbase1) {
+            return true;
+        } else if (nbtbase == null) {
+            return true;
+        } else if (nbtbase1 == null) {
+            return false;
+        } else if (!nbtbase.getClass().equals(nbtbase1.getClass())) {
+            return false;
+        } else if (nbtbase instanceof NBTTagCompound) {
+            NBTTagCompound nbttagcompound = (NBTTagCompound) nbtbase;
+            NBTTagCompound nbttagcompound1 = (NBTTagCompound) nbtbase1;
+            Iterator iterator = nbttagcompound.getKeys().iterator();
+
+            String s;
+            NBTBase nbtbase2;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return true;
+                }
+
+                s = (String) iterator.next();
+                nbtbase2 = nbttagcompound.get(s);
+            } while (a(nbtbase2, nbttagcompound1.get(s), flag));
+
+            return false;
+        } else if (nbtbase instanceof NBTTagList && flag) {
+            NBTTagList nbttaglist = (NBTTagList) nbtbase;
+            NBTTagList nbttaglist1 = (NBTTagList) nbtbase1;
+
+            if (nbttaglist.isEmpty()) {
+                return nbttaglist1.isEmpty();
+            } else {
+                int i = 0;
+
+                while (i < nbttaglist.size()) {
+                    NBTBase nbtbase3 = nbttaglist.get(i);
+                    boolean flag1 = false;
+                    int j = 0;
+
+                    while (true) {
+                        if (j < nbttaglist1.size()) {
+                            if (!a(nbtbase3, nbttaglist1.get(j), flag)) {
+                                ++j;
+                                continue;
+                            }
+
+                            flag1 = true;
+                        }
+
+                        if (!flag1) {
+                            return false;
+                        }
+
+                        ++i;
+                        break;
+                    }
+                }
+
+                return true;
+            }
+        } else {
+            return nbtbase.equals(nbtbase1);
+        }
+    }
+
+    public static NBTTagIntArray a(UUID uuid) {
+        return new NBTTagIntArray(MinecraftSerializableUUID.a(uuid));
+    }
+
+    public static UUID a(NBTBase nbtbase) {
+        if (nbtbase.b() != NBTTagIntArray.a) {
+            throw new IllegalArgumentException("Expected UUID-Tag to be of type " + NBTTagIntArray.a.a() + ", but found " + nbtbase.b().a() + ".");
+        } else {
+            int[] aint = ((NBTTagIntArray) nbtbase).getInts();
+
+            if (aint.length != 4) {
+                throw new IllegalArgumentException("Expected UUID-Array to be of length 4, but found " + aint.length + ".");
+            } else {
+                return MinecraftSerializableUUID.a(aint);
+            }
+        }
+    }
+
+    public static BlockPosition b(NBTTagCompound nbttagcompound) {
+        return new BlockPosition(nbttagcompound.getInt("X"), nbttagcompound.getInt("Y"), nbttagcompound.getInt("Z"));
+    }
+
+    public static NBTTagCompound a(BlockPosition blockposition) {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        nbttagcompound.setInt("X", blockposition.getX());
+        nbttagcompound.setInt("Y", blockposition.getY());
+        nbttagcompound.setInt("Z", blockposition.getZ());
+        return nbttagcompound;
+    }
+
+    public static IBlockData c(NBTTagCompound nbttagcompound) {
+        if (!nbttagcompound.hasKeyOfType("Name", 8)) {
+            return Blocks.AIR.getBlockData();
+        } else {
+            Block block = (Block) IRegistry.BLOCK.get(new MinecraftKey(nbttagcompound.getString("Name")));
+            IBlockData iblockdata = block.getBlockData();
+
+            if (nbttagcompound.hasKeyOfType("Properties", 10)) {
+                NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Properties");
+                BlockStateList<Block, IBlockData> blockstatelist = block.getStates();
+                Iterator iterator = nbttagcompound1.getKeys().iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+                    IBlockState<?> iblockstate = blockstatelist.a(s);
+
+                    if (iblockstate != null) {
+                        iblockdata = (IBlockData) a(iblockdata, iblockstate, s, nbttagcompound1, nbttagcompound);
+                    }
+                }
+            }
+
+            return iblockdata;
+        }
+    }
+
+    private static <S extends IBlockDataHolder<?, S>, T extends Comparable<T>> S a(S s0, IBlockState<T> iblockstate, String s, NBTTagCompound nbttagcompound, NBTTagCompound nbttagcompound1) {
+        Optional<T> optional = iblockstate.b(nbttagcompound.getString(s));
+
+        if (optional.isPresent()) {
+            return (IBlockDataHolder) s0.set(iblockstate, (Comparable) optional.get());
+        } else {
+            GameProfileSerializer.LOGGER.warn("Unable to read property: {} with value: {} for blockstate: {}", s, nbttagcompound.getString(s), nbttagcompound1.toString());
+            return s0;
+        }
+    }
+
+    public static NBTTagCompound a(IBlockData iblockdata) {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        nbttagcompound.setString("Name", IRegistry.BLOCK.getKey(iblockdata.getBlock()).toString());
+        ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap = iblockdata.getStateMap();
+
+        if (!immutablemap.isEmpty()) {
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+            UnmodifiableIterator unmodifiableiterator = immutablemap.entrySet().iterator();
+
+            while (unmodifiableiterator.hasNext()) {
+                Entry<IBlockState<?>, Comparable<?>> entry = (Entry) unmodifiableiterator.next();
+                IBlockState<?> iblockstate = (IBlockState) entry.getKey();
+
+                nbttagcompound1.setString(iblockstate.getName(), a(iblockstate, (Comparable) entry.getValue()));
+            }
+
+            nbttagcompound.set("Properties", nbttagcompound1);
+        }
+
+        return nbttagcompound;
+    }
+
+    private static <T extends Comparable<T>> String a(IBlockState<T> iblockstate, Comparable<?> comparable) {
+        return iblockstate.a(comparable);
+    }
+
+    public static NBTTagCompound a(DataFixer datafixer, DataFixTypes datafixtypes, NBTTagCompound nbttagcompound, int i) {
+        return a(datafixer, datafixtypes, nbttagcompound, i, SharedConstants.getGameVersion().getWorldVersion());
+    }
+
+    public static NBTTagCompound a(DataFixer datafixer, DataFixTypes datafixtypes, NBTTagCompound nbttagcompound, int i, int j) {
+        return (NBTTagCompound) datafixer.update(datafixtypes.a(), new Dynamic(DynamicOpsNBT.a, nbttagcompound), i, j).getValue();
+    }
+}
diff --git a/src/main/java/net/minecraft/nbt/NBTBase.java b/src/main/java/net/minecraft/nbt/NBTBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..170a65cb13e7b87f64cd28331431ba55d53702cd
--- /dev/null
+++ b/src/main/java/net/minecraft/nbt/NBTBase.java
@@ -0,0 +1,34 @@
+package net.minecraft.nbt;
+
+import java.io.DataOutput;
+import java.io.IOException;
+import net.minecraft.EnumChatFormat;
+import net.minecraft.network.chat.IChatBaseComponent;
+
+public interface NBTBase {
+
+    EnumChatFormat d = EnumChatFormat.AQUA;
+    EnumChatFormat e = EnumChatFormat.GREEN;
+    EnumChatFormat f = EnumChatFormat.GOLD;
+    EnumChatFormat g = EnumChatFormat.RED;
+
+    void write(DataOutput dataoutput) throws IOException;
+
+    String toString();
+
+    byte getTypeId();
+
+    NBTTagType<?> b();
+
+    NBTBase clone();
+
+    default String asString() {
+        return this.toString();
+    }
+
+    default IChatBaseComponent l() {
+        return this.a("", 0);
+    }
+
+    IChatBaseComponent a(String s, int i);
+}
diff --git a/src/main/java/net/minecraft/nbt/NBTTagCompound.java b/src/main/java/net/minecraft/nbt/NBTTagCompound.java
new file mode 100644
index 0000000000000000000000000000000000000000..b2fb24e9ae19ab6e7039a98fc0c265f801be8a99
--- /dev/null
+++ b/src/main/java/net/minecraft/nbt/NBTTagCompound.java
@@ -0,0 +1,536 @@
+package net.minecraft.nbt;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Dynamic;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import net.minecraft.CrashReport;
+import net.minecraft.CrashReportSystemDetails;
+import net.minecraft.ReportedException;
+import net.minecraft.network.chat.ChatComponentText;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.network.chat.IChatMutableComponent;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class NBTTagCompound implements NBTBase {
+
+    public static final Codec<NBTTagCompound> a = Codec.PASSTHROUGH.comapFlatMap((dynamic) -> {
+        NBTBase nbtbase = (NBTBase) dynamic.convert(DynamicOpsNBT.a).getValue();
+
+        return nbtbase instanceof NBTTagCompound ? DataResult.success((NBTTagCompound) nbtbase) : DataResult.error("Not a compound tag: " + nbtbase);
+    }, (nbttagcompound) -> {
+        return new Dynamic(DynamicOpsNBT.a, nbttagcompound);
+    });
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final Pattern h = Pattern.compile("[A-Za-z0-9._+-]+");
+    public static final NBTTagType<NBTTagCompound> b = new NBTTagType<NBTTagCompound>() {
+        @Override
+        public NBTTagCompound b(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+            nbtreadlimiter.a(384L);
+            if (i > 512) {
+                throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+            } else {
+                HashMap hashmap = Maps.newHashMap();
+
+                byte b0;
+
+                while ((b0 = NBTTagCompound.c(datainput, nbtreadlimiter)) != 0) {
+                    String s = NBTTagCompound.d(datainput, nbtreadlimiter);
+
+                    nbtreadlimiter.a((long) (224 + 16 * s.length()));
+                    NBTBase nbtbase = NBTTagCompound.b(NBTTagTypes.a(b0), s, datainput, i + 1, nbtreadlimiter);
+
+                    if (hashmap.put(s, nbtbase) != null) {
+                        nbtreadlimiter.a(288L);
+                    }
+                }
+
+                return new NBTTagCompound(hashmap);
+            }
+        }
+
+        @Override
+        public String a() {
+            return "COMPOUND";
+        }
+
+        @Override
+        public String b() {
+            return "TAG_Compound";
+        }
+    };
+    private final Map<String, NBTBase> map;
+
+    protected NBTTagCompound(Map<String, NBTBase> map) {
+        this.map = map;
+    }
+
+    public NBTTagCompound() {
+        this(Maps.newHashMap());
+    }
+
+    @Override
+    public void write(DataOutput dataoutput) throws IOException {
+        Iterator iterator = this.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            NBTBase nbtbase = (NBTBase) this.map.get(s);
+
+            a(s, nbtbase, dataoutput);
+        }
+
+        dataoutput.writeByte(0);
+    }
+
+    public Set<String> getKeys() {
+        return this.map.keySet();
+    }
+
+    @Override
+    public byte getTypeId() {
+        return 10;
+    }
+
+    @Override
+    public NBTTagType<NBTTagCompound> b() {
+        return NBTTagCompound.b;
+    }
+
+    public int e() {
+        return this.map.size();
+    }
+
+    @Nullable
+    public NBTBase set(String s, NBTBase nbtbase) {
+        return (NBTBase) this.map.put(s, nbtbase);
+    }
+
+    public void setByte(String s, byte b0) {
+        this.map.put(s, NBTTagByte.a(b0));
+    }
+
+    public void setShort(String s, short short0) {
+        this.map.put(s, NBTTagShort.a(short0));
+    }
+
+    public void setInt(String s, int i) {
+        this.map.put(s, NBTTagInt.a(i));
+    }
+
+    public void setLong(String s, long i) {
+        this.map.put(s, NBTTagLong.a(i));
+    }
+
+    public void a(String s, UUID uuid) {
+        this.map.put(s, GameProfileSerializer.a(uuid));
+    }
+
+    public UUID a(String s) {
+        return GameProfileSerializer.a(this.get(s));
+    }
+
+    public boolean b(String s) {
+        NBTBase nbtbase = this.get(s);
+
+        return nbtbase != null && nbtbase.b() == NBTTagIntArray.a && ((NBTTagIntArray) nbtbase).getInts().length == 4;
+    }
+
+    public void setFloat(String s, float f) {
+        this.map.put(s, NBTTagFloat.a(f));
+    }
+
+    public void setDouble(String s, double d0) {
+        this.map.put(s, NBTTagDouble.a(d0));
+    }
+
+    public void setString(String s, String s1) {
+        this.map.put(s, NBTTagString.a(s1));
+    }
+
+    public void setByteArray(String s, byte[] abyte) {
+        this.map.put(s, new NBTTagByteArray(abyte));
+    }
+
+    public void setIntArray(String s, int[] aint) {
+        this.map.put(s, new NBTTagIntArray(aint));
+    }
+
+    public void b(String s, List<Integer> list) {
+        this.map.put(s, new NBTTagIntArray(list));
+    }
+
+    public void a(String s, long[] along) {
+        this.map.put(s, new NBTTagLongArray(along));
+    }
+
+    public void c(String s, List<Long> list) {
+        this.map.put(s, new NBTTagLongArray(list));
+    }
+
+    public void setBoolean(String s, boolean flag) {
+        this.map.put(s, NBTTagByte.a(flag));
+    }
+
+    @Nullable
+    public NBTBase get(String s) {
+        return (NBTBase) this.map.get(s);
+    }
+
+    public byte d(String s) {
+        NBTBase nbtbase = (NBTBase) this.map.get(s);
+
+        return nbtbase == null ? 0 : nbtbase.getTypeId();
+    }
+
+    public boolean hasKey(String s) {
+        return this.map.containsKey(s);
+    }
+
+    public boolean hasKeyOfType(String s, int i) {
+        byte b0 = this.d(s);
+
+        return b0 == i ? true : (i != 99 ? false : b0 == 1 || b0 == 2 || b0 == 3 || b0 == 4 || b0 == 5 || b0 == 6);
+    }
+
+    public byte getByte(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTNumber) this.map.get(s)).asByte();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0;
+    }
+
+    public short getShort(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTNumber) this.map.get(s)).asShort();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0;
+    }
+
+    public int getInt(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTNumber) this.map.get(s)).asInt();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0;
+    }
+
+    public long getLong(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTNumber) this.map.get(s)).asLong();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0L;
+    }
+
+    public float getFloat(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTNumber) this.map.get(s)).asFloat();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0.0F;
+    }
+
+    public double getDouble(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTNumber) this.map.get(s)).asDouble();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0.0D;
+    }
+
+    public String getString(String s) {
+        try {
+            if (this.hasKeyOfType(s, 8)) {
+                return ((NBTBase) this.map.get(s)).asString();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return "";
+    }
+
+    public byte[] getByteArray(String s) {
+        try {
+            if (this.hasKeyOfType(s, 7)) {
+                return ((NBTTagByteArray) this.map.get(s)).getBytes();
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, NBTTagByteArray.a, classcastexception));
+        }
+
+        return new byte[0];
+    }
+
+    public int[] getIntArray(String s) {
+        try {
+            if (this.hasKeyOfType(s, 11)) {
+                return ((NBTTagIntArray) this.map.get(s)).getInts();
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, NBTTagIntArray.a, classcastexception));
+        }
+
+        return new int[0];
+    }
+
+    public long[] getLongArray(String s) {
+        try {
+            if (this.hasKeyOfType(s, 12)) {
+                return ((NBTTagLongArray) this.map.get(s)).getLongs();
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, NBTTagLongArray.a, classcastexception));
+        }
+
+        return new long[0];
+    }
+
+    public NBTTagCompound getCompound(String s) {
+        try {
+            if (this.hasKeyOfType(s, 10)) {
+                return (NBTTagCompound) this.map.get(s);
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, NBTTagCompound.b, classcastexception));
+        }
+
+        return new NBTTagCompound();
+    }
+
+    public NBTTagList getList(String s, int i) {
+        try {
+            if (this.d(s) == 9) {
+                NBTTagList nbttaglist = (NBTTagList) this.map.get(s);
+
+                if (!nbttaglist.isEmpty() && nbttaglist.d_() != i) {
+                    return new NBTTagList();
+                }
+
+                return nbttaglist;
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, NBTTagList.a, classcastexception));
+        }
+
+        return new NBTTagList();
+    }
+
+    public boolean getBoolean(String s) {
+        return this.getByte(s) != 0;
+    }
+
+    public void remove(String s) {
+        this.map.remove(s);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder stringbuilder = new StringBuilder("{");
+        Collection<String> collection = this.map.keySet();
+
+        if (NBTTagCompound.LOGGER.isDebugEnabled()) {
+            List<String> list = Lists.newArrayList(this.map.keySet());
+
+            Collections.sort(list);
+            collection = list;
+        }
+
+        String s;
+
+        for (Iterator iterator = ((Collection) collection).iterator(); iterator.hasNext(); stringbuilder.append(s(s)).append(':').append(this.map.get(s))) {
+            s = (String) iterator.next();
+            if (stringbuilder.length() != 1) {
+                stringbuilder.append(',');
+            }
+        }
+
+        return stringbuilder.append('}').toString();
+    }
+
+    public boolean isEmpty() {
+        return this.map.isEmpty();
+    }
+
+    private CrashReport a(String s, NBTTagType<?> nbttagtype, ClassCastException classcastexception) {
+        CrashReport crashreport = CrashReport.a(classcastexception, "Reading NBT data");
+        CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Corrupt NBT tag", 1);
+
+        crashreportsystemdetails.a("Tag type found", () -> {
+            return ((NBTBase) this.map.get(s)).b().a();
+        });
+        crashreportsystemdetails.a("Tag type expected", nbttagtype::a);
+        crashreportsystemdetails.a("Tag name", (Object) s);
+        return crashreport;
+    }
+
+    @Override
+    public NBTTagCompound clone() {
+        Map<String, NBTBase> map = Maps.newHashMap(Maps.transformValues(this.map, NBTBase::clone));
+
+        return new NBTTagCompound(map);
+    }
+
+    public boolean equals(Object object) {
+        return this == object ? true : object instanceof NBTTagCompound && Objects.equals(this.map, ((NBTTagCompound) object).map);
+    }
+
+    public int hashCode() {
+        return this.map.hashCode();
+    }
+
+    private static void a(String s, NBTBase nbtbase, DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(nbtbase.getTypeId());
+        if (nbtbase.getTypeId() != 0) {
+            dataoutput.writeUTF(s);
+            nbtbase.write(dataoutput);
+        }
+    }
+
+    private static byte c(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
+        return datainput.readByte();
+    }
+
+    private static String d(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
+        return datainput.readUTF();
+    }
+
+    private static NBTBase b(NBTTagType<?> nbttagtype, String s, DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) {
+        try {
+            return nbttagtype.b(datainput, i, nbtreadlimiter);
+        } catch (IOException ioexception) {
+            CrashReport crashreport = CrashReport.a(ioexception, "Loading NBT data");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("NBT Tag");
+
+            crashreportsystemdetails.a("Tag name", (Object) s);
+            crashreportsystemdetails.a("Tag type", (Object) nbttagtype.a());
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public NBTTagCompound a(NBTTagCompound nbttagcompound) {
+        Iterator iterator = nbttagcompound.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            NBTBase nbtbase = (NBTBase) nbttagcompound.map.get(s);
+
+            if (nbtbase.getTypeId() == 10) {
+                if (this.hasKeyOfType(s, 10)) {
+                    NBTTagCompound nbttagcompound1 = this.getCompound(s);
+
+                    nbttagcompound1.a((NBTTagCompound) nbtbase);
+                } else {
+                    this.set(s, nbtbase.clone());
+                }
+            } else {
+                this.set(s, nbtbase.clone());
+            }
+        }
+
+        return this;
+    }
+
+    protected static String s(String s) {
+        return NBTTagCompound.h.matcher(s).matches() ? s : NBTTagString.b(s);
+    }
+
+    protected static IChatBaseComponent t(String s) {
+        if (NBTTagCompound.h.matcher(s).matches()) {
+            return (new ChatComponentText(s)).a(NBTTagCompound.d);
+        } else {
+            String s1 = NBTTagString.b(s);
+            String s2 = s1.substring(0, 1);
+            IChatMutableComponent ichatmutablecomponent = (new ChatComponentText(s1.substring(1, s1.length() - 1))).a(NBTTagCompound.d);
+
+            return (new ChatComponentText(s2)).addSibling(ichatmutablecomponent).c(s2);
+        }
+    }
+
+    @Override
+    public IChatBaseComponent a(String s, int i) {
+        if (this.map.isEmpty()) {
+            return new ChatComponentText("{}");
+        } else {
+            ChatComponentText chatcomponenttext = new ChatComponentText("{");
+            Collection<String> collection = this.map.keySet();
+
+            if (NBTTagCompound.LOGGER.isDebugEnabled()) {
+                List<String> list = Lists.newArrayList(this.map.keySet());
+
+                Collections.sort(list);
+                collection = list;
+            }
+
+            if (!s.isEmpty()) {
+                chatcomponenttext.c("\n");
+            }
+
+            IChatMutableComponent ichatmutablecomponent;
+
+            for (Iterator iterator = ((Collection) collection).iterator(); iterator.hasNext(); chatcomponenttext.addSibling(ichatmutablecomponent)) {
+                String s1 = (String) iterator.next();
+
+                ichatmutablecomponent = (new ChatComponentText(Strings.repeat(s, i + 1))).addSibling(t(s1)).c(String.valueOf(':')).c(" ").addSibling(((NBTBase) this.map.get(s1)).a(s, i + 1));
+                if (iterator.hasNext()) {
+                    ichatmutablecomponent.c(String.valueOf(',')).c(s.isEmpty() ? " " : "\n");
+                }
+            }
+
+            if (!s.isEmpty()) {
+                chatcomponenttext.c("\n").c(Strings.repeat(s, i));
+            }
+
+            chatcomponenttext.c("}");
+            return chatcomponenttext;
+        }
+    }
+
+    protected Map<String, NBTBase> h() {
+        return Collections.unmodifiableMap(this.map);
+    }
+}
diff --git a/src/main/java/net/minecraft/nbt/NBTTagList.java b/src/main/java/net/minecraft/nbt/NBTTagList.java
new file mode 100644
index 0000000000000000000000000000000000000000..35cca76fb7c7aa736e64185b44016e65cfaef6cd
--- /dev/null
+++ b/src/main/java/net/minecraft/nbt/NBTTagList.java
@@ -0,0 +1,360 @@
+package net.minecraft.nbt;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import it.unimi.dsi.fastutil.bytes.ByteOpenHashSet;
+import it.unimi.dsi.fastutil.bytes.ByteSet;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import net.minecraft.network.chat.ChatComponentText;
+import net.minecraft.network.chat.IChatBaseComponent;
+
+public class NBTTagList extends NBTList<NBTBase> {
+
+    public static final NBTTagType<NBTTagList> a = new NBTTagType<NBTTagList>() {
+        @Override
+        public NBTTagList b(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+            nbtreadlimiter.a(296L);
+            if (i > 512) {
+                throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+            } else {
+                byte b0 = datainput.readByte();
+                int j = datainput.readInt();
+
+                if (b0 == 0 && j > 0) {
+                    throw new RuntimeException("Missing type on ListTag");
+                } else {
+                    nbtreadlimiter.a(32L * (long) j);
+                    NBTTagType<?> nbttagtype = NBTTagTypes.a(b0);
+                    List<NBTBase> list = Lists.newArrayListWithCapacity(j);
+
+                    for (int k = 0; k < j; ++k) {
+                        list.add(nbttagtype.b(datainput, i + 1, nbtreadlimiter));
+                    }
+
+                    return new NBTTagList(list, b0);
+                }
+            }
+        }
+
+        @Override
+        public String a() {
+            return "LIST";
+        }
+
+        @Override
+        public String b() {
+            return "TAG_List";
+        }
+    };
+    private static final ByteSet b = new ByteOpenHashSet(Arrays.asList(1, 2, 3, 4, 5, 6));
+    private final List<NBTBase> list;
+    private byte type;
+
+    private NBTTagList(List<NBTBase> list, byte b0) {
+        this.list = list;
+        this.type = b0;
+    }
+
+    public NBTTagList() {
+        this(Lists.newArrayList(), (byte) 0);
+    }
+
+    @Override
+    public void write(DataOutput dataoutput) throws IOException {
+        if (this.list.isEmpty()) {
+            this.type = 0;
+        } else {
+            this.type = ((NBTBase) this.list.get(0)).getTypeId();
+        }
+
+        dataoutput.writeByte(this.type);
+        dataoutput.writeInt(this.list.size());
+        Iterator iterator = this.list.iterator();
+
+        while (iterator.hasNext()) {
+            NBTBase nbtbase = (NBTBase) iterator.next();
+
+            nbtbase.write(dataoutput);
+        }
+
+    }
+
+    @Override
+    public byte getTypeId() {
+        return 9;
+    }
+
+    @Override
+    public NBTTagType<NBTTagList> b() {
+        return NBTTagList.a;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder stringbuilder = new StringBuilder("[");
+
+        for (int i = 0; i < this.list.size(); ++i) {
+            if (i != 0) {
+                stringbuilder.append(',');
+            }
+
+            stringbuilder.append(this.list.get(i));
+        }
+
+        return stringbuilder.append(']').toString();
+    }
+
+    private void g() {
+        if (this.list.isEmpty()) {
+            this.type = 0;
+        }
+
+    }
+
+    @Override
+    public NBTBase remove(int i) {
+        NBTBase nbtbase = (NBTBase) this.list.remove(i);
+
+        this.g();
+        return nbtbase;
+    }
+
+    public boolean isEmpty() {
+        return this.list.isEmpty();
+    }
+
+    public NBTTagCompound getCompound(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 10) {
+                return (NBTTagCompound) nbtbase;
+            }
+        }
+
+        return new NBTTagCompound();
+    }
+
+    public NBTTagList b(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 9) {
+                return (NBTTagList) nbtbase;
+            }
+        }
+
+        return new NBTTagList();
+    }
+
+    public short d(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 2) {
+                return ((NBTTagShort) nbtbase).asShort();
+            }
+        }
+
+        return 0;
+    }
+
+    public int e(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 3) {
+                return ((NBTTagInt) nbtbase).asInt();
+            }
+        }
+
+        return 0;
+    }
+
+    public int[] f(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 11) {
+                return ((NBTTagIntArray) nbtbase).getInts();
+            }
+        }
+
+        return new int[0];
+    }
+
+    public double h(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 6) {
+                return ((NBTTagDouble) nbtbase).asDouble();
+            }
+        }
+
+        return 0.0D;
+    }
+
+    public float i(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 5) {
+                return ((NBTTagFloat) nbtbase).asFloat();
+            }
+        }
+
+        return 0.0F;
+    }
+
+    public String getString(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 8 ? nbtbase.asString() : nbtbase.toString();
+        } else {
+            return "";
+        }
+    }
+
+    public int size() {
+        return this.list.size();
+    }
+
+    public NBTBase get(int i) {
+        return (NBTBase) this.list.get(i);
+    }
+
+    @Override
+    public NBTBase set(int i, NBTBase nbtbase) {
+        NBTBase nbtbase1 = this.get(i);
+
+        if (!this.a(i, nbtbase)) {
+            throw new UnsupportedOperationException(String.format("Trying to add tag of type %d to list of %d", nbtbase.getTypeId(), this.type));
+        } else {
+            return nbtbase1;
+        }
+    }
+
+    @Override
+    public void add(int i, NBTBase nbtbase) {
+        if (!this.b(i, nbtbase)) {
+            throw new UnsupportedOperationException(String.format("Trying to add tag of type %d to list of %d", nbtbase.getTypeId(), this.type));
+        }
+    }
+
+    @Override
+    public boolean a(int i, NBTBase nbtbase) {
+        if (this.a(nbtbase)) {
+            this.list.set(i, nbtbase);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean b(int i, NBTBase nbtbase) {
+        if (this.a(nbtbase)) {
+            this.list.add(i, nbtbase);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean a(NBTBase nbtbase) {
+        if (nbtbase.getTypeId() == 0) {
+            return false;
+        } else if (this.type == 0) {
+            this.type = nbtbase.getTypeId();
+            return true;
+        } else {
+            return this.type == nbtbase.getTypeId();
+        }
+    }
+
+    @Override
+    public NBTTagList clone() {
+        Iterable<NBTBase> iterable = NBTTagTypes.a(this.type).c() ? this.list : Iterables.transform(this.list, NBTBase::clone);
+        List<NBTBase> list = Lists.newArrayList((Iterable) iterable);
+
+        return new NBTTagList(list, this.type);
+    }
+
+    public boolean equals(Object object) {
+        return this == object ? true : object instanceof NBTTagList && Objects.equals(this.list, ((NBTTagList) object).list);
+    }
+
+    public int hashCode() {
+        return this.list.hashCode();
+    }
+
+    @Override
+    public IChatBaseComponent a(String s, int i) {
+        if (this.isEmpty()) {
+            return new ChatComponentText("[]");
+        } else {
+            int j;
+
+            if (NBTTagList.b.contains(this.type) && this.size() <= 8) {
+                String s1 = ", ";
+                ChatComponentText chatcomponenttext = new ChatComponentText("[");
+
+                for (j = 0; j < this.list.size(); ++j) {
+                    if (j != 0) {
+                        chatcomponenttext.c(", ");
+                    }
+
+                    chatcomponenttext.addSibling(((NBTBase) this.list.get(j)).l());
+                }
+
+                chatcomponenttext.c("]");
+                return chatcomponenttext;
+            } else {
+                ChatComponentText chatcomponenttext1 = new ChatComponentText("[");
+
+                if (!s.isEmpty()) {
+                    chatcomponenttext1.c("\n");
+                }
+
+                String s2 = String.valueOf(',');
+
+                for (j = 0; j < this.list.size(); ++j) {
+                    ChatComponentText chatcomponenttext2 = new ChatComponentText(Strings.repeat(s, i + 1));
+
+                    chatcomponenttext2.addSibling(((NBTBase) this.list.get(j)).a(s, i + 1));
+                    if (j != this.list.size() - 1) {
+                        chatcomponenttext2.c(s2).c(s.isEmpty() ? " " : "\n");
+                    }
+
+                    chatcomponenttext1.addSibling(chatcomponenttext2);
+                }
+
+                if (!s.isEmpty()) {
+                    chatcomponenttext1.c("\n").c(Strings.repeat(s, i));
+                }
+
+                chatcomponenttext1.c("]");
+                return chatcomponenttext1;
+            }
+        }
+    }
+
+    @Override
+    public byte d_() {
+        return this.type;
+    }
+
+    public void clear() {
+        this.list.clear();
+        this.type = 0;
+    }
+}
diff --git a/src/main/java/net/minecraft/nbt/NBTTagString.java b/src/main/java/net/minecraft/nbt/NBTTagString.java
new file mode 100644
index 0000000000000000000000000000000000000000..e26ef49d9dde8ed0fb4267b48cb597563967f313
--- /dev/null
+++ b/src/main/java/net/minecraft/nbt/NBTTagString.java
@@ -0,0 +1,127 @@
+package net.minecraft.nbt;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Objects;
+import net.minecraft.network.chat.ChatComponentText;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.network.chat.IChatMutableComponent;
+
+public class NBTTagString implements NBTBase {
+
+    public static final NBTTagType<NBTTagString> a = new NBTTagType<NBTTagString>() {
+        @Override
+        public NBTTagString b(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+            nbtreadlimiter.a(288L);
+            String s = datainput.readUTF();
+
+            nbtreadlimiter.a((long) (16 * s.length()));
+            return NBTTagString.a(s);
+        }
+
+        @Override
+        public String a() {
+            return "STRING";
+        }
+
+        @Override
+        public String b() {
+            return "TAG_String";
+        }
+
+        @Override
+        public boolean c() {
+            return true;
+        }
+    };
+    private static final NBTTagString b = new NBTTagString("");
+    private final String data;
+
+    private NBTTagString(String s) {
+        Objects.requireNonNull(s, "Null string not allowed");
+        this.data = s;
+    }
+
+    public static NBTTagString a(String s) {
+        return s.isEmpty() ? NBTTagString.b : new NBTTagString(s);
+    }
+
+    @Override
+    public void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeUTF(this.data);
+    }
+
+    @Override
+    public byte getTypeId() {
+        return 8;
+    }
+
+    @Override
+    public NBTTagType<NBTTagString> b() {
+        return NBTTagString.a;
+    }
+
+    @Override
+    public String toString() {
+        return b(this.data);
+    }
+
+    @Override
+    public NBTTagString clone() {
+        return this;
+    }
+
+    public boolean equals(Object object) {
+        return this == object ? true : object instanceof NBTTagString && Objects.equals(this.data, ((NBTTagString) object).data);
+    }
+
+    public int hashCode() {
+        return this.data.hashCode();
+    }
+
+    @Override
+    public String asString() {
+        return this.data;
+    }
+
+    @Override
+    public IChatBaseComponent a(String s, int i) {
+        String s1 = b(this.data);
+        String s2 = s1.substring(0, 1);
+        IChatMutableComponent ichatmutablecomponent = (new ChatComponentText(s1.substring(1, s1.length() - 1))).a(NBTTagString.e);
+
+        return (new ChatComponentText(s2)).addSibling(ichatmutablecomponent).c(s2);
+    }
+
+    public static String b(String s) {
+        StringBuilder stringbuilder = new StringBuilder(" ");
+        int i = 0;
+
+        for (int j = 0; j < s.length(); ++j) {
+            char c0 = s.charAt(j);
+
+            if (c0 == '\\') {
+                stringbuilder.append('\\');
+            } else if (c0 == '"' || c0 == '\'') {
+                if (i == 0) {
+                    i = c0 == '"' ? 39 : 34;
+                }
+
+                if (i == c0) {
+                    stringbuilder.append('\\');
+                }
+            }
+
+            stringbuilder.append(c0);
+        }
+
+        if (i == 0) {
+            i = 34;
+        }
+
+        stringbuilder.setCharAt(0, (char) i);
+        stringbuilder.append((char) i);
+        return stringbuilder.toString();
+    }
+}
diff --git a/src/main/java/net/minecraft/network/EnumProtocol.java b/src/main/java/net/minecraft/network/EnumProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab08336043d4f558434ed1f38d25cc555ace1ac0
--- /dev/null
+++ b/src/main/java/net/minecraft/network/EnumProtocol.java
@@ -0,0 +1,290 @@
+package net.minecraft.network;
+
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Supplier;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.network.protocol.EnumProtocolDirection;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.PacketPlayInAbilities;
+import net.minecraft.network.protocol.game.PacketPlayInAdvancements;
+import net.minecraft.network.protocol.game.PacketPlayInArmAnimation;
+import net.minecraft.network.protocol.game.PacketPlayInAutoRecipe;
+import net.minecraft.network.protocol.game.PacketPlayInBEdit;
+import net.minecraft.network.protocol.game.PacketPlayInBeacon;
+import net.minecraft.network.protocol.game.PacketPlayInBlockDig;
+import net.minecraft.network.protocol.game.PacketPlayInBlockPlace;
+import net.minecraft.network.protocol.game.PacketPlayInBoatMove;
+import net.minecraft.network.protocol.game.PacketPlayInChat;
+import net.minecraft.network.protocol.game.PacketPlayInClientCommand;
+import net.minecraft.network.protocol.game.PacketPlayInCloseWindow;
+import net.minecraft.network.protocol.game.PacketPlayInCustomPayload;
+import net.minecraft.network.protocol.game.PacketPlayInDifficultyChange;
+import net.minecraft.network.protocol.game.PacketPlayInDifficultyLock;
+import net.minecraft.network.protocol.game.PacketPlayInEnchantItem;
+import net.minecraft.network.protocol.game.PacketPlayInEntityAction;
+import net.minecraft.network.protocol.game.PacketPlayInEntityNBTQuery;
+import net.minecraft.network.protocol.game.PacketPlayInFlying;
+import net.minecraft.network.protocol.game.PacketPlayInHeldItemSlot;
+import net.minecraft.network.protocol.game.PacketPlayInItemName;
+import net.minecraft.network.protocol.game.PacketPlayInJigsawGenerate;
+import net.minecraft.network.protocol.game.PacketPlayInKeepAlive;
+import net.minecraft.network.protocol.game.PacketPlayInPickItem;
+import net.minecraft.network.protocol.game.PacketPlayInRecipeDisplayed;
+import net.minecraft.network.protocol.game.PacketPlayInRecipeSettings;
+import net.minecraft.network.protocol.game.PacketPlayInResourcePackStatus;
+import net.minecraft.network.protocol.game.PacketPlayInSetCommandBlock;
+import net.minecraft.network.protocol.game.PacketPlayInSetCommandMinecart;
+import net.minecraft.network.protocol.game.PacketPlayInSetCreativeSlot;
+import net.minecraft.network.protocol.game.PacketPlayInSetJigsaw;
+import net.minecraft.network.protocol.game.PacketPlayInSettings;
+import net.minecraft.network.protocol.game.PacketPlayInSpectate;
+import net.minecraft.network.protocol.game.PacketPlayInSteerVehicle;
+import net.minecraft.network.protocol.game.PacketPlayInStruct;
+import net.minecraft.network.protocol.game.PacketPlayInTabComplete;
+import net.minecraft.network.protocol.game.PacketPlayInTeleportAccept;
+import net.minecraft.network.protocol.game.PacketPlayInTileNBTQuery;
+import net.minecraft.network.protocol.game.PacketPlayInTrSel;
+import net.minecraft.network.protocol.game.PacketPlayInTransaction;
+import net.minecraft.network.protocol.game.PacketPlayInUpdateSign;
+import net.minecraft.network.protocol.game.PacketPlayInUseEntity;
+import net.minecraft.network.protocol.game.PacketPlayInUseItem;
+import net.minecraft.network.protocol.game.PacketPlayInVehicleMove;
+import net.minecraft.network.protocol.game.PacketPlayInWindowClick;
+import net.minecraft.network.protocol.game.PacketPlayOutAbilities;
+import net.minecraft.network.protocol.game.PacketPlayOutAdvancements;
+import net.minecraft.network.protocol.game.PacketPlayOutAnimation;
+import net.minecraft.network.protocol.game.PacketPlayOutAttachEntity;
+import net.minecraft.network.protocol.game.PacketPlayOutAutoRecipe;
+import net.minecraft.network.protocol.game.PacketPlayOutBlockAction;
+import net.minecraft.network.protocol.game.PacketPlayOutBlockBreak;
+import net.minecraft.network.protocol.game.PacketPlayOutBlockBreakAnimation;
+import net.minecraft.network.protocol.game.PacketPlayOutBlockChange;
+import net.minecraft.network.protocol.game.PacketPlayOutBoss;
+import net.minecraft.network.protocol.game.PacketPlayOutCamera;
+import net.minecraft.network.protocol.game.PacketPlayOutChat;
+import net.minecraft.network.protocol.game.PacketPlayOutCloseWindow;
+import net.minecraft.network.protocol.game.PacketPlayOutCollect;
+import net.minecraft.network.protocol.game.PacketPlayOutCombatEvent;
+import net.minecraft.network.protocol.game.PacketPlayOutCommands;
+import net.minecraft.network.protocol.game.PacketPlayOutCustomPayload;
+import net.minecraft.network.protocol.game.PacketPlayOutCustomSoundEffect;
+import net.minecraft.network.protocol.game.PacketPlayOutEntity;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityDestroy;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityEffect;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityEquipment;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityHeadRotation;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityMetadata;
+import net.minecraft.network.protocol.game.PacketPlayOutEntitySound;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityStatus;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityTeleport;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityVelocity;
+import net.minecraft.network.protocol.game.PacketPlayOutExperience;
+import net.minecraft.network.protocol.game.PacketPlayOutExplosion;
+import net.minecraft.network.protocol.game.PacketPlayOutGameStateChange;
+import net.minecraft.network.protocol.game.PacketPlayOutHeldItemSlot;
+import net.minecraft.network.protocol.game.PacketPlayOutKeepAlive;
+import net.minecraft.network.protocol.game.PacketPlayOutKickDisconnect;
+import net.minecraft.network.protocol.game.PacketPlayOutLightUpdate;
+import net.minecraft.network.protocol.game.PacketPlayOutLogin;
+import net.minecraft.network.protocol.game.PacketPlayOutLookAt;
+import net.minecraft.network.protocol.game.PacketPlayOutMap;
+import net.minecraft.network.protocol.game.PacketPlayOutMapChunk;
+import net.minecraft.network.protocol.game.PacketPlayOutMount;
+import net.minecraft.network.protocol.game.PacketPlayOutMultiBlockChange;
+import net.minecraft.network.protocol.game.PacketPlayOutNBTQuery;
+import net.minecraft.network.protocol.game.PacketPlayOutNamedEntitySpawn;
+import net.minecraft.network.protocol.game.PacketPlayOutNamedSoundEffect;
+import net.minecraft.network.protocol.game.PacketPlayOutOpenBook;
+import net.minecraft.network.protocol.game.PacketPlayOutOpenSignEditor;
+import net.minecraft.network.protocol.game.PacketPlayOutOpenWindow;
+import net.minecraft.network.protocol.game.PacketPlayOutOpenWindowHorse;
+import net.minecraft.network.protocol.game.PacketPlayOutOpenWindowMerchant;
+import net.minecraft.network.protocol.game.PacketPlayOutPlayerInfo;
+import net.minecraft.network.protocol.game.PacketPlayOutPlayerListHeaderFooter;
+import net.minecraft.network.protocol.game.PacketPlayOutPosition;
+import net.minecraft.network.protocol.game.PacketPlayOutRecipeUpdate;
+import net.minecraft.network.protocol.game.PacketPlayOutRecipes;
+import net.minecraft.network.protocol.game.PacketPlayOutRemoveEntityEffect;
+import net.minecraft.network.protocol.game.PacketPlayOutResourcePackSend;
+import net.minecraft.network.protocol.game.PacketPlayOutRespawn;
+import net.minecraft.network.protocol.game.PacketPlayOutScoreboardDisplayObjective;
+import net.minecraft.network.protocol.game.PacketPlayOutScoreboardObjective;
+import net.minecraft.network.protocol.game.PacketPlayOutScoreboardScore;
+import net.minecraft.network.protocol.game.PacketPlayOutScoreboardTeam;
+import net.minecraft.network.protocol.game.PacketPlayOutSelectAdvancementTab;
+import net.minecraft.network.protocol.game.PacketPlayOutServerDifficulty;
+import net.minecraft.network.protocol.game.PacketPlayOutSetCooldown;
+import net.minecraft.network.protocol.game.PacketPlayOutSetSlot;
+import net.minecraft.network.protocol.game.PacketPlayOutSpawnEntity;
+import net.minecraft.network.protocol.game.PacketPlayOutSpawnEntityExperienceOrb;
+import net.minecraft.network.protocol.game.PacketPlayOutSpawnEntityLiving;
+import net.minecraft.network.protocol.game.PacketPlayOutSpawnEntityPainting;
+import net.minecraft.network.protocol.game.PacketPlayOutSpawnPosition;
+import net.minecraft.network.protocol.game.PacketPlayOutStatistic;
+import net.minecraft.network.protocol.game.PacketPlayOutStopSound;
+import net.minecraft.network.protocol.game.PacketPlayOutTabComplete;
+import net.minecraft.network.protocol.game.PacketPlayOutTags;
+import net.minecraft.network.protocol.game.PacketPlayOutTileEntityData;
+import net.minecraft.network.protocol.game.PacketPlayOutTitle;
+import net.minecraft.network.protocol.game.PacketPlayOutTransaction;
+import net.minecraft.network.protocol.game.PacketPlayOutUnloadChunk;
+import net.minecraft.network.protocol.game.PacketPlayOutUpdateAttributes;
+import net.minecraft.network.protocol.game.PacketPlayOutUpdateHealth;
+import net.minecraft.network.protocol.game.PacketPlayOutUpdateTime;
+import net.minecraft.network.protocol.game.PacketPlayOutVehicleMove;
+import net.minecraft.network.protocol.game.PacketPlayOutViewCentre;
+import net.minecraft.network.protocol.game.PacketPlayOutViewDistance;
+import net.minecraft.network.protocol.game.PacketPlayOutWindowData;
+import net.minecraft.network.protocol.game.PacketPlayOutWindowItems;
+import net.minecraft.network.protocol.game.PacketPlayOutWorldBorder;
+import net.minecraft.network.protocol.game.PacketPlayOutWorldEvent;
+import net.minecraft.network.protocol.game.PacketPlayOutWorldParticles;
+import net.minecraft.network.protocol.handshake.PacketHandshakingInSetProtocol;
+import net.minecraft.network.protocol.login.PacketLoginInCustomPayload;
+import net.minecraft.network.protocol.login.PacketLoginInEncryptionBegin;
+import net.minecraft.network.protocol.login.PacketLoginInStart;
+import net.minecraft.network.protocol.login.PacketLoginOutCustomPayload;
+import net.minecraft.network.protocol.login.PacketLoginOutDisconnect;
+import net.minecraft.network.protocol.login.PacketLoginOutEncryptionBegin;
+import net.minecraft.network.protocol.login.PacketLoginOutSetCompression;
+import net.minecraft.network.protocol.login.PacketLoginOutSuccess;
+import net.minecraft.network.protocol.status.PacketStatusInPing;
+import net.minecraft.network.protocol.status.PacketStatusInStart;
+import net.minecraft.network.protocol.status.PacketStatusOutPong;
+import net.minecraft.network.protocol.status.PacketStatusOutServerInfo;
+import org.apache.logging.log4j.LogManager;
+
+public enum EnumProtocol {
+
+    HANDSHAKING(-1, b().a(EnumProtocolDirection.SERVERBOUND, (new EnumProtocol.a<>()).a(PacketHandshakingInSetProtocol.class, PacketHandshakingInSetProtocol::new))), PLAY(0, b().a(EnumProtocolDirection.CLIENTBOUND, (new EnumProtocol.a<>()).a(PacketPlayOutSpawnEntity.class, PacketPlayOutSpawnEntity::new).a(PacketPlayOutSpawnEntityExperienceOrb.class, PacketPlayOutSpawnEntityExperienceOrb::new).a(PacketPlayOutSpawnEntityLiving.class, PacketPlayOutSpawnEntityLiving::new).a(PacketPlayOutSpawnEntityPainting.class, PacketPlayOutSpawnEntityPainting::new).a(PacketPlayOutNamedEntitySpawn.class, PacketPlayOutNamedEntitySpawn::new).a(PacketPlayOutAnimation.class, PacketPlayOutAnimation::new).a(PacketPlayOutStatistic.class, PacketPlayOutStatistic::new).a(PacketPlayOutBlockBreak.class, PacketPlayOutBlockBreak::new).a(PacketPlayOutBlockBreakAnimation.class, PacketPlayOutBlockBreakAnimation::new).a(PacketPlayOutTileEntityData.class, PacketPlayOutTileEntityData::new).a(PacketPlayOutBlockAction.class, PacketPlayOutBlockAction::new).a(PacketPlayOutBlockChange.class, PacketPlayOutBlockChange::new).a(PacketPlayOutBoss.class, PacketPlayOutBoss::new).a(PacketPlayOutServerDifficulty.class, PacketPlayOutServerDifficulty::new).a(PacketPlayOutChat.class, PacketPlayOutChat::new).a(PacketPlayOutTabComplete.class, PacketPlayOutTabComplete::new).a(PacketPlayOutCommands.class, PacketPlayOutCommands::new).a(PacketPlayOutTransaction.class, PacketPlayOutTransaction::new).a(PacketPlayOutCloseWindow.class, PacketPlayOutCloseWindow::new).a(PacketPlayOutWindowItems.class, PacketPlayOutWindowItems::new).a(PacketPlayOutWindowData.class, PacketPlayOutWindowData::new).a(PacketPlayOutSetSlot.class, PacketPlayOutSetSlot::new).a(PacketPlayOutSetCooldown.class, PacketPlayOutSetCooldown::new).a(PacketPlayOutCustomPayload.class, PacketPlayOutCustomPayload::new).a(PacketPlayOutCustomSoundEffect.class, PacketPlayOutCustomSoundEffect::new).a(PacketPlayOutKickDisconnect.class, PacketPlayOutKickDisconnect::new).a(PacketPlayOutEntityStatus.class, PacketPlayOutEntityStatus::new).a(PacketPlayOutExplosion.class, PacketPlayOutExplosion::new).a(PacketPlayOutUnloadChunk.class, PacketPlayOutUnloadChunk::new).a(PacketPlayOutGameStateChange.class, PacketPlayOutGameStateChange::new).a(PacketPlayOutOpenWindowHorse.class, PacketPlayOutOpenWindowHorse::new).a(PacketPlayOutKeepAlive.class, PacketPlayOutKeepAlive::new).a(PacketPlayOutMapChunk.class, PacketPlayOutMapChunk::new).a(PacketPlayOutWorldEvent.class, PacketPlayOutWorldEvent::new).a(PacketPlayOutWorldParticles.class, PacketPlayOutWorldParticles::new).a(PacketPlayOutLightUpdate.class, PacketPlayOutLightUpdate::new).a(PacketPlayOutLogin.class, PacketPlayOutLogin::new).a(PacketPlayOutMap.class, PacketPlayOutMap::new).a(PacketPlayOutOpenWindowMerchant.class, PacketPlayOutOpenWindowMerchant::new).a(PacketPlayOutEntity.PacketPlayOutRelEntityMove.class, PacketPlayOutEntity.PacketPlayOutRelEntityMove::new).a(PacketPlayOutEntity.PacketPlayOutRelEntityMoveLook.class, PacketPlayOutEntity.PacketPlayOutRelEntityMoveLook::new).a(PacketPlayOutEntity.PacketPlayOutEntityLook.class, PacketPlayOutEntity.PacketPlayOutEntityLook::new).a(PacketPlayOutEntity.class, PacketPlayOutEntity::new).a(PacketPlayOutVehicleMove.class, PacketPlayOutVehicleMove::new).a(PacketPlayOutOpenBook.class, PacketPlayOutOpenBook::new).a(PacketPlayOutOpenWindow.class, PacketPlayOutOpenWindow::new).a(PacketPlayOutOpenSignEditor.class, PacketPlayOutOpenSignEditor::new).a(PacketPlayOutAutoRecipe.class, PacketPlayOutAutoRecipe::new).a(PacketPlayOutAbilities.class, PacketPlayOutAbilities::new).a(PacketPlayOutCombatEvent.class, PacketPlayOutCombatEvent::new).a(PacketPlayOutPlayerInfo.class, PacketPlayOutPlayerInfo::new).a(PacketPlayOutLookAt.class, PacketPlayOutLookAt::new).a(PacketPlayOutPosition.class, PacketPlayOutPosition::new).a(PacketPlayOutRecipes.class, PacketPlayOutRecipes::new).a(PacketPlayOutEntityDestroy.class, PacketPlayOutEntityDestroy::new).a(PacketPlayOutRemoveEntityEffect.class, PacketPlayOutRemoveEntityEffect::new).a(PacketPlayOutResourcePackSend.class, PacketPlayOutResourcePackSend::new).a(PacketPlayOutRespawn.class, PacketPlayOutRespawn::new).a(PacketPlayOutEntityHeadRotation.class, PacketPlayOutEntityHeadRotation::new).a(PacketPlayOutMultiBlockChange.class, PacketPlayOutMultiBlockChange::new).a(PacketPlayOutSelectAdvancementTab.class, PacketPlayOutSelectAdvancementTab::new).a(PacketPlayOutWorldBorder.class, PacketPlayOutWorldBorder::new).a(PacketPlayOutCamera.class, PacketPlayOutCamera::new).a(PacketPlayOutHeldItemSlot.class, PacketPlayOutHeldItemSlot::new).a(PacketPlayOutViewCentre.class, PacketPlayOutViewCentre::new).a(PacketPlayOutViewDistance.class, PacketPlayOutViewDistance::new).a(PacketPlayOutSpawnPosition.class, PacketPlayOutSpawnPosition::new).a(PacketPlayOutScoreboardDisplayObjective.class, PacketPlayOutScoreboardDisplayObjective::new).a(PacketPlayOutEntityMetadata.class, PacketPlayOutEntityMetadata::new).a(PacketPlayOutAttachEntity.class, PacketPlayOutAttachEntity::new).a(PacketPlayOutEntityVelocity.class, PacketPlayOutEntityVelocity::new).a(PacketPlayOutEntityEquipment.class, PacketPlayOutEntityEquipment::new).a(PacketPlayOutExperience.class, PacketPlayOutExperience::new).a(PacketPlayOutUpdateHealth.class, PacketPlayOutUpdateHealth::new).a(PacketPlayOutScoreboardObjective.class, PacketPlayOutScoreboardObjective::new).a(PacketPlayOutMount.class, PacketPlayOutMount::new).a(PacketPlayOutScoreboardTeam.class, PacketPlayOutScoreboardTeam::new).a(PacketPlayOutScoreboardScore.class, PacketPlayOutScoreboardScore::new).a(PacketPlayOutUpdateTime.class, PacketPlayOutUpdateTime::new).a(PacketPlayOutTitle.class, PacketPlayOutTitle::new).a(PacketPlayOutEntitySound.class, PacketPlayOutEntitySound::new).a(PacketPlayOutNamedSoundEffect.class, PacketPlayOutNamedSoundEffect::new).a(PacketPlayOutStopSound.class, PacketPlayOutStopSound::new).a(PacketPlayOutPlayerListHeaderFooter.class, PacketPlayOutPlayerListHeaderFooter::new).a(PacketPlayOutNBTQuery.class, PacketPlayOutNBTQuery::new).a(PacketPlayOutCollect.class, PacketPlayOutCollect::new).a(PacketPlayOutEntityTeleport.class, PacketPlayOutEntityTeleport::new).a(PacketPlayOutAdvancements.class, PacketPlayOutAdvancements::new).a(PacketPlayOutUpdateAttributes.class, PacketPlayOutUpdateAttributes::new).a(PacketPlayOutEntityEffect.class, PacketPlayOutEntityEffect::new).a(PacketPlayOutRecipeUpdate.class, PacketPlayOutRecipeUpdate::new).a(PacketPlayOutTags.class, PacketPlayOutTags::new)).a(EnumProtocolDirection.SERVERBOUND, (new EnumProtocol.a<>()).a(PacketPlayInTeleportAccept.class, PacketPlayInTeleportAccept::new).a(PacketPlayInTileNBTQuery.class, PacketPlayInTileNBTQuery::new).a(PacketPlayInDifficultyChange.class, PacketPlayInDifficultyChange::new).a(PacketPlayInChat.class, PacketPlayInChat::new).a(PacketPlayInClientCommand.class, PacketPlayInClientCommand::new).a(PacketPlayInSettings.class, PacketPlayInSettings::new).a(PacketPlayInTabComplete.class, PacketPlayInTabComplete::new).a(PacketPlayInTransaction.class, PacketPlayInTransaction::new).a(PacketPlayInEnchantItem.class, PacketPlayInEnchantItem::new).a(PacketPlayInWindowClick.class, PacketPlayInWindowClick::new).a(PacketPlayInCloseWindow.class, PacketPlayInCloseWindow::new).a(PacketPlayInCustomPayload.class, PacketPlayInCustomPayload::new).a(PacketPlayInBEdit.class, PacketPlayInBEdit::new).a(PacketPlayInEntityNBTQuery.class, PacketPlayInEntityNBTQuery::new).a(PacketPlayInUseEntity.class, PacketPlayInUseEntity::new).a(PacketPlayInJigsawGenerate.class, PacketPlayInJigsawGenerate::new).a(PacketPlayInKeepAlive.class, PacketPlayInKeepAlive::new).a(PacketPlayInDifficultyLock.class, PacketPlayInDifficultyLock::new).a(PacketPlayInFlying.PacketPlayInPosition.class, PacketPlayInFlying.PacketPlayInPosition::new).a(PacketPlayInFlying.PacketPlayInPositionLook.class, PacketPlayInFlying.PacketPlayInPositionLook::new).a(PacketPlayInFlying.PacketPlayInLook.class, PacketPlayInFlying.PacketPlayInLook::new).a(PacketPlayInFlying.class, PacketPlayInFlying::new).a(PacketPlayInVehicleMove.class, PacketPlayInVehicleMove::new).a(PacketPlayInBoatMove.class, PacketPlayInBoatMove::new).a(PacketPlayInPickItem.class, PacketPlayInPickItem::new).a(PacketPlayInAutoRecipe.class, PacketPlayInAutoRecipe::new).a(PacketPlayInAbilities.class, PacketPlayInAbilities::new).a(PacketPlayInBlockDig.class, PacketPlayInBlockDig::new).a(PacketPlayInEntityAction.class, PacketPlayInEntityAction::new).a(PacketPlayInSteerVehicle.class, PacketPlayInSteerVehicle::new).a(PacketPlayInRecipeSettings.class, PacketPlayInRecipeSettings::new).a(PacketPlayInRecipeDisplayed.class, PacketPlayInRecipeDisplayed::new).a(PacketPlayInItemName.class, PacketPlayInItemName::new).a(PacketPlayInResourcePackStatus.class, PacketPlayInResourcePackStatus::new).a(PacketPlayInAdvancements.class, PacketPlayInAdvancements::new).a(PacketPlayInTrSel.class, PacketPlayInTrSel::new).a(PacketPlayInBeacon.class, PacketPlayInBeacon::new).a(PacketPlayInHeldItemSlot.class, PacketPlayInHeldItemSlot::new).a(PacketPlayInSetCommandBlock.class, PacketPlayInSetCommandBlock::new).a(PacketPlayInSetCommandMinecart.class, PacketPlayInSetCommandMinecart::new).a(PacketPlayInSetCreativeSlot.class, PacketPlayInSetCreativeSlot::new).a(PacketPlayInSetJigsaw.class, PacketPlayInSetJigsaw::new).a(PacketPlayInStruct.class, PacketPlayInStruct::new).a(PacketPlayInUpdateSign.class, PacketPlayInUpdateSign::new).a(PacketPlayInArmAnimation.class, PacketPlayInArmAnimation::new).a(PacketPlayInSpectate.class, PacketPlayInSpectate::new).a(PacketPlayInUseItem.class, PacketPlayInUseItem::new).a(PacketPlayInBlockPlace.class, PacketPlayInBlockPlace::new))), STATUS(1, b().a(EnumProtocolDirection.SERVERBOUND, (new EnumProtocol.a<>()).a(PacketStatusInStart.class, PacketStatusInStart::new).a(PacketStatusInPing.class, PacketStatusInPing::new)).a(EnumProtocolDirection.CLIENTBOUND, (new EnumProtocol.a<>()).a(PacketStatusOutServerInfo.class, PacketStatusOutServerInfo::new).a(PacketStatusOutPong.class, PacketStatusOutPong::new))), LOGIN(2, b().a(EnumProtocolDirection.CLIENTBOUND, (new EnumProtocol.a<>()).a(PacketLoginOutDisconnect.class, PacketLoginOutDisconnect::new).a(PacketLoginOutEncryptionBegin.class, PacketLoginOutEncryptionBegin::new).a(PacketLoginOutSuccess.class, PacketLoginOutSuccess::new).a(PacketLoginOutSetCompression.class, PacketLoginOutSetCompression::new).a(PacketLoginOutCustomPayload.class, PacketLoginOutCustomPayload::new)).a(EnumProtocolDirection.SERVERBOUND, (new EnumProtocol.a<>()).a(PacketLoginInStart.class, PacketLoginInStart::new).a(PacketLoginInEncryptionBegin.class, PacketLoginInEncryptionBegin::new).a(PacketLoginInCustomPayload.class, PacketLoginInCustomPayload::new)));
+
+    private static final EnumProtocol[] e = new EnumProtocol[4];
+    private static final Map<Class<? extends Packet<?>>, EnumProtocol> f = Maps.newHashMap();
+    private final int g;
+    private final Map<EnumProtocolDirection, ? extends EnumProtocol.a<?>> h;
+
+    private static EnumProtocol.b b() {
+        return new EnumProtocol.b();
+    }
+
+    private EnumProtocol(int i, EnumProtocol.b enumprotocol_b) {
+        this.g = i;
+        this.h = enumprotocol_b.a;
+    }
+
+    @Nullable
+    public Integer a(EnumProtocolDirection enumprotocoldirection, Packet<?> packet) {
+        return ((EnumProtocol.a) this.h.get(enumprotocoldirection)).a(packet.getClass());
+    }
+
+    @Nullable
+    public Packet<?> a(EnumProtocolDirection enumprotocoldirection, int i) {
+        return ((EnumProtocol.a) this.h.get(enumprotocoldirection)).a(i);
+    }
+
+    public int a() {
+        return this.g;
+    }
+
+    @Nullable
+    public static EnumProtocol a(int i) {
+        return i >= -1 && i <= 2 ? EnumProtocol.e[i - -1] : null;
+    }
+
+    public static EnumProtocol a(Packet<?> packet) {
+        return (EnumProtocol) EnumProtocol.f.get(packet.getClass());
+    }
+
+    static {
+        EnumProtocol[] aenumprotocol = values();
+        int i = aenumprotocol.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumProtocol enumprotocol = aenumprotocol[j];
+            int k = enumprotocol.a();
+
+            if (k < -1 || k > 2) {
+                throw new Error("Invalid protocol ID " + Integer.toString(k));
+            }
+
+            EnumProtocol.e[k - -1] = enumprotocol;
+            enumprotocol.h.forEach((enumprotocoldirection, enumprotocol_a) -> {
+                enumprotocol_a.a().forEach((oclass) -> {
+                    if (EnumProtocol.f.containsKey(oclass) && EnumProtocol.f.get(oclass) != enumprotocol) {
+                        throw new IllegalStateException("Packet " + oclass + " is already assigned to protocol " + EnumProtocol.f.get(oclass) + " - can't reassign to " + enumprotocol);
+                    } else {
+                        EnumProtocol.f.put(oclass, enumprotocol);
+                    }
+                });
+            });
+        }
+
+    }
+
+    static class b {
+
+        private final Map<EnumProtocolDirection, EnumProtocol.a<?>> a;
+
+        private b() {
+            this.a = Maps.newEnumMap(EnumProtocolDirection.class);
+        }
+
+        public <T extends PacketListener> EnumProtocol.b a(EnumProtocolDirection enumprotocoldirection, EnumProtocol.a<T> enumprotocol_a) {
+            this.a.put(enumprotocoldirection, enumprotocol_a);
+            return this;
+        }
+    }
+
+    static class a<T extends PacketListener> {
+
+        private final Object2IntMap<Class<? extends Packet<T>>> a;
+        private final List<Supplier<? extends Packet<T>>> b;
+
+        private a() {
+            this.a = (Object2IntMap) SystemUtils.a((Object) (new Object2IntOpenHashMap()), (object2intopenhashmap) -> {
+                object2intopenhashmap.defaultReturnValue(-1);
+            });
+            this.b = Lists.newArrayList();
+        }
+
+        public <P extends Packet<T>> EnumProtocol.a<T> a(Class<P> oclass, Supplier<P> supplier) {
+            int i = this.b.size();
+            int j = this.a.put(oclass, i);
+
+            if (j != -1) {
+                String s = "Packet " + oclass + " is already registered to ID " + j;
+
+                LogManager.getLogger().fatal(s);
+                throw new IllegalArgumentException(s);
+            } else {
+                this.b.add(supplier);
+                return this;
+            }
+        }
+
+        @Nullable
+        public Integer a(Class<?> oclass) {
+            int i = this.a.getInt(oclass);
+
+            return i == -1 ? null : i;
+        }
+
+        @Nullable
+        public Packet<?> a(int i) {
+            Supplier<? extends Packet<T>> supplier = (Supplier) this.b.get(i);
+
+            return supplier != null ? (Packet) supplier.get() : null;
+        }
+
+        public Iterable<Class<? extends Packet<?>>> a() {
+            return Iterables.unmodifiableIterable(this.a.keySet());
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/network/PacketCompressor.java b/src/main/java/net/minecraft/network/PacketCompressor.java
new file mode 100644
index 0000000000000000000000000000000000000000..45b9d3d3c84d11e7f27f699506a1036dff9fdc53
--- /dev/null
+++ b/src/main/java/net/minecraft/network/PacketCompressor.java
@@ -0,0 +1,48 @@
+package net.minecraft.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import java.util.zip.Deflater;
+
+public class PacketCompressor extends MessageToByteEncoder<ByteBuf> {
+
+    private final byte[] a = new byte[8192];
+    private final Deflater b;
+    private int c;
+
+    public PacketCompressor(int i) {
+        this.c = i;
+        this.b = new Deflater();
+    }
+
+    protected void encode(ChannelHandlerContext channelhandlercontext, ByteBuf bytebuf, ByteBuf bytebuf1) throws Exception {
+        int i = bytebuf.readableBytes();
+        PacketDataSerializer packetdataserializer = new PacketDataSerializer(bytebuf1);
+
+        if (i < this.c) {
+            packetdataserializer.d(0);
+            packetdataserializer.writeBytes(bytebuf);
+        } else {
+            byte[] abyte = new byte[i];
+
+            bytebuf.readBytes(abyte);
+            packetdataserializer.d(abyte.length);
+            this.b.setInput(abyte, 0, i);
+            this.b.finish();
+
+            while (!this.b.finished()) {
+                int j = this.b.deflate(this.a);
+
+                packetdataserializer.writeBytes(this.a, 0, j);
+            }
+
+            this.b.reset();
+        }
+
+    }
+
+    public void a(int i) {
+        this.c = i;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/PacketDecompressor.java b/src/main/java/net/minecraft/network/PacketDecompressor.java
new file mode 100644
index 0000000000000000000000000000000000000000..1932ca55dad37ca773f215eaec23164533d509d3
--- /dev/null
+++ b/src/main/java/net/minecraft/network/PacketDecompressor.java
@@ -0,0 +1,54 @@
+package net.minecraft.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.handler.codec.DecoderException;
+import java.util.List;
+import java.util.zip.Inflater;
+
+public class PacketDecompressor extends ByteToMessageDecoder {
+
+    private final Inflater a;
+    private int b;
+
+    public PacketDecompressor(int i) {
+        this.b = i;
+        this.a = new Inflater();
+    }
+
+    protected void decode(ChannelHandlerContext channelhandlercontext, ByteBuf bytebuf, List<Object> list) throws Exception {
+        if (bytebuf.readableBytes() != 0) {
+            PacketDataSerializer packetdataserializer = new PacketDataSerializer(bytebuf);
+            int i = packetdataserializer.i();
+
+            if (i == 0) {
+                list.add(packetdataserializer.readBytes(packetdataserializer.readableBytes()));
+            } else {
+                if (i < this.b) {
+                    throw new DecoderException("Badly compressed packet - size of " + i + " is below server threshold of " + this.b);
+                }
+
+                if (i > 2097152) {
+                    throw new DecoderException("Badly compressed packet - size of " + i + " is larger than protocol maximum of " + 2097152);
+                }
+
+                byte[] abyte = new byte[packetdataserializer.readableBytes()];
+
+                packetdataserializer.readBytes(abyte);
+                this.a.setInput(abyte);
+                byte[] abyte1 = new byte[i];
+
+                this.a.inflate(abyte1);
+                list.add(Unpooled.wrappedBuffer(abyte1));
+                this.a.reset();
+            }
+
+        }
+    }
+
+    public void a(int i) {
+        this.b = i;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/PacketDecrypter.java b/src/main/java/net/minecraft/network/PacketDecrypter.java
new file mode 100644
index 0000000000000000000000000000000000000000..c8aa02b288d67efe1f9e20e038248a4f032f92dd
--- /dev/null
+++ b/src/main/java/net/minecraft/network/PacketDecrypter.java
@@ -0,0 +1,20 @@
+package net.minecraft.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import java.util.List;
+import javax.crypto.Cipher;
+
+public class PacketDecrypter extends MessageToMessageDecoder<ByteBuf> {
+
+    private final PacketEncryptionHandler a;
+
+    public PacketDecrypter(Cipher cipher) {
+        this.a = new PacketEncryptionHandler(cipher);
+    }
+
+    protected void decode(ChannelHandlerContext channelhandlercontext, ByteBuf bytebuf, List<Object> list) throws Exception {
+        list.add(this.a.a(channelhandlercontext, bytebuf));
+    }
+}
diff --git a/src/main/java/net/minecraft/network/PacketEncoder.java b/src/main/java/net/minecraft/network/PacketEncoder.java
new file mode 100644
index 0000000000000000000000000000000000000000..06098698e4adc31aa96f9592975e441f965b5558
--- /dev/null
+++ b/src/main/java/net/minecraft/network/PacketEncoder.java
@@ -0,0 +1,56 @@
+package net.minecraft.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import java.io.IOException;
+import net.minecraft.network.protocol.EnumProtocolDirection;
+import net.minecraft.network.protocol.Packet;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.MarkerManager;
+
+public class PacketEncoder extends MessageToByteEncoder<Packet<?>> {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final Marker b = MarkerManager.getMarker("PACKET_SENT", NetworkManager.b);
+    private final EnumProtocolDirection c;
+
+    public PacketEncoder(EnumProtocolDirection enumprotocoldirection) {
+        this.c = enumprotocoldirection;
+    }
+
+    protected void encode(ChannelHandlerContext channelhandlercontext, Packet<?> packet, ByteBuf bytebuf) throws Exception {
+        EnumProtocol enumprotocol = (EnumProtocol) channelhandlercontext.channel().attr(NetworkManager.c).get();
+
+        if (enumprotocol == null) {
+            throw new RuntimeException("ConnectionProtocol unknown: " + packet);
+        } else {
+            Integer integer = enumprotocol.a(this.c, packet);
+
+            if (PacketEncoder.LOGGER.isDebugEnabled()) {
+                PacketEncoder.LOGGER.debug(PacketEncoder.b, "OUT: [{}:{}] {}", channelhandlercontext.channel().attr(NetworkManager.c).get(), integer, packet.getClass().getName());
+            }
+
+            if (integer == null) {
+                throw new IOException("Can't serialize unregistered packet");
+            } else {
+                PacketDataSerializer packetdataserializer = new PacketDataSerializer(bytebuf);
+
+                packetdataserializer.d(integer);
+
+                try {
+                    packet.b(packetdataserializer);
+                } catch (Throwable throwable) {
+                    PacketEncoder.LOGGER.error(throwable);
+                    if (packet.a()) {
+                        throw new SkipEncodeException(throwable);
+                    } else {
+                        throw throwable;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/network/PacketEncrypter.java b/src/main/java/net/minecraft/network/PacketEncrypter.java
new file mode 100644
index 0000000000000000000000000000000000000000..5759f91d5e9dc52b16c8955b8d318da2b53c7af4
--- /dev/null
+++ b/src/main/java/net/minecraft/network/PacketEncrypter.java
@@ -0,0 +1,19 @@
+package net.minecraft.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import javax.crypto.Cipher;
+
+public class PacketEncrypter extends MessageToByteEncoder<ByteBuf> {
+
+    private final PacketEncryptionHandler a;
+
+    public PacketEncrypter(Cipher cipher) {
+        this.a = new PacketEncryptionHandler(cipher);
+    }
+
+    protected void encode(ChannelHandlerContext channelhandlercontext, ByteBuf bytebuf, ByteBuf bytebuf1) throws Exception {
+        this.a.a(bytebuf, bytebuf1);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/PacketSplitter.java b/src/main/java/net/minecraft/network/PacketSplitter.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c7de7ab6da2106394ec668cd7cb9be1f8dabeb3
--- /dev/null
+++ b/src/main/java/net/minecraft/network/PacketSplitter.java
@@ -0,0 +1,47 @@
+package net.minecraft.network;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.handler.codec.CorruptedFrameException;
+import java.util.List;
+
+public class PacketSplitter extends ByteToMessageDecoder {
+
+    public PacketSplitter() {}
+
+    protected void decode(ChannelHandlerContext channelhandlercontext, ByteBuf bytebuf, List<Object> list) throws Exception {
+        bytebuf.markReaderIndex();
+        byte[] abyte = new byte[3];
+
+        for (int i = 0; i < abyte.length; ++i) {
+            if (!bytebuf.isReadable()) {
+                bytebuf.resetReaderIndex();
+                return;
+            }
+
+            abyte[i] = bytebuf.readByte();
+            if (abyte[i] >= 0) {
+                PacketDataSerializer packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(abyte));
+
+                try {
+                    int j = packetdataserializer.i();
+
+                    if (bytebuf.readableBytes() >= j) {
+                        list.add(bytebuf.readBytes(j));
+                        return;
+                    }
+
+                    bytebuf.resetReaderIndex();
+                } finally {
+                    packetdataserializer.release();
+                }
+
+                return;
+            }
+        }
+
+        throw new CorruptedFrameException("length wider than 21-bit");
+    }
+}
diff --git a/src/main/java/net/minecraft/network/chat/ChatComponentUtils.java b/src/main/java/net/minecraft/network/chat/ChatComponentUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..b00e5d811ddfa12937f57bac4debb2fdd057d6e1
--- /dev/null
+++ b/src/main/java/net/minecraft/network/chat/ChatComponentUtils.java
@@ -0,0 +1,114 @@
+package net.minecraft.network.chat;
+
+import com.google.common.collect.Lists;
+import com.mojang.authlib.GameProfile;
+import com.mojang.brigadier.Message;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.Function;
+import javax.annotation.Nullable;
+import net.minecraft.EnumChatFormat;
+import net.minecraft.commands.CommandListenerWrapper;
+import net.minecraft.world.entity.Entity;
+
+public class ChatComponentUtils {
+
+    public static IChatMutableComponent a(IChatMutableComponent ichatmutablecomponent, ChatModifier chatmodifier) {
+        if (chatmodifier.g()) {
+            return ichatmutablecomponent;
+        } else {
+            ChatModifier chatmodifier1 = ichatmutablecomponent.getChatModifier();
+
+            return chatmodifier1.g() ? ichatmutablecomponent.setChatModifier(chatmodifier) : (chatmodifier1.equals(chatmodifier) ? ichatmutablecomponent : ichatmutablecomponent.setChatModifier(chatmodifier1.setChatModifier(chatmodifier)));
+        }
+    }
+
+    public static IChatMutableComponent filterForDisplay(@Nullable CommandListenerWrapper commandlistenerwrapper, IChatBaseComponent ichatbasecomponent, @Nullable Entity entity, int i) throws CommandSyntaxException {
+        if (i > 100) {
+            return ichatbasecomponent.mutableCopy();
+        } else {
+            IChatMutableComponent ichatmutablecomponent = ichatbasecomponent instanceof ChatComponentContextual ? ((ChatComponentContextual) ichatbasecomponent).a(commandlistenerwrapper, entity, i + 1) : ichatbasecomponent.g();
+            Iterator iterator = ichatbasecomponent.getSiblings().iterator();
+
+            while (iterator.hasNext()) {
+                IChatBaseComponent ichatbasecomponent1 = (IChatBaseComponent) iterator.next();
+
+                ichatmutablecomponent.addSibling(filterForDisplay(commandlistenerwrapper, ichatbasecomponent1, entity, i + 1));
+            }
+
+            return ichatmutablecomponent.c(a(commandlistenerwrapper, ichatbasecomponent.getChatModifier(), entity, i));
+        }
+    }
+
+    private static ChatModifier a(@Nullable CommandListenerWrapper commandlistenerwrapper, ChatModifier chatmodifier, @Nullable Entity entity, int i) throws CommandSyntaxException {
+        ChatHoverable chathoverable = chatmodifier.getHoverEvent();
+
+        if (chathoverable != null) {
+            IChatBaseComponent ichatbasecomponent = (IChatBaseComponent) chathoverable.a(ChatHoverable.EnumHoverAction.SHOW_TEXT);
+
+            if (ichatbasecomponent != null) {
+                ChatHoverable chathoverable1 = new ChatHoverable(ChatHoverable.EnumHoverAction.SHOW_TEXT, filterForDisplay(commandlistenerwrapper, ichatbasecomponent, entity, i + 1));
+
+                return chatmodifier.setChatHoverable(chathoverable1);
+            }
+        }
+
+        return chatmodifier;
+    }
+
+    public static IChatBaseComponent a(GameProfile gameprofile) {
+        return gameprofile.getName() != null ? new ChatComponentText(gameprofile.getName()) : (gameprofile.getId() != null ? new ChatComponentText(gameprofile.getId().toString()) : new ChatComponentText("(unknown)"));
+    }
+
+    public static IChatBaseComponent a(Collection<String> collection) {
+        return a(collection, (s) -> {
+            return (new ChatComponentText(s)).a(EnumChatFormat.GREEN);
+        });
+    }
+
+    public static <T extends Comparable<T>> IChatBaseComponent a(Collection<T> collection, Function<T, IChatBaseComponent> function) {
+        if (collection.isEmpty()) {
+            return ChatComponentText.d;
+        } else if (collection.size() == 1) {
+            return (IChatBaseComponent) function.apply(collection.iterator().next());
+        } else {
+            List<T> list = Lists.newArrayList(collection);
+
+            list.sort(Comparable::compareTo);
+            return b(list, function);
+        }
+    }
+
+    public static <T> IChatMutableComponent b(Collection<T> collection, Function<T, IChatBaseComponent> function) {
+        if (collection.isEmpty()) {
+            return new ChatComponentText("");
+        } else if (collection.size() == 1) {
+            return ((IChatBaseComponent) function.apply(collection.iterator().next())).mutableCopy();
+        } else {
+            ChatComponentText chatcomponenttext = new ChatComponentText("");
+            boolean flag = true;
+
+            for (Iterator iterator = collection.iterator(); iterator.hasNext(); flag = false) {
+                T t0 = iterator.next();
+
+                if (!flag) {
+                    chatcomponenttext.addSibling((new ChatComponentText(", ")).a(EnumChatFormat.GRAY));
+                }
+
+                chatcomponenttext.addSibling((IChatBaseComponent) function.apply(t0));
+            }
+
+            return chatcomponenttext;
+        }
+    }
+
+    public static IChatMutableComponent a(IChatBaseComponent ichatbasecomponent) {
+        return new ChatMessage("chat.square_brackets", new Object[]{ichatbasecomponent});
+    }
+
+    public static IChatBaseComponent a(Message message) {
+        return (IChatBaseComponent) (message instanceof IChatBaseComponent ? (IChatBaseComponent) message : new ChatComponentText(message.getString()));
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/Packet.java b/src/main/java/net/minecraft/network/protocol/Packet.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd4493a023748264748d4e892815f14d8a7bd7f6
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/Packet.java
@@ -0,0 +1,18 @@
+package net.minecraft.network.protocol;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.PacketListener;
+
+public interface Packet<T extends PacketListener> {
+
+    void a(PacketDataSerializer packetdataserializer) throws IOException;
+
+    void b(PacketDataSerializer packetdataserializer) throws IOException;
+
+    void a(T t0);
+
+    default boolean a() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayInBEdit.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInBEdit.java
new file mode 100644
index 0000000000000000000000000000000000000000..d748e07f8870023e74796910a457d58ee0361ca6
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInBEdit.java
@@ -0,0 +1,45 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.item.ItemStack;
+
+public class PacketPlayInBEdit implements Packet<PacketListenerPlayIn> {
+
+    private ItemStack a;
+    private boolean b;
+    private int c;
+
+    public PacketPlayInBEdit() {}
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.n();
+        this.b = packetdataserializer.readBoolean();
+        this.c = packetdataserializer.i();
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.a);
+        packetdataserializer.writeBoolean(this.b);
+        packetdataserializer.d(this.c);
+    }
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+
+    public ItemStack b() {
+        return this.a;
+    }
+
+    public boolean c() {
+        return this.b;
+    }
+
+    public int d() {
+        return this.c;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayInHeldItemSlot.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInHeldItemSlot.java
new file mode 100644
index 0000000000000000000000000000000000000000..d68f3e6b35f0af846c8a66710c5752508c095179
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInHeldItemSlot.java
@@ -0,0 +1,30 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+
+public class PacketPlayInHeldItemSlot implements Packet<PacketListenerPlayIn> {
+
+    private int itemInHandIndex;
+
+    public PacketPlayInHeldItemSlot() {}
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.itemInHandIndex = packetdataserializer.readShort();
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeShort(this.itemInHandIndex);
+    }
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+
+    public int b() {
+        return this.itemInHandIndex;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayInSettings.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..90842b27f64afcdd8eb7d0e52df8cfcb418b5b5a
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInSettings.java
@@ -0,0 +1,59 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.entity.EnumMainHand;
+import net.minecraft.world.entity.player.EnumChatVisibility;
+
+public class PacketPlayInSettings implements Packet<PacketListenerPlayIn> {
+
+    public String locale;
+    public int viewDistance;
+    private EnumChatVisibility c;
+    private boolean d;
+    private int e;
+    private EnumMainHand f;
+
+    public PacketPlayInSettings() {}
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.locale = packetdataserializer.e(16);
+        this.viewDistance = packetdataserializer.readByte();
+        this.c = (EnumChatVisibility) packetdataserializer.a(EnumChatVisibility.class);
+        this.d = packetdataserializer.readBoolean();
+        this.e = packetdataserializer.readUnsignedByte();
+        this.f = (EnumMainHand) packetdataserializer.a(EnumMainHand.class);
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.locale);
+        packetdataserializer.writeByte(this.viewDistance);
+        packetdataserializer.a((Enum) this.c);
+        packetdataserializer.writeBoolean(this.d);
+        packetdataserializer.writeByte(this.e);
+        packetdataserializer.a((Enum) this.f);
+    }
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+
+    public EnumChatVisibility d() {
+        return this.c;
+    }
+
+    public boolean e() {
+        return this.d;
+    }
+
+    public int f() {
+        return this.e;
+    }
+
+    public EnumMainHand getMainHand() {
+        return this.f;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayInTabComplete.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInTabComplete.java
new file mode 100644
index 0000000000000000000000000000000000000000..e201e4efd4ecc65ec3c38528a4ec5336e2d51ab2
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInTabComplete.java
@@ -0,0 +1,37 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+
+public class PacketPlayInTabComplete implements Packet<PacketListenerPlayIn> {
+
+    private int a;
+    private String b;
+
+    public PacketPlayInTabComplete() {}
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.i();
+        this.b = packetdataserializer.e(32500);
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.d(this.a);
+        packetdataserializer.a(this.b, 32500);
+    }
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+
+    public int b() {
+        return this.a;
+    }
+
+    public String c() {
+        return this.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayInUseEntity.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInUseEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..9f3f8568ef9484ba226deaa6429f819c325b7a26
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInUseEntity.java
@@ -0,0 +1,86 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.World;
+import net.minecraft.world.phys.Vec3D;
+
+public class PacketPlayInUseEntity implements Packet<PacketListenerPlayIn> {
+
+    private int a;
+    private PacketPlayInUseEntity.EnumEntityUseAction action;
+    private Vec3D c;
+    private EnumHand d;
+    private boolean e;
+
+    public PacketPlayInUseEntity() {}
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.i();
+        this.action = (PacketPlayInUseEntity.EnumEntityUseAction) packetdataserializer.a(PacketPlayInUseEntity.EnumEntityUseAction.class);
+        if (this.action == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT_AT) {
+            this.c = new Vec3D((double) packetdataserializer.readFloat(), (double) packetdataserializer.readFloat(), (double) packetdataserializer.readFloat());
+        }
+
+        if (this.action == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT || this.action == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT_AT) {
+            this.d = (EnumHand) packetdataserializer.a(EnumHand.class);
+        }
+
+        this.e = packetdataserializer.readBoolean();
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.d(this.a);
+        packetdataserializer.a((Enum) this.action);
+        if (this.action == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT_AT) {
+            packetdataserializer.writeFloat((float) this.c.x);
+            packetdataserializer.writeFloat((float) this.c.y);
+            packetdataserializer.writeFloat((float) this.c.z);
+        }
+
+        if (this.action == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT || this.action == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT_AT) {
+            packetdataserializer.a((Enum) this.d);
+        }
+
+        packetdataserializer.writeBoolean(this.e);
+    }
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+
+    @Nullable
+    public Entity a(World world) {
+        return world.getEntity(this.a);
+    }
+
+    public PacketPlayInUseEntity.EnumEntityUseAction b() {
+        return this.action;
+    }
+
+    @Nullable
+    public EnumHand c() {
+        return this.d;
+    }
+
+    public Vec3D d() {
+        return this.c;
+    }
+
+    public boolean e() {
+        return this.e;
+    }
+
+    public static enum EnumEntityUseAction {
+
+        INTERACT, ATTACK, INTERACT_AT;
+
+        private EnumEntityUseAction() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutEntity.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..e80429368afced0299d9f41b97251cd6c64b1759
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutEntity.java
@@ -0,0 +1,159 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.phys.Vec3D;
+
+public class PacketPlayOutEntity implements Packet<PacketListenerPlayOut> {
+
+    protected int a;
+    protected short b;
+    protected short c;
+    protected short d;
+    protected byte e;
+    protected byte f;
+    protected boolean g;
+    protected boolean h;
+    protected boolean i;
+
+    public static long a(double d0) {
+        return MathHelper.d(d0 * 4096.0D);
+    }
+
+    public static Vec3D a(long i, long j, long k) {
+        return (new Vec3D((double) i, (double) j, (double) k)).a(2.44140625E-4D);
+    }
+
+    public PacketPlayOutEntity() {}
+
+    public PacketPlayOutEntity(int i) {
+        this.a = i;
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.i();
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.d(this.a);
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+    public String toString() {
+        return "Entity_" + super.toString();
+    }
+
+    public static class PacketPlayOutEntityLook extends PacketPlayOutEntity {
+
+        public PacketPlayOutEntityLook() {
+            this.h = true;
+        }
+
+        public PacketPlayOutEntityLook(int i, byte b0, byte b1, boolean flag) {
+            super(i);
+            this.e = b0;
+            this.f = b1;
+            this.h = true;
+            this.g = flag;
+        }
+
+        @Override
+        public void a(PacketDataSerializer packetdataserializer) throws IOException {
+            super.a(packetdataserializer);
+            this.e = packetdataserializer.readByte();
+            this.f = packetdataserializer.readByte();
+            this.g = packetdataserializer.readBoolean();
+        }
+
+        @Override
+        public void b(PacketDataSerializer packetdataserializer) throws IOException {
+            super.b(packetdataserializer);
+            packetdataserializer.writeByte(this.e);
+            packetdataserializer.writeByte(this.f);
+            packetdataserializer.writeBoolean(this.g);
+        }
+    }
+
+    public static class PacketPlayOutRelEntityMove extends PacketPlayOutEntity {
+
+        public PacketPlayOutRelEntityMove() {
+            this.i = true;
+        }
+
+        public PacketPlayOutRelEntityMove(int i, short short0, short short1, short short2, boolean flag) {
+            super(i);
+            this.b = short0;
+            this.c = short1;
+            this.d = short2;
+            this.g = flag;
+            this.i = true;
+        }
+
+        @Override
+        public void a(PacketDataSerializer packetdataserializer) throws IOException {
+            super.a(packetdataserializer);
+            this.b = packetdataserializer.readShort();
+            this.c = packetdataserializer.readShort();
+            this.d = packetdataserializer.readShort();
+            this.g = packetdataserializer.readBoolean();
+        }
+
+        @Override
+        public void b(PacketDataSerializer packetdataserializer) throws IOException {
+            super.b(packetdataserializer);
+            packetdataserializer.writeShort(this.b);
+            packetdataserializer.writeShort(this.c);
+            packetdataserializer.writeShort(this.d);
+            packetdataserializer.writeBoolean(this.g);
+        }
+    }
+
+    public static class PacketPlayOutRelEntityMoveLook extends PacketPlayOutEntity {
+
+        public PacketPlayOutRelEntityMoveLook() {
+            this.h = true;
+            this.i = true;
+        }
+
+        public PacketPlayOutRelEntityMoveLook(int i, short short0, short short1, short short2, byte b0, byte b1, boolean flag) {
+            super(i);
+            this.b = short0;
+            this.c = short1;
+            this.d = short2;
+            this.e = b0;
+            this.f = b1;
+            this.g = flag;
+            this.h = true;
+            this.i = true;
+        }
+
+        @Override
+        public void a(PacketDataSerializer packetdataserializer) throws IOException {
+            super.a(packetdataserializer);
+            this.b = packetdataserializer.readShort();
+            this.c = packetdataserializer.readShort();
+            this.d = packetdataserializer.readShort();
+            this.e = packetdataserializer.readByte();
+            this.f = packetdataserializer.readByte();
+            this.g = packetdataserializer.readBoolean();
+        }
+
+        @Override
+        public void b(PacketDataSerializer packetdataserializer) throws IOException {
+            super.b(packetdataserializer);
+            packetdataserializer.writeShort(this.b);
+            packetdataserializer.writeShort(this.c);
+            packetdataserializer.writeShort(this.d);
+            packetdataserializer.writeByte(this.e);
+            packetdataserializer.writeByte(this.f);
+            packetdataserializer.writeBoolean(this.g);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutLightUpdate.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutLightUpdate.java
new file mode 100644
index 0000000000000000000000000000000000000000..247d969e7d1aa59d9650fce1032aaa09db3903e5
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutLightUpdate.java
@@ -0,0 +1,159 @@
+package net.minecraft.network.protocol.game;
+
+import com.google.common.collect.Lists;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.chunk.NibbleArray;
+import net.minecraft.world.level.lighting.LightEngine;
+
+public class PacketPlayOutLightUpdate implements Packet<PacketListenerPlayOut> {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private int e;
+    private int f;
+    private List<byte[]> g;
+    private List<byte[]> h;
+    private boolean i;
+
+    public PacketPlayOutLightUpdate() {}
+
+    public PacketPlayOutLightUpdate(ChunkCoordIntPair chunkcoordintpair, LightEngine lightengine, boolean flag) {
+        this.a = chunkcoordintpair.x;
+        this.b = chunkcoordintpair.z;
+        this.i = flag;
+        this.g = Lists.newArrayList();
+        this.h = Lists.newArrayList();
+
+        for (int i = 0; i < 18; ++i) {
+            NibbleArray nibblearray = lightengine.a(EnumSkyBlock.SKY).a(SectionPosition.a(chunkcoordintpair, -1 + i));
+            NibbleArray nibblearray1 = lightengine.a(EnumSkyBlock.BLOCK).a(SectionPosition.a(chunkcoordintpair, -1 + i));
+
+            if (nibblearray != null) {
+                if (nibblearray.c()) {
+                    this.e |= 1 << i;
+                } else {
+                    this.c |= 1 << i;
+                    this.g.add(nibblearray.asBytes().clone());
+                }
+            }
+
+            if (nibblearray1 != null) {
+                if (nibblearray1.c()) {
+                    this.f |= 1 << i;
+                } else {
+                    this.d |= 1 << i;
+                    this.h.add(nibblearray1.asBytes().clone());
+                }
+            }
+        }
+
+    }
+
+    public PacketPlayOutLightUpdate(ChunkCoordIntPair chunkcoordintpair, LightEngine lightengine, int i, int j, boolean flag) {
+        this.a = chunkcoordintpair.x;
+        this.b = chunkcoordintpair.z;
+        this.i = flag;
+        this.c = i;
+        this.d = j;
+        this.g = Lists.newArrayList();
+        this.h = Lists.newArrayList();
+
+        for (int k = 0; k < 18; ++k) {
+            NibbleArray nibblearray;
+
+            if ((this.c & 1 << k) != 0) {
+                nibblearray = lightengine.a(EnumSkyBlock.SKY).a(SectionPosition.a(chunkcoordintpair, -1 + k));
+                if (nibblearray != null && !nibblearray.c()) {
+                    this.g.add(nibblearray.asBytes().clone());
+                } else {
+                    this.c &= ~(1 << k);
+                    if (nibblearray != null) {
+                        this.e |= 1 << k;
+                    }
+                }
+            }
+
+            if ((this.d & 1 << k) != 0) {
+                nibblearray = lightengine.a(EnumSkyBlock.BLOCK).a(SectionPosition.a(chunkcoordintpair, -1 + k));
+                if (nibblearray != null && !nibblearray.c()) {
+                    this.h.add(nibblearray.asBytes().clone());
+                } else {
+                    this.d &= ~(1 << k);
+                    if (nibblearray != null) {
+                        this.f |= 1 << k;
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.i();
+        this.b = packetdataserializer.i();
+        this.i = packetdataserializer.readBoolean();
+        this.c = packetdataserializer.i();
+        this.d = packetdataserializer.i();
+        this.e = packetdataserializer.i();
+        this.f = packetdataserializer.i();
+        this.g = Lists.newArrayList();
+
+        int i;
+
+        for (i = 0; i < 18; ++i) {
+            if ((this.c & 1 << i) != 0) {
+                this.g.add(packetdataserializer.b(2048));
+            }
+        }
+
+        this.h = Lists.newArrayList();
+
+        for (i = 0; i < 18; ++i) {
+            if ((this.d & 1 << i) != 0) {
+                this.h.add(packetdataserializer.b(2048));
+            }
+        }
+
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.d(this.a);
+        packetdataserializer.d(this.b);
+        packetdataserializer.writeBoolean(this.i);
+        packetdataserializer.d(this.c);
+        packetdataserializer.d(this.d);
+        packetdataserializer.d(this.e);
+        packetdataserializer.d(this.f);
+        Iterator iterator = this.g.iterator();
+
+        byte[] abyte;
+
+        while (iterator.hasNext()) {
+            abyte = (byte[]) iterator.next();
+            packetdataserializer.a(abyte);
+        }
+
+        iterator = this.h.iterator();
+
+        while (iterator.hasNext()) {
+            abyte = (byte[]) iterator.next();
+            packetdataserializer.a(abyte);
+        }
+
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..820ba7c59e7bc7b6f3311f1a4ec3d724e265a2af
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java
@@ -0,0 +1,179 @@
+package net.minecraft.network.protocol.game;
+
+import com.google.common.collect.Lists;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map.Entry;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagLongArray;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.chunk.BiomeStorage;
+import net.minecraft.world.level.chunk.Chunk;
+import net.minecraft.world.level.chunk.ChunkSection;
+import net.minecraft.world.level.levelgen.HeightMap;
+
+public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
+
+    private int a;
+    private int b;
+    private int c;
+    private NBTTagCompound d;
+    @Nullable
+    private int[] e;
+    private byte[] f;
+    private List<NBTTagCompound> g;
+    private boolean h;
+
+    public PacketPlayOutMapChunk() {}
+
+    public PacketPlayOutMapChunk(Chunk chunk, int i) {
+        ChunkCoordIntPair chunkcoordintpair = chunk.getPos();
+
+        this.a = chunkcoordintpair.x;
+        this.b = chunkcoordintpair.z;
+        this.h = i == 65535;
+        this.d = new NBTTagCompound();
+        Iterator iterator = chunk.f().iterator();
+
+        Entry entry;
+
+        while (iterator.hasNext()) {
+            entry = (Entry) iterator.next();
+            if (((HeightMap.Type) entry.getKey()).c()) {
+                this.d.set(((HeightMap.Type) entry.getKey()).b(), new NBTTagLongArray(((HeightMap) entry.getValue()).a()));
+            }
+        }
+
+        if (this.h) {
+            this.e = chunk.getBiomeIndex().a();
+        }
+
+        this.f = new byte[this.a(chunk, i)];
+        this.c = this.a(new PacketDataSerializer(this.j()), chunk, i);
+        this.g = Lists.newArrayList();
+        iterator = chunk.getTileEntities().entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            entry = (Entry) iterator.next();
+            BlockPosition blockposition = (BlockPosition) entry.getKey();
+            TileEntity tileentity = (TileEntity) entry.getValue();
+            int j = blockposition.getY() >> 4;
+
+            if (this.f() || (i & 1 << j) != 0) {
+                NBTTagCompound nbttagcompound = tileentity.b();
+
+                this.g.add(nbttagcompound);
+            }
+        }
+
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.h = packetdataserializer.readBoolean();
+        this.c = packetdataserializer.i();
+        this.d = packetdataserializer.l();
+        if (this.h) {
+            this.e = packetdataserializer.c(BiomeStorage.a);
+        }
+
+        int i = packetdataserializer.i();
+
+        if (i > 2097152) {
+            throw new RuntimeException("Chunk Packet trying to allocate too much memory on read.");
+        } else {
+            this.f = new byte[i];
+            packetdataserializer.readBytes(this.f);
+            int j = packetdataserializer.i();
+
+            this.g = Lists.newArrayList();
+
+            for (int k = 0; k < j; ++k) {
+                this.g.add(packetdataserializer.l());
+            }
+
+        }
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeInt(this.b);
+        packetdataserializer.writeBoolean(this.h);
+        packetdataserializer.d(this.c);
+        packetdataserializer.a(this.d);
+        if (this.e != null) {
+            packetdataserializer.a(this.e);
+        }
+
+        packetdataserializer.d(this.f.length);
+        packetdataserializer.writeBytes(this.f);
+        packetdataserializer.d(this.g.size());
+        Iterator iterator = this.g.iterator();
+
+        while (iterator.hasNext()) {
+            NBTTagCompound nbttagcompound = (NBTTagCompound) iterator.next();
+
+            packetdataserializer.a(nbttagcompound);
+        }
+
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+    private ByteBuf j() {
+        ByteBuf bytebuf = Unpooled.wrappedBuffer(this.f);
+
+        bytebuf.writerIndex(0);
+        return bytebuf;
+    }
+
+    public int a(PacketDataSerializer packetdataserializer, Chunk chunk, int i) {
+        int j = 0;
+        ChunkSection[] achunksection = chunk.getSections();
+        int k = 0;
+
+        for (int l = achunksection.length; k < l; ++k) {
+            ChunkSection chunksection = achunksection[k];
+
+            if (chunksection != Chunk.a && (!this.f() || !chunksection.c()) && (i & 1 << k) != 0) {
+                j |= 1 << k;
+                chunksection.b(packetdataserializer);
+            }
+        }
+
+        return j;
+    }
+
+    protected int a(Chunk chunk, int i) {
+        int j = 0;
+        ChunkSection[] achunksection = chunk.getSections();
+        int k = 0;
+
+        for (int l = achunksection.length; k < l; ++k) {
+            ChunkSection chunksection = achunksection[k];
+
+            if (chunksection != Chunk.a && (!this.f() || !chunksection.c()) && (i & 1 << k) != 0) {
+                j += chunksection.j();
+            }
+        }
+
+        return j;
+    }
+
+    public boolean f() {
+        return this.h;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMount.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMount.java
new file mode 100644
index 0000000000000000000000000000000000000000..edc6fff87c4abad2c123b1a46d6e5b792602b3be
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMount.java
@@ -0,0 +1,43 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import java.util.List;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.entity.Entity;
+
+public class PacketPlayOutMount implements Packet<PacketListenerPlayOut> {
+
+    private int a;
+    private int[] b;
+
+    public PacketPlayOutMount() {}
+
+    public PacketPlayOutMount(Entity entity) {
+        this.a = entity.getId();
+        List<Entity> list = entity.getPassengers();
+
+        this.b = new int[list.size()];
+
+        for (int i = 0; i < list.size(); ++i) {
+            this.b[i] = ((Entity) list.get(i)).getId();
+        }
+
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.i();
+        this.b = packetdataserializer.b();
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.d(this.a);
+        packetdataserializer.a(this.b);
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutPlayerListHeaderFooter.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutPlayerListHeaderFooter.java
new file mode 100644
index 0000000000000000000000000000000000000000..0268b8e6595ee919bcd55a74ba872a2b7d2a17d8
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutPlayerListHeaderFooter.java
@@ -0,0 +1,30 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.network.protocol.Packet;
+
+public class PacketPlayOutPlayerListHeaderFooter implements Packet<PacketListenerPlayOut> {
+
+    public IChatBaseComponent header;
+    public IChatBaseComponent footer;
+
+    public PacketPlayOutPlayerListHeaderFooter() {}
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.header = packetdataserializer.h();
+        this.footer = packetdataserializer.h();
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.header);
+        packetdataserializer.a(this.footer);
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutScoreboardTeam.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutScoreboardTeam.java
new file mode 100644
index 0000000000000000000000000000000000000000..bc40f2cbe1645fd60c4cee106b90f17cd043d32d
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutScoreboardTeam.java
@@ -0,0 +1,137 @@
+package net.minecraft.network.protocol.game;
+
+import com.google.common.collect.Lists;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Iterator;
+import net.minecraft.EnumChatFormat;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.chat.ChatComponentText;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.scores.ScoreboardTeam;
+import net.minecraft.world.scores.ScoreboardTeamBase;
+
+public class PacketPlayOutScoreboardTeam implements Packet<PacketListenerPlayOut> {
+
+    private String a = "";
+    private IChatBaseComponent b;
+    private IChatBaseComponent c;
+    private IChatBaseComponent d;
+    private String e;
+    private String f;
+    private EnumChatFormat g;
+    private final Collection<String> h;
+    private int i;
+    private int j;
+
+    public PacketPlayOutScoreboardTeam() {
+        this.b = ChatComponentText.d;
+        this.c = ChatComponentText.d;
+        this.d = ChatComponentText.d;
+        this.e = ScoreboardTeamBase.EnumNameTagVisibility.ALWAYS.e;
+        this.f = ScoreboardTeamBase.EnumTeamPush.ALWAYS.e;
+        this.g = EnumChatFormat.RESET;
+        this.h = Lists.newArrayList();
+    }
+
+    public PacketPlayOutScoreboardTeam(ScoreboardTeam scoreboardteam, int i) {
+        this.b = ChatComponentText.d;
+        this.c = ChatComponentText.d;
+        this.d = ChatComponentText.d;
+        this.e = ScoreboardTeamBase.EnumNameTagVisibility.ALWAYS.e;
+        this.f = ScoreboardTeamBase.EnumTeamPush.ALWAYS.e;
+        this.g = EnumChatFormat.RESET;
+        this.h = Lists.newArrayList();
+        this.a = scoreboardteam.getName();
+        this.i = i;
+        if (i == 0 || i == 2) {
+            this.b = scoreboardteam.getDisplayName();
+            this.j = scoreboardteam.packOptionData();
+            this.e = scoreboardteam.getNameTagVisibility().e;
+            this.f = scoreboardteam.getCollisionRule().e;
+            this.g = scoreboardteam.getColor();
+            this.c = scoreboardteam.getPrefix();
+            this.d = scoreboardteam.getSuffix();
+        }
+
+        if (i == 0) {
+            this.h.addAll(scoreboardteam.getPlayerNameSet());
+        }
+
+    }
+
+    public PacketPlayOutScoreboardTeam(ScoreboardTeam scoreboardteam, Collection<String> collection, int i) {
+        this.b = ChatComponentText.d;
+        this.c = ChatComponentText.d;
+        this.d = ChatComponentText.d;
+        this.e = ScoreboardTeamBase.EnumNameTagVisibility.ALWAYS.e;
+        this.f = ScoreboardTeamBase.EnumTeamPush.ALWAYS.e;
+        this.g = EnumChatFormat.RESET;
+        this.h = Lists.newArrayList();
+        if (i != 3 && i != 4) {
+            throw new IllegalArgumentException("Method must be join or leave for player constructor");
+        } else if (collection != null && !collection.isEmpty()) {
+            this.i = i;
+            this.a = scoreboardteam.getName();
+            this.h.addAll(collection);
+        } else {
+            throw new IllegalArgumentException("Players cannot be null/empty");
+        }
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.e(16);
+        this.i = packetdataserializer.readByte();
+        if (this.i == 0 || this.i == 2) {
+            this.b = packetdataserializer.h();
+            this.j = packetdataserializer.readByte();
+            this.e = packetdataserializer.e(40);
+            this.f = packetdataserializer.e(40);
+            this.g = (EnumChatFormat) packetdataserializer.a(EnumChatFormat.class);
+            this.c = packetdataserializer.h();
+            this.d = packetdataserializer.h();
+        }
+
+        if (this.i == 0 || this.i == 3 || this.i == 4) {
+            int i = packetdataserializer.i();
+
+            for (int j = 0; j < i; ++j) {
+                this.h.add(packetdataserializer.e(40));
+            }
+        }
+
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.a);
+        packetdataserializer.writeByte(this.i);
+        if (this.i == 0 || this.i == 2) {
+            packetdataserializer.a(this.b);
+            packetdataserializer.writeByte(this.j);
+            packetdataserializer.a(this.e);
+            packetdataserializer.a(this.f);
+            packetdataserializer.a((Enum) this.g);
+            packetdataserializer.a(this.c);
+            packetdataserializer.a(this.d);
+        }
+
+        if (this.i == 0 || this.i == 3 || this.i == 4) {
+            packetdataserializer.d(this.h.size());
+            Iterator iterator = this.h.iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+
+                packetdataserializer.a(s);
+            }
+        }
+
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTitle.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTitle.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c44a3d9273afaf4d35f4ff86727386b34d9eb06
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTitle.java
@@ -0,0 +1,75 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.network.protocol.Packet;
+
+public class PacketPlayOutTitle implements Packet<PacketListenerPlayOut> {
+
+    private PacketPlayOutTitle.EnumTitleAction a;
+    private IChatBaseComponent b;
+    private int c;
+    private int d;
+    private int e;
+
+    public PacketPlayOutTitle() {}
+
+    public PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction packetplayouttitle_enumtitleaction, IChatBaseComponent ichatbasecomponent) {
+        this(packetplayouttitle_enumtitleaction, ichatbasecomponent, -1, -1, -1);
+    }
+
+    public PacketPlayOutTitle(int i, int j, int k) {
+        this(PacketPlayOutTitle.EnumTitleAction.TIMES, (IChatBaseComponent) null, i, j, k);
+    }
+
+    public PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction packetplayouttitle_enumtitleaction, @Nullable IChatBaseComponent ichatbasecomponent, int i, int j, int k) {
+        this.a = packetplayouttitle_enumtitleaction;
+        this.b = ichatbasecomponent;
+        this.c = i;
+        this.d = j;
+        this.e = k;
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = (PacketPlayOutTitle.EnumTitleAction) packetdataserializer.a(PacketPlayOutTitle.EnumTitleAction.class);
+        if (this.a == PacketPlayOutTitle.EnumTitleAction.TITLE || this.a == PacketPlayOutTitle.EnumTitleAction.SUBTITLE || this.a == PacketPlayOutTitle.EnumTitleAction.ACTIONBAR) {
+            this.b = packetdataserializer.h();
+        }
+
+        if (this.a == PacketPlayOutTitle.EnumTitleAction.TIMES) {
+            this.c = packetdataserializer.readInt();
+            this.d = packetdataserializer.readInt();
+            this.e = packetdataserializer.readInt();
+        }
+
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a((Enum) this.a);
+        if (this.a == PacketPlayOutTitle.EnumTitleAction.TITLE || this.a == PacketPlayOutTitle.EnumTitleAction.SUBTITLE || this.a == PacketPlayOutTitle.EnumTitleAction.ACTIONBAR) {
+            packetdataserializer.a(this.b);
+        }
+
+        if (this.a == PacketPlayOutTitle.EnumTitleAction.TIMES) {
+            packetdataserializer.writeInt(this.c);
+            packetdataserializer.writeInt(this.d);
+            packetdataserializer.writeInt(this.e);
+        }
+
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+    public static enum EnumTitleAction {
+
+        TITLE, SUBTITLE, ACTIONBAR, TIMES, CLEAR, RESET;
+
+        private EnumTitleAction() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutUpdateTime.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutUpdateTime.java
new file mode 100644
index 0000000000000000000000000000000000000000..a69e60a8934493f6786ce3d425f6dccb6e4befdd
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutUpdateTime.java
@@ -0,0 +1,41 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+
+public class PacketPlayOutUpdateTime implements Packet<PacketListenerPlayOut> {
+
+    private long a;
+    private long b;
+
+    public PacketPlayOutUpdateTime() {}
+
+    public PacketPlayOutUpdateTime(long i, long j, boolean flag) {
+        this.a = i;
+        this.b = j;
+        if (!flag) {
+            this.b = -this.b;
+            if (this.b == 0L) {
+                this.b = -1L;
+            }
+        }
+
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readLong();
+        this.b = packetdataserializer.readLong();
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeLong(this.a);
+        packetdataserializer.writeLong(this.b);
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutWindowItems.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutWindowItems.java
new file mode 100644
index 0000000000000000000000000000000000000000..b90e35a0099a2482f8fc2998bd079fc2fe6439e6
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutWindowItems.java
@@ -0,0 +1,58 @@
+package net.minecraft.network.protocol.game;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import net.minecraft.core.NonNullList;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.item.ItemStack;
+
+public class PacketPlayOutWindowItems implements Packet<PacketListenerPlayOut> {
+
+    private int a;
+    private List<ItemStack> b;
+
+    public PacketPlayOutWindowItems() {}
+
+    public PacketPlayOutWindowItems(int i, NonNullList<ItemStack> nonnulllist) {
+        this.a = i;
+        this.b = NonNullList.a(nonnulllist.size(), ItemStack.b);
+
+        for (int j = 0; j < this.b.size(); ++j) {
+            this.b.set(j, ((ItemStack) nonnulllist.get(j)).cloneItemStack());
+        }
+
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readUnsignedByte();
+        short short0 = packetdataserializer.readShort();
+
+        this.b = NonNullList.a(short0, ItemStack.b);
+
+        for (int i = 0; i < short0; ++i) {
+            this.b.set(i, packetdataserializer.n());
+        }
+
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeByte(this.a);
+        packetdataserializer.writeShort(this.b.size());
+        Iterator iterator = this.b.iterator();
+
+        while (iterator.hasNext()) {
+            ItemStack itemstack = (ItemStack) iterator.next();
+
+            packetdataserializer.a(itemstack);
+        }
+
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/login/PacketLoginInCustomPayload.java b/src/main/java/net/minecraft/network/protocol/login/PacketLoginInCustomPayload.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1bac2d07e5107c1346f246f5d5d929c73912bfd
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/login/PacketLoginInCustomPayload.java
@@ -0,0 +1,46 @@
+package net.minecraft.network.protocol.login;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+
+public class PacketLoginInCustomPayload implements Packet<PacketLoginInListener> {
+
+    private int a;
+    private PacketDataSerializer b;
+
+    public PacketLoginInCustomPayload() {}
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.i();
+        if (packetdataserializer.readBoolean()) {
+            int i = packetdataserializer.readableBytes();
+
+            if (i < 0 || i > 1048576) {
+                throw new IOException("Payload may not be larger than 1048576 bytes");
+            }
+
+            this.b = new PacketDataSerializer(packetdataserializer.readBytes(i));
+        } else {
+            this.b = null;
+        }
+
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.d(this.a);
+        if (this.b != null) {
+            packetdataserializer.writeBoolean(true);
+            packetdataserializer.writeBytes(this.b.copy());
+        } else {
+            packetdataserializer.writeBoolean(false);
+        }
+
+    }
+
+    public void a(PacketLoginInListener packetlogininlistener) {
+        packetlogininlistener.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/login/PacketLoginOutCustomPayload.java b/src/main/java/net/minecraft/network/protocol/login/PacketLoginOutCustomPayload.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb970c1e954cb0aa83aa12e83c471778809e69b2
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/login/PacketLoginOutCustomPayload.java
@@ -0,0 +1,39 @@
+package net.minecraft.network.protocol.login;
+
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.resources.MinecraftKey;
+
+public class PacketLoginOutCustomPayload implements Packet<PacketLoginOutListener> {
+
+    private int a;
+    private MinecraftKey b;
+    private PacketDataSerializer c;
+
+    public PacketLoginOutCustomPayload() {}
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.i();
+        this.b = packetdataserializer.p();
+        int i = packetdataserializer.readableBytes();
+
+        if (i >= 0 && i <= 1048576) {
+            this.c = new PacketDataSerializer(packetdataserializer.readBytes(i));
+        } else {
+            throw new IOException("Payload may not be larger than 1048576 bytes");
+        }
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.d(this.a);
+        packetdataserializer.a(this.b);
+        packetdataserializer.writeBytes(this.c.copy());
+    }
+
+    public void a(PacketLoginOutListener packetloginoutlistener) {
+        packetloginoutlistener.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/status/PacketStatusOutServerInfo.java b/src/main/java/net/minecraft/network/protocol/status/PacketStatusOutServerInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..0ebeacaaeb265d202f52c758566a5160c42e8a55
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/status/PacketStatusOutServerInfo.java
@@ -0,0 +1,37 @@
+package net.minecraft.network.protocol.status;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import java.io.IOException;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.chat.ChatModifier;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.util.ChatDeserializer;
+import net.minecraft.util.ChatTypeAdapterFactory;
+
+public class PacketStatusOutServerInfo implements Packet<PacketStatusOutListener> {
+
+    private static final Gson a = (new GsonBuilder()).registerTypeAdapter(ServerPing.ServerData.class, new ServerPing.ServerData.Serializer()).registerTypeAdapter(ServerPing.ServerPingPlayerSample.class, new ServerPing.ServerPingPlayerSample.Serializer()).registerTypeAdapter(ServerPing.class, new ServerPing.Serializer()).registerTypeHierarchyAdapter(IChatBaseComponent.class, new IChatBaseComponent.ChatSerializer()).registerTypeHierarchyAdapter(ChatModifier.class, new ChatModifier.ChatModifierSerializer()).registerTypeAdapterFactory(new ChatTypeAdapterFactory()).create();
+    private ServerPing b;
+
+    public PacketStatusOutServerInfo() {}
+
+    public PacketStatusOutServerInfo(ServerPing serverping) {
+        this.b = serverping;
+    }
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.b = (ServerPing) ChatDeserializer.a(PacketStatusOutServerInfo.a, packetdataserializer.e(32767), ServerPing.class);
+    }
+
+    @Override
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(PacketStatusOutServerInfo.a.toJson(this.b));
+    }
+
+    public void a(PacketStatusOutListener packetstatusoutlistener) {
+        packetstatusoutlistener.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/status/ServerPing.java b/src/main/java/net/minecraft/network/protocol/status/ServerPing.java
new file mode 100644
index 0000000000000000000000000000000000000000..005ae7a75dfb19152abb606da29acad07c85e499
--- /dev/null
+++ b/src/main/java/net/minecraft/network/protocol/status/ServerPing.java
@@ -0,0 +1,225 @@
+package net.minecraft.network.protocol.status;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.mojang.authlib.GameProfile;
+import java.lang.reflect.Type;
+import java.util.UUID;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.util.ChatDeserializer;
+
+public class ServerPing {
+
+    private IChatBaseComponent a;
+    private ServerPing.ServerPingPlayerSample b;
+    private ServerPing.ServerData c;
+    private String d;
+
+    public ServerPing() {}
+
+    public IChatBaseComponent a() {
+        return this.a;
+    }
+
+    public void setMOTD(IChatBaseComponent ichatbasecomponent) {
+        this.a = ichatbasecomponent;
+    }
+
+    public ServerPing.ServerPingPlayerSample b() {
+        return this.b;
+    }
+
+    public void setPlayerSample(ServerPing.ServerPingPlayerSample serverping_serverpingplayersample) {
+        this.b = serverping_serverpingplayersample;
+    }
+
+    public ServerPing.ServerData getServerData() {
+        return this.c;
+    }
+
+    public void setServerInfo(ServerPing.ServerData serverping_serverdata) {
+        this.c = serverping_serverdata;
+    }
+
+    public void setFavicon(String s) {
+        this.d = s;
+    }
+
+    public String d() {
+        return this.d;
+    }
+
+    public static class Serializer implements JsonDeserializer<ServerPing>, JsonSerializer<ServerPing> {
+
+        public Serializer() {}
+
+        public ServerPing deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) throws JsonParseException {
+            JsonObject jsonobject = ChatDeserializer.m(jsonelement, "status");
+            ServerPing serverping = new ServerPing();
+
+            if (jsonobject.has("description")) {
+                serverping.setMOTD((IChatBaseComponent) jsondeserializationcontext.deserialize(jsonobject.get("description"), IChatBaseComponent.class));
+            }
+
+            if (jsonobject.has("players")) {
+                serverping.setPlayerSample((ServerPing.ServerPingPlayerSample) jsondeserializationcontext.deserialize(jsonobject.get("players"), ServerPing.ServerPingPlayerSample.class));
+            }
+
+            if (jsonobject.has("version")) {
+                serverping.setServerInfo((ServerPing.ServerData) jsondeserializationcontext.deserialize(jsonobject.get("version"), ServerPing.ServerData.class));
+            }
+
+            if (jsonobject.has("favicon")) {
+                serverping.setFavicon(ChatDeserializer.h(jsonobject, "favicon"));
+            }
+
+            return serverping;
+        }
+
+        public JsonElement serialize(ServerPing serverping, Type type, JsonSerializationContext jsonserializationcontext) {
+            JsonObject jsonobject = new JsonObject();
+
+            if (serverping.a() != null) {
+                jsonobject.add("description", jsonserializationcontext.serialize(serverping.a()));
+            }
+
+            if (serverping.b() != null) {
+                jsonobject.add("players", jsonserializationcontext.serialize(serverping.b()));
+            }
+
+            if (serverping.getServerData() != null) {
+                jsonobject.add("version", jsonserializationcontext.serialize(serverping.getServerData()));
+            }
+
+            if (serverping.d() != null) {
+                jsonobject.addProperty("favicon", serverping.d());
+            }
+
+            return jsonobject;
+        }
+    }
+
+    public static class ServerData {
+
+        private final String a;
+        private final int b;
+
+        public ServerData(String s, int i) {
+            this.a = s;
+            this.b = i;
+        }
+
+        public String a() {
+            return this.a;
+        }
+
+        public int getProtocolVersion() {
+            return this.b;
+        }
+
+        public static class Serializer implements JsonDeserializer<ServerPing.ServerData>, JsonSerializer<ServerPing.ServerData> {
+
+            public Serializer() {}
+
+            public ServerPing.ServerData deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) throws JsonParseException {
+                JsonObject jsonobject = ChatDeserializer.m(jsonelement, "version");
+
+                return new ServerPing.ServerData(ChatDeserializer.h(jsonobject, "name"), ChatDeserializer.n(jsonobject, "protocol"));
+            }
+
+            public JsonElement serialize(ServerPing.ServerData serverping_serverdata, Type type, JsonSerializationContext jsonserializationcontext) {
+                JsonObject jsonobject = new JsonObject();
+
+                jsonobject.addProperty("name", serverping_serverdata.a());
+                jsonobject.addProperty("protocol", serverping_serverdata.getProtocolVersion());
+                return jsonobject;
+            }
+        }
+    }
+
+    public static class ServerPingPlayerSample {
+
+        private final int a;
+        private final int b;
+        private GameProfile[] c;
+
+        public ServerPingPlayerSample(int i, int j) {
+            this.a = i;
+            this.b = j;
+        }
+
+        public int a() {
+            return this.a;
+        }
+
+        public int b() {
+            return this.b;
+        }
+
+        public GameProfile[] c() {
+            return this.c;
+        }
+
+        public void a(GameProfile[] agameprofile) {
+            this.c = agameprofile;
+        }
+
+        public static class Serializer implements JsonDeserializer<ServerPing.ServerPingPlayerSample>, JsonSerializer<ServerPing.ServerPingPlayerSample> {
+
+            public Serializer() {}
+
+            public ServerPing.ServerPingPlayerSample deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) throws JsonParseException {
+                JsonObject jsonobject = ChatDeserializer.m(jsonelement, "players");
+                ServerPing.ServerPingPlayerSample serverping_serverpingplayersample = new ServerPing.ServerPingPlayerSample(ChatDeserializer.n(jsonobject, "max"), ChatDeserializer.n(jsonobject, "online"));
+
+                if (ChatDeserializer.d(jsonobject, "sample")) {
+                    JsonArray jsonarray = ChatDeserializer.u(jsonobject, "sample");
+
+                    if (jsonarray.size() > 0) {
+                        GameProfile[] agameprofile = new GameProfile[jsonarray.size()];
+
+                        for (int i = 0; i < agameprofile.length; ++i) {
+                            JsonObject jsonobject1 = ChatDeserializer.m(jsonarray.get(i), "player[" + i + "]");
+                            String s = ChatDeserializer.h(jsonobject1, "id");
+
+                            agameprofile[i] = new GameProfile(UUID.fromString(s), ChatDeserializer.h(jsonobject1, "name"));
+                        }
+
+                        serverping_serverpingplayersample.a(agameprofile);
+                    }
+                }
+
+                return serverping_serverpingplayersample;
+            }
+
+            public JsonElement serialize(ServerPing.ServerPingPlayerSample serverping_serverpingplayersample, Type type, JsonSerializationContext jsonserializationcontext) {
+                JsonObject jsonobject = new JsonObject();
+
+                jsonobject.addProperty("max", serverping_serverpingplayersample.a());
+                jsonobject.addProperty("online", serverping_serverpingplayersample.b());
+                if (serverping_serverpingplayersample.c() != null && serverping_serverpingplayersample.c().length > 0) {
+                    JsonArray jsonarray = new JsonArray();
+
+                    for (int i = 0; i < serverping_serverpingplayersample.c().length; ++i) {
+                        JsonObject jsonobject1 = new JsonObject();
+                        UUID uuid = serverping_serverpingplayersample.c()[i].getId();
+
+                        jsonobject1.addProperty("id", uuid == null ? "" : uuid.toString());
+                        jsonobject1.addProperty("name", serverping_serverpingplayersample.c()[i].getName());
+                        jsonarray.add(jsonobject1);
+                    }
+
+                    jsonobject.add("sample", jsonarray);
+                }
+
+                return jsonobject;
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/recipebook/AutoRecipe.java b/src/main/java/net/minecraft/recipebook/AutoRecipe.java
new file mode 100644
index 0000000000000000000000000000000000000000..897f7270bae601b39d74d6a56a60f0ac7f1f6090
--- /dev/null
+++ b/src/main/java/net/minecraft/recipebook/AutoRecipe.java
@@ -0,0 +1,245 @@
+package net.minecraft.recipebook;
+
+import com.google.common.collect.Lists;
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+import it.unimi.dsi.fastutil.ints.IntList;
+import it.unimi.dsi.fastutil.ints.IntListIterator;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.network.protocol.game.PacketPlayOutAutoRecipe;
+import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.world.IInventory;
+import net.minecraft.world.entity.player.AutoRecipeStackManager;
+import net.minecraft.world.entity.player.PlayerInventory;
+import net.minecraft.world.inventory.ContainerPlayer;
+import net.minecraft.world.inventory.ContainerRecipeBook;
+import net.minecraft.world.inventory.ContainerWorkbench;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.crafting.IRecipe;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class AutoRecipe<C extends IInventory> implements AutoRecipeAbstract<Integer> {
+
+    protected static final Logger LOGGER = LogManager.getLogger();
+    protected final AutoRecipeStackManager b = new AutoRecipeStackManager();
+    protected PlayerInventory c;
+    protected ContainerRecipeBook<C> d;
+
+    public AutoRecipe(ContainerRecipeBook<C> containerrecipebook) {
+        this.d = containerrecipebook;
+    }
+
+    public void a(EntityPlayer entityplayer, @Nullable IRecipe<C> irecipe, boolean flag) {
+        if (irecipe != null && entityplayer.getRecipeBook().b(irecipe)) {
+            this.c = entityplayer.inventory;
+            if (this.b() || entityplayer.isCreative()) {
+                this.b.a();
+                entityplayer.inventory.a(this.b);
+                this.d.a(this.b);
+                if (this.b.a(irecipe, (IntList) null)) {
+                    this.a(irecipe, flag);
+                } else {
+                    this.a();
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutAutoRecipe(entityplayer.activeContainer.windowId, irecipe));
+                }
+
+                entityplayer.inventory.update();
+            }
+        }
+    }
+
+    protected void a() {
+        for (int i = 0; i < this.d.g() * this.d.h() + 1; ++i) {
+            if (i != this.d.f() || !(this.d instanceof ContainerWorkbench) && !(this.d instanceof ContainerPlayer)) {
+                this.a(i);
+            }
+        }
+
+        this.d.e();
+    }
+
+    protected void a(int i) {
+        ItemStack itemstack = this.d.getSlot(i).getItem();
+
+        if (!itemstack.isEmpty()) {
+            for (; itemstack.getCount() > 0; this.d.getSlot(i).a(1)) {
+                int j = this.c.firstPartial(itemstack);
+
+                if (j == -1) {
+                    j = this.c.getFirstEmptySlotIndex();
+                }
+
+                ItemStack itemstack1 = itemstack.cloneItemStack();
+
+                itemstack1.setCount(1);
+                if (!this.c.c(j, itemstack1)) {
+                    AutoRecipe.LOGGER.error("Can't find any space for item in the inventory");
+                }
+            }
+
+        }
+    }
+
+    protected void a(IRecipe<C> irecipe, boolean flag) {
+        boolean flag1 = this.d.a(irecipe);
+        int i = this.b.b(irecipe, (IntList) null);
+        int j;
+
+        if (flag1) {
+            for (j = 0; j < this.d.h() * this.d.g() + 1; ++j) {
+                if (j != this.d.f()) {
+                    ItemStack itemstack = this.d.getSlot(j).getItem();
+
+                    if (!itemstack.isEmpty() && Math.min(i, itemstack.getMaxStackSize()) < itemstack.getCount() + 1) {
+                        return;
+                    }
+                }
+            }
+        }
+
+        j = this.a(flag, i, flag1);
+        IntArrayList intarraylist = new IntArrayList();
+
+        if (this.b.a(irecipe, intarraylist, j)) {
+            int k = j;
+            IntListIterator intlistiterator = intarraylist.iterator();
+
+            while (intlistiterator.hasNext()) {
+                int l = (Integer) intlistiterator.next();
+                int i1 = AutoRecipeStackManager.a(l).getMaxStackSize();
+
+                if (i1 < k) {
+                    k = i1;
+                }
+            }
+
+            if (this.b.a(irecipe, intarraylist, k)) {
+                this.a();
+                this.a(this.d.g(), this.d.h(), this.d.f(), irecipe, intarraylist.iterator(), k);
+            }
+        }
+
+    }
+
+    @Override
+    public void a(Iterator<Integer> iterator, int i, int j, int k, int l) {
+        Slot slot = this.d.getSlot(i);
+        ItemStack itemstack = AutoRecipeStackManager.a((Integer) iterator.next());
+
+        if (!itemstack.isEmpty()) {
+            for (int i1 = 0; i1 < j; ++i1) {
+                this.a(slot, itemstack);
+            }
+        }
+
+    }
+
+    protected int a(boolean flag, int i, boolean flag1) {
+        int j = 1;
+
+        if (flag) {
+            j = i;
+        } else if (flag1) {
+            j = 64;
+
+            for (int k = 0; k < this.d.g() * this.d.h() + 1; ++k) {
+                if (k != this.d.f()) {
+                    ItemStack itemstack = this.d.getSlot(k).getItem();
+
+                    if (!itemstack.isEmpty() && j > itemstack.getCount()) {
+                        j = itemstack.getCount();
+                    }
+                }
+            }
+
+            if (j < 64) {
+                ++j;
+            }
+        }
+
+        return j;
+    }
+
+    protected void a(Slot slot, ItemStack itemstack) {
+        int i = this.c.c(itemstack);
+
+        if (i != -1) {
+            ItemStack itemstack1 = this.c.getItem(i).cloneItemStack();
+
+            if (!itemstack1.isEmpty()) {
+                if (itemstack1.getCount() > 1) {
+                    this.c.splitStack(i, 1);
+                } else {
+                    this.c.splitWithoutUpdate(i);
+                }
+
+                itemstack1.setCount(1);
+                if (slot.getItem().isEmpty()) {
+                    slot.set(itemstack1);
+                } else {
+                    slot.getItem().add(1);
+                }
+
+            }
+        }
+    }
+
+    private boolean b() {
+        List<ItemStack> list = Lists.newArrayList();
+        int i = this.c();
+
+        for (int j = 0; j < this.d.g() * this.d.h() + 1; ++j) {
+            if (j != this.d.f()) {
+                ItemStack itemstack = this.d.getSlot(j).getItem().cloneItemStack();
+
+                if (!itemstack.isEmpty()) {
+                    int k = this.c.firstPartial(itemstack);
+
+                    if (k == -1 && list.size() <= i) {
+                        Iterator iterator = list.iterator();
+
+                        while (iterator.hasNext()) {
+                            ItemStack itemstack1 = (ItemStack) iterator.next();
+
+                            if (itemstack1.doMaterialsMatch(itemstack) && itemstack1.getCount() != itemstack1.getMaxStackSize() && itemstack1.getCount() + itemstack.getCount() <= itemstack1.getMaxStackSize()) {
+                                itemstack1.add(itemstack.getCount());
+                                itemstack.setCount(0);
+                                break;
+                            }
+                        }
+
+                        if (!itemstack.isEmpty()) {
+                            if (list.size() >= i) {
+                                return false;
+                            }
+
+                            list.add(itemstack);
+                        }
+                    } else if (k == -1) {
+                        return false;
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+
+    private int c() {
+        int i = 0;
+        Iterator iterator = this.c.items.iterator();
+
+        while (iterator.hasNext()) {
+            ItemStack itemstack = (ItemStack) iterator.next();
+
+            if (itemstack.isEmpty()) {
+                ++i;
+            }
+        }
+
+        return i;
+    }
+}
diff --git a/src/main/java/net/minecraft/resources/ResourceKey.java b/src/main/java/net/minecraft/resources/ResourceKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..760579921927b4c8b0f20b2611b95fd626e4b27f
--- /dev/null
+++ b/src/main/java/net/minecraft/resources/ResourceKey.java
@@ -0,0 +1,53 @@
+package net.minecraft.resources;
+
+import com.google.common.collect.Maps;
+import java.util.Collections;
+import java.util.Map;
+import java.util.function.Function;
+import net.minecraft.core.IRegistry;
+
+public class ResourceKey<T> {
+
+    private static final Map<String, ResourceKey<?>> a = Collections.synchronizedMap(Maps.newIdentityHashMap());
+    private final MinecraftKey b;
+    private final MinecraftKey c;
+
+    public static <T> ResourceKey<T> a(ResourceKey<? extends IRegistry<T>> resourcekey, MinecraftKey minecraftkey) {
+        return a(resourcekey.c, minecraftkey);
+    }
+
+    public static <T> ResourceKey<IRegistry<T>> a(MinecraftKey minecraftkey) {
+        return a(IRegistry.d, minecraftkey);
+    }
+
+    private static <T> ResourceKey<T> a(MinecraftKey minecraftkey, MinecraftKey minecraftkey1) {
+        String s = (minecraftkey + ":" + minecraftkey1).intern();
+
+        return (ResourceKey) ResourceKey.a.computeIfAbsent(s, (s1) -> {
+            return new ResourceKey<>(minecraftkey, minecraftkey1);
+        });
+    }
+
+    private ResourceKey(MinecraftKey minecraftkey, MinecraftKey minecraftkey1) {
+        this.b = minecraftkey;
+        this.c = minecraftkey1;
+    }
+
+    public String toString() {
+        return "ResourceKey[" + this.b + " / " + this.c + ']';
+    }
+
+    public boolean a(ResourceKey<? extends IRegistry<?>> resourcekey) {
+        return this.b.equals(resourcekey.a());
+    }
+
+    public MinecraftKey a() {
+        return this.c;
+    }
+
+    public static <T> Function<MinecraftKey, ResourceKey<T>> b(ResourceKey<? extends IRegistry<T>> resourcekey) {
+        return (minecraftkey) -> {
+            return a(resourcekey, minecraftkey);
+        };
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EULA.java b/src/main/java/net/minecraft/server/EULA.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5171d28b960b12c2743ea68a36d747bc967697d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EULA.java
@@ -0,0 +1,99 @@
+package net.minecraft.server;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Properties;
+import net.minecraft.SharedConstants;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class EULA {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final Path b;
+    private final boolean c;
+
+    public EULA(Path path) {
+        this.b = path;
+        this.c = SharedConstants.d || this.b();
+    }
+
+    private boolean b() {
+        try {
+            InputStream inputstream = Files.newInputStream(this.b);
+            Throwable throwable = null;
+
+            boolean flag;
+
+            try {
+                Properties properties = new Properties();
+
+                properties.load(inputstream);
+                flag = Boolean.parseBoolean(properties.getProperty("eula", "false"));
+            } catch (Throwable throwable1) {
+                throwable = throwable1;
+                throw throwable1;
+            } finally {
+                if (inputstream != null) {
+                    if (throwable != null) {
+                        try {
+                            inputstream.close();
+                        } catch (Throwable throwable2) {
+                            throwable.addSuppressed(throwable2);
+                        }
+                    } else {
+                        inputstream.close();
+                    }
+                }
+
+            }
+
+            return flag;
+        } catch (Exception exception) {
+            EULA.LOGGER.warn("Failed to load {}", this.b);
+            this.c();
+            return false;
+        }
+    }
+
+    public boolean a() {
+        return this.c;
+    }
+
+    private void c() {
+        if (!SharedConstants.d) {
+            try {
+                OutputStream outputstream = Files.newOutputStream(this.b);
+                Throwable throwable = null;
+
+                try {
+                    Properties properties = new Properties();
+
+                    properties.setProperty("eula", "false");
+                    properties.store(outputstream, "By changing the setting below to TRUE you are indicating your agreement to our EULA (https://account.mojang.com/documents/minecraft_eula).");
+                } catch (Throwable throwable1) {
+                    throwable = throwable1;
+                    throw throwable1;
+                } finally {
+                    if (outputstream != null) {
+                        if (throwable != null) {
+                            try {
+                                outputstream.close();
+                            } catch (Throwable throwable2) {
+                                throwable.addSuppressed(throwable2);
+                            }
+                        } else {
+                            outputstream.close();
+                        }
+                    }
+
+                }
+            } catch (Exception exception) {
+                EULA.LOGGER.warn("Failed to save {}", this.b, exception);
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/CommandDifficulty.java b/src/main/java/net/minecraft/server/commands/CommandDifficulty.java
new file mode 100644
index 0000000000000000000000000000000000000000..1773fa44f55c6f6dcda0afceff4db39881861879
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/CommandDifficulty.java
@@ -0,0 +1,52 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import net.minecraft.commands.CommandListenerWrapper;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.EnumDifficulty;
+
+public class CommandDifficulty {
+
+    private static final DynamicCommandExceptionType a = new DynamicCommandExceptionType((object) -> {
+        return new ChatMessage("commands.difficulty.failure", new Object[]{object});
+    });
+
+    public static void a(CommandDispatcher<CommandListenerWrapper> commanddispatcher) {
+        LiteralArgumentBuilder<CommandListenerWrapper> literalargumentbuilder = net.minecraft.commands.CommandDispatcher.a("difficulty");
+        EnumDifficulty[] aenumdifficulty = EnumDifficulty.values();
+        int i = aenumdifficulty.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDifficulty enumdifficulty = aenumdifficulty[j];
+
+            literalargumentbuilder.then(net.minecraft.commands.CommandDispatcher.a(enumdifficulty.c()).executes((commandcontext) -> {
+                return a((CommandListenerWrapper) commandcontext.getSource(), enumdifficulty);
+            }));
+        }
+
+        commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) literalargumentbuilder.requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(2);
+        })).executes((commandcontext) -> {
+            EnumDifficulty enumdifficulty1 = ((CommandListenerWrapper) commandcontext.getSource()).getWorld().getDifficulty();
+
+            ((CommandListenerWrapper) commandcontext.getSource()).sendMessage(new ChatMessage("commands.difficulty.query", new Object[]{enumdifficulty1.b()}), false);
+            return enumdifficulty1.a();
+        }));
+    }
+
+    public static int a(CommandListenerWrapper commandlistenerwrapper, EnumDifficulty enumdifficulty) throws CommandSyntaxException {
+        MinecraftServer minecraftserver = commandlistenerwrapper.getServer();
+
+        if (minecraftserver.getSaveData().getDifficulty() == enumdifficulty) {
+            throw CommandDifficulty.a.create(enumdifficulty.c());
+        } else {
+            minecraftserver.a(enumdifficulty, true);
+            commandlistenerwrapper.sendMessage(new ChatMessage("commands.difficulty.success", new Object[]{enumdifficulty.b()}), true);
+            return 0;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/CommandGive.java b/src/main/java/net/minecraft/server/commands/CommandGive.java
new file mode 100644
index 0000000000000000000000000000000000000000..6685bf1757458d908e32d4069f7a8a22a28c28d7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/CommandGive.java
@@ -0,0 +1,77 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import java.util.Collection;
+import java.util.Iterator;
+import net.minecraft.commands.CommandListenerWrapper;
+import net.minecraft.commands.arguments.ArgumentEntity;
+import net.minecraft.commands.arguments.item.ArgumentItemStack;
+import net.minecraft.commands.arguments.item.ArgumentPredicateItemStack;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.world.entity.item.EntityItem;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.item.ItemStack;
+
+public class CommandGive {
+
+    public static void a(CommandDispatcher<CommandListenerWrapper> commanddispatcher) {
+        commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) net.minecraft.commands.CommandDispatcher.a("give").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(2);
+        })).then(net.minecraft.commands.CommandDispatcher.a("targets", (ArgumentType) ArgumentEntity.d()).then(((RequiredArgumentBuilder) net.minecraft.commands.CommandDispatcher.a("item", (ArgumentType) ArgumentItemStack.a()).executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), ArgumentItemStack.a(commandcontext, "item"), ArgumentEntity.f(commandcontext, "targets"), 1);
+        })).then(net.minecraft.commands.CommandDispatcher.a("count", (ArgumentType) IntegerArgumentType.integer(1)).executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), ArgumentItemStack.a(commandcontext, "item"), ArgumentEntity.f(commandcontext, "targets"), IntegerArgumentType.getInteger(commandcontext, "count"));
+        })))));
+    }
+
+    private static int a(CommandListenerWrapper commandlistenerwrapper, ArgumentPredicateItemStack argumentpredicateitemstack, Collection<EntityPlayer> collection, int i) throws CommandSyntaxException {
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+            int j = i;
+
+            while (j > 0) {
+                int k = Math.min(argumentpredicateitemstack.a().getMaxStackSize(), j);
+
+                j -= k;
+                ItemStack itemstack = argumentpredicateitemstack.a(k, false);
+                boolean flag = entityplayer.inventory.pickup(itemstack);
+                EntityItem entityitem;
+
+                if (flag && itemstack.isEmpty()) {
+                    itemstack.setCount(1);
+                    entityitem = entityplayer.drop(itemstack, false);
+                    if (entityitem != null) {
+                        entityitem.s();
+                    }
+
+                    entityplayer.world.playSound((EntityHuman) null, entityplayer.locX(), entityplayer.locY(), entityplayer.locZ(), SoundEffects.ENTITY_ITEM_PICKUP, SoundCategory.PLAYERS, 0.2F, ((entityplayer.getRandom().nextFloat() - entityplayer.getRandom().nextFloat()) * 0.7F + 1.0F) * 2.0F);
+                    entityplayer.defaultContainer.c();
+                } else {
+                    entityitem = entityplayer.drop(itemstack, false);
+                    if (entityitem != null) {
+                        entityitem.n();
+                        entityitem.setOwner(entityplayer.getUniqueID());
+                    }
+                }
+            }
+        }
+
+        if (collection.size() == 1) {
+            commandlistenerwrapper.sendMessage(new ChatMessage("commands.give.success.single", new Object[]{i, argumentpredicateitemstack.a(i, false).C(), ((EntityPlayer) collection.iterator().next()).getScoreboardDisplayName()}), true);
+        } else {
+            commandlistenerwrapper.sendMessage(new ChatMessage("commands.give.success.single", new Object[]{i, argumentpredicateitemstack.a(i, false).C(), collection.size()}), true);
+        }
+
+        return collection.size();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/CommandSchedule.java b/src/main/java/net/minecraft/server/commands/CommandSchedule.java
new file mode 100644
index 0000000000000000000000000000000000000000..b88a91072032b75f83d811d63e1b5e3808faa9be
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/CommandSchedule.java
@@ -0,0 +1,93 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.datafixers.util.Either;
+import com.mojang.datafixers.util.Pair;
+import net.minecraft.commands.CommandListenerWrapper;
+import net.minecraft.commands.CustomFunction;
+import net.minecraft.commands.ICompletionProvider;
+import net.minecraft.commands.arguments.ArgumentTime;
+import net.minecraft.commands.arguments.item.ArgumentTag;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.Tag;
+import net.minecraft.world.level.timers.CustomFunctionCallback;
+import net.minecraft.world.level.timers.CustomFunctionCallbackTag;
+import net.minecraft.world.level.timers.CustomFunctionCallbackTimerQueue;
+
+public class CommandSchedule {
+
+    private static final SimpleCommandExceptionType a = new SimpleCommandExceptionType(new ChatMessage("commands.schedule.same_tick"));
+    private static final DynamicCommandExceptionType b = new DynamicCommandExceptionType((object) -> {
+        return new ChatMessage("commands.schedule.cleared.failure", new Object[]{object});
+    });
+    private static final SuggestionProvider<CommandListenerWrapper> c = (commandcontext, suggestionsbuilder) -> {
+        return ICompletionProvider.b((Iterable) ((CommandListenerWrapper) commandcontext.getSource()).getServer().getSaveData().H().u().a(), suggestionsbuilder);
+    };
+
+    public static void a(CommandDispatcher<CommandListenerWrapper> commanddispatcher) {
+        commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) ((LiteralArgumentBuilder) net.minecraft.commands.CommandDispatcher.a("schedule").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(2);
+        })).then(net.minecraft.commands.CommandDispatcher.a("function").then(net.minecraft.commands.CommandDispatcher.a("function", (ArgumentType) ArgumentTag.a()).suggests(CommandFunction.a).then(((RequiredArgumentBuilder) ((RequiredArgumentBuilder) net.minecraft.commands.CommandDispatcher.a("time", (ArgumentType) ArgumentTime.a()).executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), ArgumentTag.b(commandcontext, "function"), IntegerArgumentType.getInteger(commandcontext, "time"), true);
+        })).then(net.minecraft.commands.CommandDispatcher.a("append").executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), ArgumentTag.b(commandcontext, "function"), IntegerArgumentType.getInteger(commandcontext, "time"), false);
+        }))).then(net.minecraft.commands.CommandDispatcher.a("replace").executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), ArgumentTag.b(commandcontext, "function"), IntegerArgumentType.getInteger(commandcontext, "time"), true);
+        })))))).then(net.minecraft.commands.CommandDispatcher.a("clear").then(net.minecraft.commands.CommandDispatcher.a("function", (ArgumentType) StringArgumentType.greedyString()).suggests(CommandSchedule.c).executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), StringArgumentType.getString(commandcontext, "function"));
+        }))));
+    }
+
+    private static int a(CommandListenerWrapper commandlistenerwrapper, Pair<MinecraftKey, Either<CustomFunction, Tag<CustomFunction>>> pair, int i, boolean flag) throws CommandSyntaxException {
+        if (i == 0) {
+            throw CommandSchedule.a.create();
+        } else {
+            long j = commandlistenerwrapper.getWorld().getTime() + (long) i;
+            MinecraftKey minecraftkey = (MinecraftKey) pair.getFirst();
+            CustomFunctionCallbackTimerQueue<MinecraftServer> customfunctioncallbacktimerqueue = commandlistenerwrapper.getServer().getSaveData().H().u();
+
+            ((Either) pair.getSecond()).ifLeft((customfunction) -> {
+                String s = minecraftkey.toString();
+
+                if (flag) {
+                    customfunctioncallbacktimerqueue.a(s);
+                }
+
+                customfunctioncallbacktimerqueue.a(s, j, new CustomFunctionCallback(minecraftkey));
+                commandlistenerwrapper.sendMessage(new ChatMessage("commands.schedule.created.function", new Object[]{minecraftkey, i, j}), true);
+            }).ifRight((tag) -> {
+                String s = "#" + minecraftkey.toString();
+
+                if (flag) {
+                    customfunctioncallbacktimerqueue.a(s);
+                }
+
+                customfunctioncallbacktimerqueue.a(s, j, new CustomFunctionCallbackTag(minecraftkey));
+                commandlistenerwrapper.sendMessage(new ChatMessage("commands.schedule.created.tag", new Object[]{minecraftkey, i, j}), true);
+            });
+            return (int) Math.floorMod(j, 2147483647L);
+        }
+    }
+
+    private static int a(CommandListenerWrapper commandlistenerwrapper, String s) throws CommandSyntaxException {
+        int i = commandlistenerwrapper.getServer().getSaveData().H().u().a(s);
+
+        if (i == 0) {
+            throw CommandSchedule.b.create(s);
+        } else {
+            commandlistenerwrapper.sendMessage(new ChatMessage("commands.schedule.cleared.success", new Object[]{i, s}), true);
+            return i;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
new file mode 100644
index 0000000000000000000000000000000000000000..b13e6f9923a9c5703f4eaeab2d0c112e4726b496
--- /dev/null
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
@@ -0,0 +1,143 @@
+package net.minecraft.server.dedicated;
+
+import com.mojang.authlib.GameProfile;
+import java.io.IOException;
+import net.minecraft.core.IRegistryCustom;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.world.level.storage.WorldNBTStorage;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class DedicatedPlayerList extends PlayerList {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public DedicatedPlayerList(DedicatedServer dedicatedserver, IRegistryCustom.Dimension iregistrycustom_dimension, WorldNBTStorage worldnbtstorage) {
+        super(dedicatedserver, iregistrycustom_dimension, worldnbtstorage, dedicatedserver.getDedicatedServerProperties().maxPlayers);
+        DedicatedServerProperties dedicatedserverproperties = dedicatedserver.getDedicatedServerProperties();
+
+        this.a(dedicatedserverproperties.viewDistance);
+        super.setHasWhitelist((Boolean) dedicatedserverproperties.whiteList.get());
+        this.y();
+        this.w();
+        this.x();
+        this.v();
+        this.z();
+        this.B();
+        this.A();
+        if (!this.getWhitelist().b().exists()) {
+            this.C();
+        }
+
+    }
+
+    @Override
+    public void setHasWhitelist(boolean flag) {
+        super.setHasWhitelist(flag);
+        this.getServer().setHasWhitelist(flag);
+    }
+
+    @Override
+    public void addOp(GameProfile gameprofile) {
+        super.addOp(gameprofile);
+        this.A();
+    }
+
+    @Override
+    public void removeOp(GameProfile gameprofile) {
+        super.removeOp(gameprofile);
+        this.A();
+    }
+
+    @Override
+    public void reloadWhitelist() {
+        this.B();
+    }
+
+    private void v() {
+        try {
+            this.getIPBans().save();
+        } catch (IOException ioexception) {
+            DedicatedPlayerList.LOGGER.warn("Failed to save ip banlist: ", ioexception);
+        }
+
+    }
+
+    private void w() {
+        try {
+            this.getProfileBans().save();
+        } catch (IOException ioexception) {
+            DedicatedPlayerList.LOGGER.warn("Failed to save user banlist: ", ioexception);
+        }
+
+    }
+
+    private void x() {
+        try {
+            this.getIPBans().load();
+        } catch (IOException ioexception) {
+            DedicatedPlayerList.LOGGER.warn("Failed to load ip banlist: ", ioexception);
+        }
+
+    }
+
+    private void y() {
+        try {
+            this.getProfileBans().load();
+        } catch (IOException ioexception) {
+            DedicatedPlayerList.LOGGER.warn("Failed to load user banlist: ", ioexception);
+        }
+
+    }
+
+    private void z() {
+        try {
+            this.getOPs().load();
+        } catch (Exception exception) {
+            DedicatedPlayerList.LOGGER.warn("Failed to load operators list: ", exception);
+        }
+
+    }
+
+    private void A() {
+        try {
+            this.getOPs().save();
+        } catch (Exception exception) {
+            DedicatedPlayerList.LOGGER.warn("Failed to save operators list: ", exception);
+        }
+
+    }
+
+    private void B() {
+        try {
+            this.getWhitelist().load();
+        } catch (Exception exception) {
+            DedicatedPlayerList.LOGGER.warn("Failed to load white-list: ", exception);
+        }
+
+    }
+
+    private void C() {
+        try {
+            this.getWhitelist().save();
+        } catch (Exception exception) {
+            DedicatedPlayerList.LOGGER.warn("Failed to save white-list: ", exception);
+        }
+
+    }
+
+    @Override
+    public boolean isWhitelisted(GameProfile gameprofile) {
+        return !this.getHasWhitelist() || this.isOp(gameprofile) || this.getWhitelist().isWhitelisted(gameprofile);
+    }
+
+    @Override
+    public DedicatedServer getServer() {
+        return (DedicatedServer) super.getServer();
+    }
+
+    @Override
+    public boolean f(GameProfile gameprofile) {
+        return this.getOPs().b(gameprofile);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/gui/GuiStatsComponent.java b/src/main/java/net/minecraft/server/gui/GuiStatsComponent.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ac8a9af459656483dc693a3028ebf8c34628cc7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/gui/GuiStatsComponent.java
@@ -0,0 +1,88 @@
+package net.minecraft.server.gui;
+
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.Locale;
+import javax.swing.JComponent;
+import javax.swing.Timer;
+import net.minecraft.SystemUtils;
+import net.minecraft.server.MinecraftServer;
+
+public class GuiStatsComponent extends JComponent {
+
+    private static final DecimalFormat a = (DecimalFormat) SystemUtils.a((Object) (new DecimalFormat("########0.000")), (decimalformat) -> {
+        decimalformat.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(Locale.ROOT));
+    });
+    private final int[] b = new int[256];
+    private int c;
+    private final String[] d = new String[11];
+    private final MinecraftServer e;
+    private final Timer f;
+
+    public GuiStatsComponent(MinecraftServer minecraftserver) {
+        this.e = minecraftserver;
+        this.setPreferredSize(new Dimension(456, 246));
+        this.setMinimumSize(new Dimension(456, 246));
+        this.setMaximumSize(new Dimension(456, 246));
+        this.f = new Timer(500, (actionevent) -> {
+            this.b();
+        });
+        this.f.start();
+        this.setBackground(Color.BLACK);
+    }
+
+    private void b() {
+        long i = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
+
+        this.d[0] = "Memory use: " + i / 1024L / 1024L + " mb (" + Runtime.getRuntime().freeMemory() * 100L / Runtime.getRuntime().maxMemory() + "% free)";
+        this.d[1] = "Avg tick: " + GuiStatsComponent.a.format(this.a(this.e.h) * 1.0E-6D) + " ms";
+        this.b[this.c++ & 255] = (int) (i * 100L / Runtime.getRuntime().maxMemory());
+        this.repaint();
+    }
+
+    private double a(long[] along) {
+        long i = 0L;
+        long[] along1 = along;
+        int j = along.length;
+
+        for (int k = 0; k < j; ++k) {
+            long l = along1[k];
+
+            i += l;
+        }
+
+        return (double) i / (double) along.length;
+    }
+
+    public void paint(Graphics graphics) {
+        graphics.setColor(new Color(16777215));
+        graphics.fillRect(0, 0, 456, 246);
+
+        int i;
+
+        for (i = 0; i < 256; ++i) {
+            int j = this.b[i + this.c & 255];
+
+            graphics.setColor(new Color(j + 28 << 16));
+            graphics.fillRect(i, 100 - j, 1, j);
+        }
+
+        graphics.setColor(Color.BLACK);
+
+        for (i = 0; i < this.d.length; ++i) {
+            String s = this.d[i];
+
+            if (s != null) {
+                graphics.drawString(s, 32, 116 + i * 16);
+            }
+        }
+
+    }
+
+    public void a() {
+        this.f.stop();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/LightEngineGraphSection.java b/src/main/java/net/minecraft/server/level/LightEngineGraphSection.java
new file mode 100644
index 0000000000000000000000000000000000000000..c8bb040e7ed848877ec9c2f9b30dcda137cadf35
--- /dev/null
+++ b/src/main/java/net/minecraft/server/level/LightEngineGraphSection.java
@@ -0,0 +1,74 @@
+package net.minecraft.server.level;
+
+import net.minecraft.core.SectionPosition;
+import net.minecraft.world.level.lighting.LightEngineGraph;
+
+public abstract class LightEngineGraphSection extends LightEngineGraph {
+
+    protected LightEngineGraphSection(int i, int j, int k) {
+        super(i, j, k);
+    }
+
+    @Override
+    protected boolean a(long i) {
+        return i == Long.MAX_VALUE;
+    }
+
+    @Override
+    protected void a(long i, int j, boolean flag) {
+        for (int k = -1; k <= 1; ++k) {
+            for (int l = -1; l <= 1; ++l) {
+                for (int i1 = -1; i1 <= 1; ++i1) {
+                    long j1 = SectionPosition.a(i, k, l, i1);
+
+                    if (j1 != i) {
+                        this.b(i, j1, j, flag);
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Override
+    protected int a(long i, long j, int k) {
+        int l = k;
+
+        for (int i1 = -1; i1 <= 1; ++i1) {
+            for (int j1 = -1; j1 <= 1; ++j1) {
+                for (int k1 = -1; k1 <= 1; ++k1) {
+                    long l1 = SectionPosition.a(i, i1, j1, k1);
+
+                    if (l1 == i) {
+                        l1 = Long.MAX_VALUE;
+                    }
+
+                    if (l1 != j) {
+                        int i2 = this.b(l1, i, this.c(l1));
+
+                        if (l > i2) {
+                            l = i2;
+                        }
+
+                        if (l == 0) {
+                            return l;
+                        }
+                    }
+                }
+            }
+        }
+
+        return l;
+    }
+
+    @Override
+    protected int b(long i, long j, int k) {
+        return i == Long.MAX_VALUE ? this.b(j) : k + 1;
+    }
+
+    protected abstract int b(long i);
+
+    public void b(long i, int j, boolean flag) {
+        this.a(Long.MAX_VALUE, i, j, flag);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/LightEngineThreaded.java b/src/main/java/net/minecraft/server/level/LightEngineThreaded.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a51f47f747382ec2a30bb47bcb1f7c61dd4c369
--- /dev/null
+++ b/src/main/java/net/minecraft/server/level/LightEngineThreaded.java
@@ -0,0 +1,228 @@
+package net.minecraft.server.level;
+
+import com.mojang.datafixers.util.Pair;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectList;
+import it.unimi.dsi.fastutil.objects.ObjectListIterator;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.IntSupplier;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.util.thread.Mailbox;
+import net.minecraft.util.thread.ThreadedMailbox;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.chunk.ChunkSection;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.chunk.ILightAccess;
+import net.minecraft.world.level.chunk.NibbleArray;
+import net.minecraft.world.level.lighting.LightEngine;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class LightEngineThreaded extends LightEngine implements AutoCloseable {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final ThreadedMailbox<Runnable> b;
+    private final ObjectList<Pair<LightEngineThreaded.Update, Runnable>> c = new ObjectArrayList();
+    private final PlayerChunkMap d;
+    private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> e;
+    private volatile int f = 5;
+    private final AtomicBoolean g = new AtomicBoolean();
+
+    public LightEngineThreaded(ILightAccess ilightaccess, PlayerChunkMap playerchunkmap, boolean flag, ThreadedMailbox<Runnable> threadedmailbox, Mailbox<ChunkTaskQueueSorter.a<Runnable>> mailbox) {
+        super(ilightaccess, true, flag);
+        this.d = playerchunkmap;
+        this.e = mailbox;
+        this.b = threadedmailbox;
+    }
+
+    public void close() {}
+
+    @Override
+    public int a(int i, boolean flag, boolean flag1) {
+        throw (UnsupportedOperationException) SystemUtils.c((Throwable) (new UnsupportedOperationException("Ran authomatically on a different thread!")));
+    }
+
+    @Override
+    public void a(BlockPosition blockposition, int i) {
+        throw (UnsupportedOperationException) SystemUtils.c((Throwable) (new UnsupportedOperationException("Ran authomatically on a different thread!")));
+    }
+
+    @Override
+    public void a(BlockPosition blockposition) {
+        BlockPosition blockposition1 = blockposition.immutableCopy();
+
+        this.a(blockposition.getX() >> 4, blockposition.getZ() >> 4, LightEngineThreaded.Update.POST_UPDATE, SystemUtils.a(() -> {
+            super.a(blockposition1);
+        }, () -> {
+            return "checkBlock " + blockposition1;
+        }));
+    }
+
+    protected void a(ChunkCoordIntPair chunkcoordintpair) {
+        this.a(chunkcoordintpair.x, chunkcoordintpair.z, () -> {
+            return 0;
+        }, LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
+            super.b(chunkcoordintpair, false);
+            super.a(chunkcoordintpair, false);
+
+            int i;
+
+            for (i = -1; i < 17; ++i) {
+                super.a(EnumSkyBlock.BLOCK, SectionPosition.a(chunkcoordintpair, i), (NibbleArray) null, true);
+                super.a(EnumSkyBlock.SKY, SectionPosition.a(chunkcoordintpair, i), (NibbleArray) null, true);
+            }
+
+            for (i = 0; i < 16; ++i) {
+                super.a(SectionPosition.a(chunkcoordintpair, i), true);
+            }
+
+        }, () -> {
+            return "updateChunkStatus " + chunkcoordintpair + " " + true;
+        }));
+    }
+
+    @Override
+    public void a(SectionPosition sectionposition, boolean flag) {
+        this.a(sectionposition.a(), sectionposition.c(), () -> {
+            return 0;
+        }, LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
+            super.a(sectionposition, flag);
+        }, () -> {
+            return "updateSectionStatus " + sectionposition + " " + flag;
+        }));
+    }
+
+    @Override
+    public void a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        this.a(chunkcoordintpair.x, chunkcoordintpair.z, LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
+            super.a(chunkcoordintpair, flag);
+        }, () -> {
+            return "enableLight " + chunkcoordintpair + " " + flag;
+        }));
+    }
+
+    @Override
+    public void a(EnumSkyBlock enumskyblock, SectionPosition sectionposition, @Nullable NibbleArray nibblearray, boolean flag) {
+        this.a(sectionposition.a(), sectionposition.c(), () -> {
+            return 0;
+        }, LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
+            super.a(enumskyblock, sectionposition, nibblearray, flag);
+        }, () -> {
+            return "queueData " + sectionposition;
+        }));
+    }
+
+    private void a(int i, int j, LightEngineThreaded.Update lightenginethreaded_update, Runnable runnable) {
+        this.a(i, j, this.d.c(ChunkCoordIntPair.pair(i, j)), lightenginethreaded_update, runnable);
+    }
+
+    private void a(int i, int j, IntSupplier intsupplier, LightEngineThreaded.Update lightenginethreaded_update, Runnable runnable) {
+        this.e.a(ChunkTaskQueueSorter.a(() -> {
+            this.c.add(Pair.of(lightenginethreaded_update, runnable));
+            if (this.c.size() >= this.f) {
+                this.b();
+            }
+
+        }, ChunkCoordIntPair.pair(i, j), intsupplier));
+    }
+
+    @Override
+    public void b(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        this.a(chunkcoordintpair.x, chunkcoordintpair.z, () -> {
+            return 0;
+        }, LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
+            super.b(chunkcoordintpair, flag);
+        }, () -> {
+            return "retainData " + chunkcoordintpair;
+        }));
+    }
+
+    public CompletableFuture<IChunkAccess> a(IChunkAccess ichunkaccess, boolean flag) {
+        ChunkCoordIntPair chunkcoordintpair = ichunkaccess.getPos();
+
+        ichunkaccess.b(false);
+        this.a(chunkcoordintpair.x, chunkcoordintpair.z, LightEngineThreaded.Update.PRE_UPDATE, SystemUtils.a(() -> {
+            ChunkSection[] achunksection = ichunkaccess.getSections();
+
+            for (int i = 0; i < 16; ++i) {
+                ChunkSection chunksection = achunksection[i];
+
+                if (!ChunkSection.a(chunksection)) {
+                    super.a(SectionPosition.a(chunkcoordintpair, i), false);
+                }
+            }
+
+            super.a(chunkcoordintpair, true);
+            if (!flag) {
+                ichunkaccess.m().forEach((blockposition) -> {
+                    super.a(blockposition, ichunkaccess.g(blockposition));
+                });
+            }
+
+            this.d.c(chunkcoordintpair);
+        }, () -> {
+            return "lightChunk " + chunkcoordintpair + " " + flag;
+        }));
+        return CompletableFuture.supplyAsync(() -> {
+            ichunkaccess.b(true);
+            super.b(chunkcoordintpair, false);
+            return ichunkaccess;
+        }, (runnable) -> {
+            this.a(chunkcoordintpair.x, chunkcoordintpair.z, LightEngineThreaded.Update.POST_UPDATE, runnable);
+        });
+    }
+
+    public void queueUpdate() {
+        if ((!this.c.isEmpty() || super.a()) && this.g.compareAndSet(false, true)) {
+            this.b.a((Object) (() -> {
+                this.b();
+                this.g.set(false);
+            }));
+        }
+
+    }
+
+    private void b() {
+        int i = Math.min(this.c.size(), this.f);
+        ObjectListIterator<Pair<LightEngineThreaded.Update, Runnable>> objectlistiterator = this.c.iterator();
+
+        Pair pair;
+        int j;
+
+        for (j = 0; objectlistiterator.hasNext() && j < i; ++j) {
+            pair = (Pair) objectlistiterator.next();
+            if (pair.getFirst() == LightEngineThreaded.Update.PRE_UPDATE) {
+                ((Runnable) pair.getSecond()).run();
+            }
+        }
+
+        objectlistiterator.back(j);
+        super.a(Integer.MAX_VALUE, true, true);
+
+        for (j = 0; objectlistiterator.hasNext() && j < i; ++j) {
+            pair = (Pair) objectlistiterator.next();
+            if (pair.getFirst() == LightEngineThreaded.Update.POST_UPDATE) {
+                ((Runnable) pair.getSecond()).run();
+            }
+
+            objectlistiterator.remove();
+        }
+
+    }
+
+    public void a(int i) {
+        this.f = i;
+    }
+
+    static enum Update {
+
+        PRE_UPDATE, POST_UPDATE;
+
+        private Update() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/Ticket.java b/src/main/java/net/minecraft/server/level/Ticket.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c500e1193296f92f03a94e2cf085b215daaad6c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/level/Ticket.java
@@ -0,0 +1,67 @@
+package net.minecraft.server.level;
+
+import java.util.Objects;
+
+public final class Ticket<T> implements Comparable<Ticket<?>> {
+
+    private final TicketType<T> a;
+    private final int b;
+    public final T identifier;
+    private long d;
+
+    protected Ticket(TicketType<T> tickettype, int i, T t0) {
+        this.a = tickettype;
+        this.b = i;
+        this.identifier = t0;
+    }
+
+    public int compareTo(Ticket<?> ticket) {
+        int i = Integer.compare(this.b, ticket.b);
+
+        if (i != 0) {
+            return i;
+        } else {
+            int j = Integer.compare(System.identityHashCode(this.a), System.identityHashCode(ticket.a));
+
+            return j != 0 ? j : this.a.a().compare(this.identifier, ticket.identifier);
+        }
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof Ticket)) {
+            return false;
+        } else {
+            Ticket<?> ticket = (Ticket) object;
+
+            return this.b == ticket.b && Objects.equals(this.a, ticket.a) && Objects.equals(this.identifier, ticket.identifier);
+        }
+    }
+
+    public int hashCode() {
+        return Objects.hash(new Object[]{this.a, this.b, this.identifier});
+    }
+
+    public String toString() {
+        return "Ticket[" + this.a + " " + this.b + " (" + this.identifier + ")] at " + this.d;
+    }
+
+    public TicketType<T> getTicketType() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.b;
+    }
+
+    protected void a(long i) {
+        this.d = i;
+    }
+
+    protected boolean b(long i) {
+        long j = this.a.b();
+
+        return j != 0L && i - this.d > j;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/progress/WorldLoadListener.java b/src/main/java/net/minecraft/server/level/progress/WorldLoadListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..de011b5e3a5e751160b4d3b65b50f28e6c6a5f52
--- /dev/null
+++ b/src/main/java/net/minecraft/server/level/progress/WorldLoadListener.java
@@ -0,0 +1,14 @@
+package net.minecraft.server.level.progress;
+
+import javax.annotation.Nullable;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.chunk.ChunkStatus;
+
+public interface WorldLoadListener {
+
+    void a(ChunkCoordIntPair chunkcoordintpair);
+
+    void a(ChunkCoordIntPair chunkcoordintpair, @Nullable ChunkStatus chunkstatus);
+
+    void b();
+}
diff --git a/src/main/java/net/minecraft/server/level/progress/WorldLoadListenerLogger.java b/src/main/java/net/minecraft/server/level/progress/WorldLoadListenerLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..872d00de41533ab7f4b43874de6c1747022e2ac5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/level/progress/WorldLoadListenerLogger.java
@@ -0,0 +1,56 @@
+package net.minecraft.server.level.progress;
+
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class WorldLoadListenerLogger implements WorldLoadListener {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final int b;
+    private int c;
+    private long d;
+    private long e = Long.MAX_VALUE;
+
+    public WorldLoadListenerLogger(int i) {
+        int j = i * 2 + 1;
+
+        this.b = j * j;
+    }
+
+    @Override
+    public void a(ChunkCoordIntPair chunkcoordintpair) {
+        this.e = SystemUtils.getMonotonicMillis();
+        this.d = this.e;
+    }
+
+    @Override
+    public void a(ChunkCoordIntPair chunkcoordintpair, @Nullable ChunkStatus chunkstatus) {
+        if (chunkstatus == ChunkStatus.FULL) {
+            ++this.c;
+        }
+
+        int i = this.c();
+
+        if (SystemUtils.getMonotonicMillis() > this.e) {
+            this.e += 500L;
+            WorldLoadListenerLogger.LOGGER.info((new ChatMessage("menu.preparingSpawn", new Object[]{MathHelper.clamp(i, 0, 100)})).getString());
+        }
+
+    }
+
+    @Override
+    public void b() {
+        WorldLoadListenerLogger.LOGGER.info("Time elapsed: {} ms", SystemUtils.getMonotonicMillis() - this.d);
+        this.e = Long.MAX_VALUE;
+    }
+
+    public int c() {
+        return MathHelper.d((float) this.c * 100.0F / (float) this.b);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/rcon/RemoteStatusReply.java b/src/main/java/net/minecraft/server/rcon/RemoteStatusReply.java
new file mode 100644
index 0000000000000000000000000000000000000000..57ff3db0a0199ef03045b880e598407886b0306b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/rcon/RemoteStatusReply.java
@@ -0,0 +1,41 @@
+package net.minecraft.server.rcon;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class RemoteStatusReply {
+
+    private final ByteArrayOutputStream a;
+    private final DataOutputStream b;
+
+    public RemoteStatusReply(int i) {
+        this.a = new ByteArrayOutputStream(i);
+        this.b = new DataOutputStream(this.a);
+    }
+
+    public void a(byte[] abyte) throws IOException {
+        this.b.write(abyte, 0, abyte.length);
+    }
+
+    public void a(String s) throws IOException {
+        this.b.writeBytes(s);
+        this.b.write(0);
+    }
+
+    public void a(int i) throws IOException {
+        this.b.write(i);
+    }
+
+    public void a(short short0) throws IOException {
+        this.b.writeShort(Short.reverseBytes(short0));
+    }
+
+    public byte[] a() {
+        return this.a.toByteArray();
+    }
+
+    public void b() {
+        this.a.reset();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/rcon/thread/RemoteControlListener.java b/src/main/java/net/minecraft/server/rcon/thread/RemoteControlListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..797a450a08da1b799e32fae2a71a7a50bb90d127
--- /dev/null
+++ b/src/main/java/net/minecraft/server/rcon/thread/RemoteControlListener.java
@@ -0,0 +1,131 @@
+package net.minecraft.server.rcon.thread;
+
+import com.google.common.collect.Lists;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.server.IMinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServerProperties;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class RemoteControlListener extends RemoteConnectionThread {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final ServerSocket e;
+    private final String f;
+    private final List<RemoteControlSession> g = Lists.newArrayList();
+    private final IMinecraftServer h;
+
+    private RemoteControlListener(IMinecraftServer iminecraftserver, ServerSocket serversocket, String s) {
+        super("RCON Listener");
+        this.h = iminecraftserver;
+        this.e = serversocket;
+        this.f = s;
+    }
+
+    private void d() {
+        this.g.removeIf((remotecontrolsession) -> {
+            return !remotecontrolsession.c();
+        });
+    }
+
+    public void run() {
+        try {
+            while (this.a) {
+                try {
+                    Socket socket = this.e.accept();
+                    RemoteControlSession remotecontrolsession = new RemoteControlSession(this.h, this.f, socket);
+
+                    remotecontrolsession.a();
+                    this.g.add(remotecontrolsession);
+                    this.d();
+                } catch (SocketTimeoutException sockettimeoutexception) {
+                    this.d();
+                } catch (IOException ioexception) {
+                    if (this.a) {
+                        RemoteControlListener.LOGGER.info("IO exception: ", ioexception);
+                    }
+                }
+            }
+        } finally {
+            this.a(this.e);
+        }
+
+    }
+
+    @Nullable
+    public static RemoteControlListener a(IMinecraftServer iminecraftserver) {
+        DedicatedServerProperties dedicatedserverproperties = iminecraftserver.getDedicatedServerProperties();
+        String s = iminecraftserver.h_();
+
+        if (s.isEmpty()) {
+            s = "0.0.0.0";
+        }
+
+        int i = dedicatedserverproperties.rconPort;
+
+        if (0 < i && 65535 >= i) {
+            String s1 = dedicatedserverproperties.rconPassword;
+
+            if (s1.isEmpty()) {
+                RemoteControlListener.LOGGER.warn("No rcon password set in server.properties, rcon disabled!");
+                return null;
+            } else {
+                try {
+                    ServerSocket serversocket = new ServerSocket(i, 0, InetAddress.getByName(s));
+
+                    serversocket.setSoTimeout(500);
+                    RemoteControlListener remotecontrollistener = new RemoteControlListener(iminecraftserver, serversocket, s1);
+
+                    if (!remotecontrollistener.a()) {
+                        return null;
+                    } else {
+                        RemoteControlListener.LOGGER.info("RCON running on {}:{}", s, i);
+                        return remotecontrollistener;
+                    }
+                } catch (IOException ioexception) {
+                    RemoteControlListener.LOGGER.warn("Unable to initialise RCON on {}:{}", s, i, ioexception);
+                    return null;
+                }
+            }
+        } else {
+            RemoteControlListener.LOGGER.warn("Invalid rcon port {} found in server.properties, rcon disabled!", i);
+            return null;
+        }
+    }
+
+    @Override
+    public void b() {
+        this.a = false;
+        this.a(this.e);
+        super.b();
+        Iterator iterator = this.g.iterator();
+
+        while (iterator.hasNext()) {
+            RemoteControlSession remotecontrolsession = (RemoteControlSession) iterator.next();
+
+            if (remotecontrolsession.c()) {
+                remotecontrolsession.b();
+            }
+        }
+
+        this.g.clear();
+    }
+
+    private void a(ServerSocket serversocket) {
+        RemoteControlListener.LOGGER.debug("closeSocket: {}", serversocket);
+
+        try {
+            serversocket.close();
+        } catch (IOException ioexception) {
+            RemoteControlListener.LOGGER.warn("Failed to close socket", ioexception);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/rcon/thread/RemoteStatusListener.java b/src/main/java/net/minecraft/server/rcon/thread/RemoteStatusListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..55b379af2e0c8c3513a76a346d381cd3dbcabe40
--- /dev/null
+++ b/src/main/java/net/minecraft/server/rcon/thread/RemoteStatusListener.java
@@ -0,0 +1,318 @@
+package net.minecraft.server.rcon.thread;
+
+import com.google.common.collect.Maps;
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetAddress;
+import java.net.PortUnreachableException;
+import java.net.SocketAddress;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+import java.nio.charset.StandardCharsets;
+import java.util.Date;
+import java.util.Map;
+import java.util.Random;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.server.IMinecraftServer;
+import net.minecraft.server.rcon.RemoteStatusReply;
+import net.minecraft.server.rcon.StatusChallengeUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class RemoteStatusListener extends RemoteConnectionThread {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private long e;
+    private final int f;
+    private final int g;
+    private final int h;
+    private final String i;
+    private final String j;
+    private DatagramSocket k;
+    private final byte[] l = new byte[1460];
+    private String m;
+    private String n;
+    private final Map<SocketAddress, RemoteStatusListener.RemoteStatusChallenge> o;
+    private final RemoteStatusReply p;
+    private long q;
+    private final IMinecraftServer r;
+
+    private RemoteStatusListener(IMinecraftServer iminecraftserver, int i) {
+        super("Query Listener");
+        this.r = iminecraftserver;
+        this.f = i;
+        this.n = iminecraftserver.h_();
+        this.g = iminecraftserver.p();
+        this.i = iminecraftserver.i_();
+        this.h = iminecraftserver.getMaxPlayers();
+        this.j = iminecraftserver.getWorld();
+        this.q = 0L;
+        this.m = "0.0.0.0";
+        if (!this.n.isEmpty() && !this.m.equals(this.n)) {
+            this.m = this.n;
+        } else {
+            this.n = "0.0.0.0";
+
+            try {
+                InetAddress inetaddress = InetAddress.getLocalHost();
+
+                this.m = inetaddress.getHostAddress();
+            } catch (UnknownHostException unknownhostexception) {
+                RemoteStatusListener.LOGGER.warn("Unable to determine local host IP, please set server-ip in server.properties", unknownhostexception);
+            }
+        }
+
+        this.p = new RemoteStatusReply(1460);
+        this.o = Maps.newHashMap();
+    }
+
+    @Nullable
+    public static RemoteStatusListener a(IMinecraftServer iminecraftserver) {
+        int i = iminecraftserver.getDedicatedServerProperties().queryPort;
+
+        if (0 < i && 65535 >= i) {
+            RemoteStatusListener remotestatuslistener = new RemoteStatusListener(iminecraftserver, i);
+
+            return !remotestatuslistener.a() ? null : remotestatuslistener;
+        } else {
+            RemoteStatusListener.LOGGER.warn("Invalid query port {} found in server.properties (queries disabled)", i);
+            return null;
+        }
+    }
+
+    private void a(byte[] abyte, DatagramPacket datagrampacket) throws IOException {
+        this.k.send(new DatagramPacket(abyte, abyte.length, datagrampacket.getSocketAddress()));
+    }
+
+    private boolean a(DatagramPacket datagrampacket) throws IOException {
+        byte[] abyte = datagrampacket.getData();
+        int i = datagrampacket.getLength();
+        SocketAddress socketaddress = datagrampacket.getSocketAddress();
+
+        RemoteStatusListener.LOGGER.debug("Packet len {} [{}]", i, socketaddress);
+        if (3 <= i && -2 == abyte[0] && -3 == abyte[1]) {
+            RemoteStatusListener.LOGGER.debug("Packet '{}' [{}]", StatusChallengeUtils.a(abyte[2]), socketaddress);
+            switch (abyte[2]) {
+                case 0:
+                    if (!this.c(datagrampacket)) {
+                        RemoteStatusListener.LOGGER.debug("Invalid challenge [{}]", socketaddress);
+                        return false;
+                    } else if (15 == i) {
+                        this.a(this.b(datagrampacket), datagrampacket);
+                        RemoteStatusListener.LOGGER.debug("Rules [{}]", socketaddress);
+                    } else {
+                        RemoteStatusReply remotestatusreply = new RemoteStatusReply(1460);
+
+                        remotestatusreply.a((int) 0);
+                        remotestatusreply.a(this.a(datagrampacket.getSocketAddress()));
+                        remotestatusreply.a(this.i);
+                        remotestatusreply.a("SMP");
+                        remotestatusreply.a(this.j);
+                        remotestatusreply.a(Integer.toString(this.r.getPlayerCount()));
+                        remotestatusreply.a(Integer.toString(this.h));
+                        remotestatusreply.a((short) this.g);
+                        remotestatusreply.a(this.m);
+                        this.a(remotestatusreply.a(), datagrampacket);
+                        RemoteStatusListener.LOGGER.debug("Status [{}]", socketaddress);
+                    }
+                default:
+                    return true;
+                case 9:
+                    this.d(datagrampacket);
+                    RemoteStatusListener.LOGGER.debug("Challenge [{}]", socketaddress);
+                    return true;
+            }
+        } else {
+            RemoteStatusListener.LOGGER.debug("Invalid packet [{}]", socketaddress);
+            return false;
+        }
+    }
+
+    private byte[] b(DatagramPacket datagrampacket) throws IOException {
+        long i = SystemUtils.getMonotonicMillis();
+
+        if (i < this.q + 5000L) {
+            byte[] abyte = this.p.a();
+            byte[] abyte1 = this.a(datagrampacket.getSocketAddress());
+
+            abyte[1] = abyte1[0];
+            abyte[2] = abyte1[1];
+            abyte[3] = abyte1[2];
+            abyte[4] = abyte1[3];
+            return abyte;
+        } else {
+            this.q = i;
+            this.p.b();
+            this.p.a((int) 0);
+            this.p.a(this.a(datagrampacket.getSocketAddress()));
+            this.p.a("splitnum");
+            this.p.a((int) 128);
+            this.p.a((int) 0);
+            this.p.a("hostname");
+            this.p.a(this.i);
+            this.p.a("gametype");
+            this.p.a("SMP");
+            this.p.a("game_id");
+            this.p.a("MINECRAFT");
+            this.p.a("version");
+            this.p.a(this.r.getVersion());
+            this.p.a("plugins");
+            this.p.a(this.r.getPlugins());
+            this.p.a("map");
+            this.p.a(this.j);
+            this.p.a("numplayers");
+            this.p.a("" + this.r.getPlayerCount());
+            this.p.a("maxplayers");
+            this.p.a("" + this.h);
+            this.p.a("hostport");
+            this.p.a("" + this.g);
+            this.p.a("hostip");
+            this.p.a(this.m);
+            this.p.a((int) 0);
+            this.p.a((int) 1);
+            this.p.a("player_");
+            this.p.a((int) 0);
+            String[] astring = this.r.getPlayers();
+            String[] astring1 = astring;
+            int j = astring.length;
+
+            for (int k = 0; k < j; ++k) {
+                String s = astring1[k];
+
+                this.p.a(s);
+            }
+
+            this.p.a((int) 0);
+            return this.p.a();
+        }
+    }
+
+    private byte[] a(SocketAddress socketaddress) {
+        return ((RemoteStatusListener.RemoteStatusChallenge) this.o.get(socketaddress)).c();
+    }
+
+    private Boolean c(DatagramPacket datagrampacket) {
+        SocketAddress socketaddress = datagrampacket.getSocketAddress();
+
+        if (!this.o.containsKey(socketaddress)) {
+            return false;
+        } else {
+            byte[] abyte = datagrampacket.getData();
+
+            return ((RemoteStatusListener.RemoteStatusChallenge) this.o.get(socketaddress)).a() == StatusChallengeUtils.c(abyte, 7, datagrampacket.getLength());
+        }
+    }
+
+    private void d(DatagramPacket datagrampacket) throws IOException {
+        RemoteStatusListener.RemoteStatusChallenge remotestatuslistener_remotestatuschallenge = new RemoteStatusListener.RemoteStatusChallenge(datagrampacket);
+
+        this.o.put(datagrampacket.getSocketAddress(), remotestatuslistener_remotestatuschallenge);
+        this.a(remotestatuslistener_remotestatuschallenge.b(), datagrampacket);
+    }
+
+    private void d() {
+        if (this.a) {
+            long i = SystemUtils.getMonotonicMillis();
+
+            if (i >= this.e + 30000L) {
+                this.e = i;
+                this.o.values().removeIf((remotestatuslistener_remotestatuschallenge) -> {
+                    return remotestatuslistener_remotestatuschallenge.a(i);
+                });
+            }
+        }
+    }
+
+    public void run() {
+        RemoteStatusListener.LOGGER.info("Query running on {}:{}", this.n, this.f);
+        this.e = SystemUtils.getMonotonicMillis();
+        DatagramPacket datagrampacket = new DatagramPacket(this.l, this.l.length);
+
+        try {
+            while (this.a) {
+                try {
+                    this.k.receive(datagrampacket);
+                    this.d();
+                    this.a(datagrampacket);
+                } catch (SocketTimeoutException sockettimeoutexception) {
+                    this.d();
+                } catch (PortUnreachableException portunreachableexception) {
+                    ;
+                } catch (IOException ioexception) {
+                    this.a((Exception) ioexception);
+                }
+            }
+        } finally {
+            RemoteStatusListener.LOGGER.debug("closeSocket: {}:{}", this.n, this.f);
+            this.k.close();
+        }
+
+    }
+
+    @Override
+    public boolean a() {
+        return this.a ? true : (!this.e() ? false : super.a());
+    }
+
+    private void a(Exception exception) {
+        if (this.a) {
+            RemoteStatusListener.LOGGER.warn("Unexpected exception", exception);
+            if (!this.e()) {
+                RemoteStatusListener.LOGGER.error("Failed to recover from exception, shutting down!");
+                this.a = false;
+            }
+
+        }
+    }
+
+    private boolean e() {
+        try {
+            this.k = new DatagramSocket(this.f, InetAddress.getByName(this.n));
+            this.k.setSoTimeout(500);
+            return true;
+        } catch (Exception exception) {
+            RemoteStatusListener.LOGGER.warn("Unable to initialise query system on {}:{}", this.n, this.f, exception);
+            return false;
+        }
+    }
+
+    static class RemoteStatusChallenge {
+
+        private final long time = (new Date()).getTime();
+        private final int token;
+        private final byte[] identity;
+        private final byte[] d;
+        private final String e;
+
+        public RemoteStatusChallenge(DatagramPacket datagrampacket) {
+            byte[] abyte = datagrampacket.getData();
+
+            this.identity = new byte[4];
+            this.identity[0] = abyte[3];
+            this.identity[1] = abyte[4];
+            this.identity[2] = abyte[5];
+            this.identity[3] = abyte[6];
+            this.e = new String(this.identity, StandardCharsets.UTF_8);
+            this.token = (new Random()).nextInt(16777216);
+            this.d = String.format("\t%s%d\u0000", this.e, this.token).getBytes(StandardCharsets.UTF_8);
+        }
+
+        public Boolean a(long i) {
+            return this.time < i;
+        }
+
+        public int a() {
+            return this.token;
+        }
+
+        public byte[] b() {
+            return this.d;
+        }
+
+        public byte[] c() {
+            return this.identity;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/stats/StatisticWrapper.java b/src/main/java/net/minecraft/stats/StatisticWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1a694c4a773a41cdefca6b154711f7fc0a7fcaa
--- /dev/null
+++ b/src/main/java/net/minecraft/stats/StatisticWrapper.java
@@ -0,0 +1,34 @@
+package net.minecraft.stats;
+
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.Map;
+import net.minecraft.core.IRegistry;
+
+public class StatisticWrapper<T> implements Iterable<Statistic<T>> {
+
+    private final IRegistry<T> a;
+    private final Map<T, Statistic<T>> b = new IdentityHashMap();
+
+    public StatisticWrapper(IRegistry<T> iregistry) {
+        this.a = iregistry;
+    }
+
+    public Statistic<T> a(T t0, Counter counter) {
+        return (Statistic) this.b.computeIfAbsent(t0, (object) -> {
+            return new Statistic<>(this, object, counter);
+        });
+    }
+
+    public IRegistry<T> getRegistry() {
+        return this.a;
+    }
+
+    public Iterator<Statistic<T>> iterator() {
+        return this.b.values().iterator();
+    }
+
+    public Statistic<T> b(T t0) {
+        return this.a(t0, Counter.DEFAULT);
+    }
+}
diff --git a/src/main/java/net/minecraft/util/ArraySetSorted.java b/src/main/java/net/minecraft/util/ArraySetSorted.java
new file mode 100644
index 0000000000000000000000000000000000000000..e56b8e172d96c5508457fcf3f5a0cf0d2d2d8d7c
--- /dev/null
+++ b/src/main/java/net/minecraft/util/ArraySetSorted.java
@@ -0,0 +1,202 @@
+package net.minecraft.util;
+
+import it.unimi.dsi.fastutil.objects.ObjectArrays;
+import java.util.AbstractSet;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+public class ArraySetSorted<T> extends AbstractSet<T> {
+
+    private final Comparator<T> a;
+    private T[] b;
+    private int c;
+
+    private ArraySetSorted(int i, Comparator<T> comparator) {
+        this.a = comparator;
+        if (i < 0) {
+            throw new IllegalArgumentException("Initial capacity (" + i + ") is negative");
+        } else {
+            this.b = a(new Object[i]);
+        }
+    }
+
+    public static <T extends Comparable<T>> ArraySetSorted<T> a(int i) {
+        return new ArraySetSorted<>(i, Comparator.naturalOrder());
+    }
+
+    private static <T> T[] a(Object[] aobject) {
+        return (Object[]) aobject;
+    }
+
+    private int c(T t0) {
+        return Arrays.binarySearch(this.b, 0, this.c, t0, this.a);
+    }
+
+    private static int b(int i) {
+        return -i - 1;
+    }
+
+    public boolean add(T t0) {
+        int i = this.c(t0);
+
+        if (i >= 0) {
+            return false;
+        } else {
+            int j = b(i);
+
+            this.a(t0, j);
+            return true;
+        }
+    }
+
+    private void c(int i) {
+        if (i > this.b.length) {
+            if (this.b != ObjectArrays.DEFAULT_EMPTY_ARRAY) {
+                i = (int) Math.max(Math.min((long) this.b.length + (long) (this.b.length >> 1), 2147483639L), (long) i);
+            } else if (i < 10) {
+                i = 10;
+            }
+
+            Object[] aobject = new Object[i];
+
+            System.arraycopy(this.b, 0, aobject, 0, this.c);
+            this.b = a(aobject);
+        }
+    }
+
+    private void a(T t0, int i) {
+        this.c(this.c + 1);
+        if (i != this.c) {
+            System.arraycopy(this.b, i, this.b, i + 1, this.c - i);
+        }
+
+        this.b[i] = t0;
+        ++this.c;
+    }
+
+    private void d(int i) {
+        --this.c;
+        if (i != this.c) {
+            System.arraycopy(this.b, i + 1, this.b, i, this.c - i);
+        }
+
+        this.b[this.c] = null;
+    }
+
+    private T e(int i) {
+        return this.b[i];
+    }
+
+    public T a(T t0) {
+        int i = this.c(t0);
+
+        if (i >= 0) {
+            return this.e(i);
+        } else {
+            this.a(t0, b(i));
+            return t0;
+        }
+    }
+
+    public boolean remove(Object object) {
+        int i = this.c(object);
+
+        if (i >= 0) {
+            this.d(i);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public T b() {
+        return this.e(0);
+    }
+
+    public boolean contains(Object object) {
+        int i = this.c(object);
+
+        return i >= 0;
+    }
+
+    public Iterator<T> iterator() {
+        return new ArraySetSorted.a();
+    }
+
+    public int size() {
+        return this.c;
+    }
+
+    public Object[] toArray() {
+        return (Object[]) this.b.clone();
+    }
+
+    public <U> U[] toArray(U[] au) {
+        if (au.length < this.c) {
+            return (Object[]) Arrays.copyOf(this.b, this.c, au.getClass());
+        } else {
+            System.arraycopy(this.b, 0, au, 0, this.c);
+            if (au.length > this.c) {
+                au[this.c] = null;
+            }
+
+            return au;
+        }
+    }
+
+    public void clear() {
+        Arrays.fill(this.b, 0, this.c, (Object) null);
+        this.c = 0;
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else {
+            if (object instanceof ArraySetSorted) {
+                ArraySetSorted<?> arraysetsorted = (ArraySetSorted) object;
+
+                if (this.a.equals(arraysetsorted.a)) {
+                    return this.c == arraysetsorted.c && Arrays.equals(this.b, arraysetsorted.b);
+                }
+            }
+
+            return super.equals(object);
+        }
+    }
+
+    class a implements Iterator<T> {
+
+        private int b;
+        private int c;
+
+        private a() {
+            this.c = -1;
+        }
+
+        public boolean hasNext() {
+            return this.b < ArraySetSorted.this.c;
+        }
+
+        public T next() {
+            if (this.b >= ArraySetSorted.this.c) {
+                throw new NoSuchElementException();
+            } else {
+                this.c = this.b++;
+                return ArraySetSorted.this.b[this.c];
+            }
+        }
+
+        public void remove() {
+            if (this.c == -1) {
+                throw new IllegalStateException();
+            } else {
+                ArraySetSorted.this.d(this.c);
+                --this.b;
+                this.c = -1;
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/util/DataBits.java b/src/main/java/net/minecraft/util/DataBits.java
new file mode 100644
index 0000000000000000000000000000000000000000..54974a941a334dc0c8e62ffb8ca094772888b8fa
--- /dev/null
+++ b/src/main/java/net/minecraft/util/DataBits.java
@@ -0,0 +1,114 @@
+package net.minecraft.util;
+
+import java.util.function.IntConsumer;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private static final int[] a = new int[]{-1, -1, 0, Integer.MIN_VALUE, 0, 0, 1431655765, 1431655765, 0, Integer.MIN_VALUE, 0, 1, 858993459, 858993459, 0, 715827882, 715827882, 0, 613566756, 613566756, 0, Integer.MIN_VALUE, 0, 2, 477218588, 477218588, 0, 429496729, 429496729, 0, 390451572, 390451572, 0, 357913941, 357913941, 0, 330382099, 330382099, 0, 306783378, 306783378, 0, 286331153, 286331153, 0, Integer.MIN_VALUE, 0, 3, 252645135, 252645135, 0, 238609294, 238609294, 0, 226050910, 226050910, 0, 214748364, 214748364, 0, 204522252, 204522252, 0, 195225786, 195225786, 0, 186737708, 186737708, 0, 178956970, 178956970, 0, 171798691, 171798691, 0, 165191049, 165191049, 0, 159072862, 159072862, 0, 153391689, 153391689, 0, 148102320, 148102320, 0, 143165576, 143165576, 0, 138547332, 138547332, 0, Integer.MIN_VALUE, 0, 4, 130150524, 130150524, 0, 126322567, 126322567, 0, 122713351, 122713351, 0, 119304647, 119304647, 0, 116080197, 116080197, 0, 113025455, 113025455, 0, 110127366, 110127366, 0, 107374182, 107374182, 0, 104755299, 104755299, 0, 102261126, 102261126, 0, 99882960, 99882960, 0, 97612893, 97612893, 0, 95443717, 95443717, 0, 93368854, 93368854, 0, 91382282, 91382282, 0, 89478485, 89478485, 0, 87652393, 87652393, 0, 85899345, 85899345, 0, 84215045, 84215045, 0, 82595524, 82595524, 0, 81037118, 81037118, 0, 79536431, 79536431, 0, 78090314, 78090314, 0, 76695844, 76695844, 0, 75350303, 75350303, 0, 74051160, 74051160, 0, 72796055, 72796055, 0, 71582788, 71582788, 0, 70409299, 70409299, 0, 69273666, 69273666, 0, 68174084, 68174084, 0, Integer.MIN_VALUE, 0, 5};
+    private final long[] b;
+    private final int c;
+    private final long d;
+    private final int e;
+    private final int f;
+    private final int g;
+    private final int h;
+    private final int i;
+
+    public DataBits(int i, int j) {
+        this(i, j, (long[]) null);
+    }
+
+    public DataBits(int i, int j, @Nullable long[] along) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.e = j;
+        this.c = i;
+        this.d = (1L << i) - 1L;
+        this.f = (char) (64 / i);
+        int k = 3 * (this.f - 1);
+
+        this.g = DataBits.a[k + 0];
+        this.h = DataBits.a[k + 1];
+        this.i = DataBits.a[k + 2];
+        int l = (j + this.f - 1) / this.f;
+
+        if (along != null) {
+            if (along.length != l) {
+                throw (RuntimeException) SystemUtils.c((Throwable) (new RuntimeException("Invalid length given for storage, got: " + along.length + " but expected: " + l)));
+            }
+
+            this.b = along;
+        } else {
+            this.b = new long[l];
+        }
+
+    }
+
+    private int b(int i) {
+        long j = Integer.toUnsignedLong(this.g);
+        long k = Integer.toUnsignedLong(this.h);
+
+        return (int) ((long) i * j + k >> 32 >> this.i);
+    }
+
+    public int a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.e - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.d, (long) j);
+        int k = this.b(i);
+        long l = this.b[k];
+        int i1 = (i - k * this.f) * this.c;
+        int j1 = (int) (l >> i1 & this.d);
+
+        this.b[k] = l & ~(this.d << i1) | ((long) j & this.d) << i1;
+        return j1;
+    }
+
+    public void b(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.e - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.d, (long) j);
+        int k = this.b(i);
+        long l = this.b[k];
+        int i1 = (i - k * this.f) * this.c;
+
+        this.b[k] = l & ~(this.d << i1) | ((long) j & this.d) << i1;
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.e - 1), (long) i);
+        int j = this.b(i);
+        long k = this.b[j];
+        int l = (i - j * this.f) * this.c;
+
+        return (int) (k >> l & this.d);
+    }
+
+    public long[] a() {
+        return this.b;
+    }
+
+    public int b() {
+        return this.e;
+    }
+
+    public void a(IntConsumer intconsumer) {
+        int i = 0;
+        long[] along = this.b;
+        int j = along.length;
+
+        for (int k = 0; k < j; ++k) {
+            long l = along[k];
+
+            for (int i1 = 0; i1 < this.f; ++i1) {
+                intconsumer.accept((int) (l & this.d));
+                l >>= this.c;
+                ++i;
+                if (i >= this.e) {
+                    return;
+                }
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/util/MathHelper.java b/src/main/java/net/minecraft/util/MathHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..caa628417bb9c1c65b037e4f3f762b08272c6d09
--- /dev/null
+++ b/src/main/java/net/minecraft/util/MathHelper.java
@@ -0,0 +1,469 @@
+package net.minecraft.util;
+
+import java.util.Random;
+import java.util.UUID;
+import java.util.function.IntPredicate;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BaseBlockPosition;
+
+public class MathHelper {
+
+    public static final float a = c(2.0F);
+    private static final float[] b = (float[]) SystemUtils.a((Object) (new float[65536]), (afloat) -> {
+        for (int i = 0; i < afloat.length; ++i) {
+            afloat[i] = (float) Math.sin((double) i * 3.141592653589793D * 2.0D / 65536.0D);
+        }
+
+    });
+    private static final Random c = new Random();
+    private static final int[] d = new int[]{0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};
+    private static final double e = Double.longBitsToDouble(4805340802404319232L);
+    private static final double[] f = new double[257];
+    private static final double[] g = new double[257];
+
+    public static float sin(float f) {
+        return MathHelper.b[(int) (f * 10430.378F) & '\uffff'];
+    }
+
+    public static float cos(float f) {
+        return MathHelper.b[(int) (f * 10430.378F + 16384.0F) & '\uffff'];
+    }
+
+    public static float c(float f) {
+        return (float) Math.sqrt((double) f);
+    }
+
+    public static float sqrt(double d0) {
+        return (float) Math.sqrt(d0);
+    }
+
+    public static int d(float f) {
+        int i = (int) f;
+
+        return f < (float) i ? i - 1 : i;
+    }
+
+    public static int floor(double d0) {
+        int i = (int) d0;
+
+        return d0 < (double) i ? i - 1 : i;
+    }
+
+    public static long d(double d0) {
+        long i = (long) d0;
+
+        return d0 < (double) i ? i - 1L : i;
+    }
+
+    public static float e(float f) {
+        return Math.abs(f);
+    }
+
+    public static int a(int i) {
+        return Math.abs(i);
+    }
+
+    public static int f(float f) {
+        int i = (int) f;
+
+        return f > (float) i ? i + 1 : i;
+    }
+
+    public static int f(double d0) {
+        int i = (int) d0;
+
+        return d0 > (double) i ? i + 1 : i;
+    }
+
+    public static int clamp(int i, int j, int k) {
+        return i < j ? j : (i > k ? k : i);
+    }
+
+    public static float a(float f, float f1, float f2) {
+        return f < f1 ? f1 : (f > f2 ? f2 : f);
+    }
+
+    public static double a(double d0, double d1, double d2) {
+        return d0 < d1 ? d1 : (d0 > d2 ? d2 : d0);
+    }
+
+    public static double b(double d0, double d1, double d2) {
+        return d2 < 0.0D ? d0 : (d2 > 1.0D ? d1 : d(d2, d0, d1));
+    }
+
+    public static double a(double d0, double d1) {
+        if (d0 < 0.0D) {
+            d0 = -d0;
+        }
+
+        if (d1 < 0.0D) {
+            d1 = -d1;
+        }
+
+        return d0 > d1 ? d0 : d1;
+    }
+
+    public static int a(int i, int j) {
+        return Math.floorDiv(i, j);
+    }
+
+    public static int nextInt(Random random, int i, int j) {
+        return i >= j ? i : random.nextInt(j - i + 1) + i;
+    }
+
+    public static float a(Random random, float f, float f1) {
+        return f >= f1 ? f : random.nextFloat() * (f1 - f) + f;
+    }
+
+    public static double a(Random random, double d0, double d1) {
+        return d0 >= d1 ? d0 : random.nextDouble() * (d1 - d0) + d0;
+    }
+
+    public static double a(long[] along) {
+        long i = 0L;
+        long[] along1 = along;
+        int j = along.length;
+
+        for (int k = 0; k < j; ++k) {
+            long l = along1[k];
+
+            i += l;
+        }
+
+        return (double) i / (double) along.length;
+    }
+
+    public static boolean b(double d0, double d1) {
+        return Math.abs(d1 - d0) < 9.999999747378752E-6D;
+    }
+
+    public static int b(int i, int j) {
+        return Math.floorMod(i, j);
+    }
+
+    public static float g(float f) {
+        float f1 = f % 360.0F;
+
+        if (f1 >= 180.0F) {
+            f1 -= 360.0F;
+        }
+
+        if (f1 < -180.0F) {
+            f1 += 360.0F;
+        }
+
+        return f1;
+    }
+
+    public static double g(double d0) {
+        double d1 = d0 % 360.0D;
+
+        if (d1 >= 180.0D) {
+            d1 -= 360.0D;
+        }
+
+        if (d1 < -180.0D) {
+            d1 += 360.0D;
+        }
+
+        return d1;
+    }
+
+    public static float c(float f, float f1) {
+        return g(f1 - f);
+    }
+
+    public static float d(float f, float f1) {
+        return e(c(f, f1));
+    }
+
+    public static float b(float f, float f1, float f2) {
+        float f3 = c(f, f1);
+        float f4 = a(f3, -f2, f2);
+
+        return f1 - f4;
+    }
+
+    public static float c(float f, float f1, float f2) {
+        f2 = e(f2);
+        return f < f1 ? a(f + f2, f, f1) : a(f - f2, f1, f);
+    }
+
+    public static float d(float f, float f1, float f2) {
+        float f3 = c(f, f1);
+
+        return c(f, f + f3, f2);
+    }
+
+    public static int c(int i) {
+        int j = i - 1;
+
+        j |= j >> 1;
+        j |= j >> 2;
+        j |= j >> 4;
+        j |= j >> 8;
+        j |= j >> 16;
+        return j + 1;
+    }
+
+    public static boolean d(int i) {
+        return i != 0 && (i & i - 1) == 0;
+    }
+
+    public static int e(int i) {
+        i = d(i) ? i : c(i);
+        return MathHelper.d[(int) ((long) i * 125613361L >> 27) & 31];
+    }
+
+    public static int f(int i) {
+        return e(i) - (d(i) ? 0 : 1);
+    }
+
+    public static int c(int i, int j) {
+        if (j == 0) {
+            return 0;
+        } else if (i == 0) {
+            return j;
+        } else {
+            if (i < 0) {
+                j *= -1;
+            }
+
+            int k = i % j;
+
+            return k == 0 ? i : i + j - k;
+        }
+    }
+
+    public static float h(float f) {
+        return f - (float) d(f);
+    }
+
+    public static double h(double d0) {
+        return d0 - (double) d(d0);
+    }
+
+    public static long a(BaseBlockPosition baseblockposition) {
+        return c(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public static long c(int i, int j, int k) {
+        long l = (long) (i * 3129871) ^ (long) k * 116129781L ^ (long) j;
+
+        l = l * l * 42317861L + l * 11L;
+        return l >> 16;
+    }
+
+    public static UUID a(Random random) {
+        long i = random.nextLong() & -61441L | 16384L;
+        long j = random.nextLong() & 4611686018427387903L | Long.MIN_VALUE;
+
+        return new UUID(i, j);
+    }
+
+    public static UUID a() {
+        return a(MathHelper.c);
+    }
+
+    public static double c(double d0, double d1, double d2) {
+        return (d0 - d1) / (d2 - d1);
+    }
+
+    public static double d(double d0, double d1) {
+        double d2 = d1 * d1 + d0 * d0;
+
+        if (Double.isNaN(d2)) {
+            return Double.NaN;
+        } else {
+            boolean flag = d0 < 0.0D;
+
+            if (flag) {
+                d0 = -d0;
+            }
+
+            boolean flag1 = d1 < 0.0D;
+
+            if (flag1) {
+                d1 = -d1;
+            }
+
+            boolean flag2 = d0 > d1;
+            double d3;
+
+            if (flag2) {
+                d3 = d1;
+                d1 = d0;
+                d0 = d3;
+            }
+
+            d3 = i(d2);
+            d1 *= d3;
+            d0 *= d3;
+            double d4 = MathHelper.e + d0;
+            int i = (int) Double.doubleToRawLongBits(d4);
+            double d5 = MathHelper.f[i];
+            double d6 = MathHelper.g[i];
+            double d7 = d4 - MathHelper.e;
+            double d8 = d0 * d6 - d1 * d7;
+            double d9 = (6.0D + d8 * d8) * d8 * 0.16666666666666666D;
+            double d10 = d5 + d9;
+
+            if (flag2) {
+                d10 = 1.5707963267948966D - d10;
+            }
+
+            if (flag1) {
+                d10 = 3.141592653589793D - d10;
+            }
+
+            if (flag) {
+                d10 = -d10;
+            }
+
+            return d10;
+        }
+    }
+
+    public static double i(double d0) {
+        double d1 = 0.5D * d0;
+        long i = Double.doubleToRawLongBits(d0);
+
+        i = 6910469410427058090L - (i >> 1);
+        d0 = Double.longBitsToDouble(i);
+        d0 *= 1.5D - d1 * d0 * d0;
+        return d0;
+    }
+
+    public static int f(float f, float f1, float f2) {
+        int i = (int) (f * 6.0F) % 6;
+        float f3 = f * 6.0F - (float) i;
+        float f4 = f2 * (1.0F - f1);
+        float f5 = f2 * (1.0F - f3 * f1);
+        float f6 = f2 * (1.0F - (1.0F - f3) * f1);
+        float f7;
+        float f8;
+        float f9;
+
+        switch (i) {
+            case 0:
+                f7 = f2;
+                f8 = f6;
+                f9 = f4;
+                break;
+            case 1:
+                f7 = f5;
+                f8 = f2;
+                f9 = f4;
+                break;
+            case 2:
+                f7 = f4;
+                f8 = f2;
+                f9 = f6;
+                break;
+            case 3:
+                f7 = f4;
+                f8 = f5;
+                f9 = f2;
+                break;
+            case 4:
+                f7 = f6;
+                f8 = f4;
+                f9 = f2;
+                break;
+            case 5:
+                f7 = f2;
+                f8 = f4;
+                f9 = f5;
+                break;
+            default:
+                throw new RuntimeException("Something went wrong when converting from HSV to RGB. Input was " + f + ", " + f1 + ", " + f2);
+        }
+
+        int j = clamp((int) (f7 * 255.0F), 0, 255);
+        int k = clamp((int) (f8 * 255.0F), 0, 255);
+        int l = clamp((int) (f9 * 255.0F), 0, 255);
+
+        return j << 16 | k << 8 | l;
+    }
+
+    public static int g(int i) {
+        i ^= i >>> 16;
+        i *= -2048144789;
+        i ^= i >>> 13;
+        i *= -1028477387;
+        i ^= i >>> 16;
+        return i;
+    }
+
+    public static int a(int i, int j, IntPredicate intpredicate) {
+        int k = j - i;
+
+        while (k > 0) {
+            int l = k / 2;
+            int i1 = i + l;
+
+            if (intpredicate.test(i1)) {
+                k = l;
+            } else {
+                i = i1 + 1;
+                k -= l + 1;
+            }
+        }
+
+        return i;
+    }
+
+    public static float g(float f, float f1, float f2) {
+        return f1 + f * (f2 - f1);
+    }
+
+    public static double d(double d0, double d1, double d2) {
+        return d1 + d0 * (d2 - d1);
+    }
+
+    public static double a(double d0, double d1, double d2, double d3, double d4, double d5) {
+        return d(d1, d(d0, d2, d3), d(d0, d4, d5));
+    }
+
+    public static double a(double d0, double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10) {
+        return d(d2, a(d0, d1, d3, d4, d5, d6), a(d0, d1, d7, d8, d9, d10));
+    }
+
+    public static double j(double d0) {
+        return d0 * d0 * d0 * (d0 * (d0 * 6.0D - 15.0D) + 10.0D);
+    }
+
+    public static int k(double d0) {
+        return d0 == 0.0D ? 0 : (d0 > 0.0D ? 1 : -1);
+    }
+
+    @Deprecated
+    public static float j(float f, float f1, float f2) {
+        float f3;
+
+        for (f3 = f1 - f; f3 < -180.0F; f3 += 360.0F) {
+            ;
+        }
+
+        while (f3 >= 180.0F) {
+            f3 -= 360.0F;
+        }
+
+        return f + f2 * f3;
+    }
+
+    public static float k(float f) {
+        return f * f;
+    }
+
+    static {
+        for (int i = 0; i < 257; ++i) {
+            double d0 = (double) i / 256.0D;
+            double d1 = Math.asin(d0);
+
+            MathHelper.g[i] = Math.cos(d1);
+            MathHelper.f[i] = d1;
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/util/RegistryID.java b/src/main/java/net/minecraft/util/RegistryID.java
new file mode 100644
index 0000000000000000000000000000000000000000..d88e55c64f80707b4a9b1e271714c2dbdee9a38a
--- /dev/null
+++ b/src/main/java/net/minecraft/util/RegistryID.java
@@ -0,0 +1,158 @@
+package net.minecraft.util;
+
+import com.google.common.base.Predicates;
+import com.google.common.collect.Iterators;
+import java.util.Arrays;
+import java.util.Iterator;
+import javax.annotation.Nullable;
+import net.minecraft.core.Registry;
+
+public class RegistryID<K> implements Registry<K> {
+
+    private static final Object a = null;
+    private K[] b;
+    private int[] c;
+    private K[] d;
+    private int e;
+    private int f;
+
+    public RegistryID(int i) {
+        i = (int) ((float) i / 0.8F);
+        this.b = (Object[]) (new Object[i]);
+        this.c = new int[i];
+        this.d = (Object[]) (new Object[i]);
+    }
+
+    public int getId(@Nullable K k0) {
+        return this.c(this.b(k0, this.d(k0)));
+    }
+
+    @Nullable
+    @Override
+    public K fromId(int i) {
+        return i >= 0 && i < this.d.length ? this.d[i] : null;
+    }
+
+    private int c(int i) {
+        return i == -1 ? -1 : this.c[i];
+    }
+
+    public int c(K k0) {
+        int i = this.c();
+
+        this.a(k0, i);
+        return i;
+    }
+
+    private int c() {
+        while (this.e < this.d.length && this.d[this.e] != null) {
+            ++this.e;
+        }
+
+        return this.e;
+    }
+
+    private void d(int i) {
+        K[] ak = this.b;
+        int[] aint = this.c;
+
+        this.b = (Object[]) (new Object[i]);
+        this.c = new int[i];
+        this.d = (Object[]) (new Object[i]);
+        this.e = 0;
+        this.f = 0;
+
+        for (int j = 0; j < ak.length; ++j) {
+            if (ak[j] != null) {
+                this.a(ak[j], aint[j]);
+            }
+        }
+
+    }
+
+    public void a(K k0, int i) {
+        int j = Math.max(i, this.f + 1);
+        int k;
+
+        if ((float) j >= (float) this.b.length * 0.8F) {
+            for (k = this.b.length << 1; k < i; k <<= 1) {
+                ;
+            }
+
+            this.d(k);
+        }
+
+        k = this.e(this.d(k0));
+        this.b[k] = k0;
+        this.c[k] = i;
+        this.d[i] = k0;
+        ++this.f;
+        if (i == this.e) {
+            ++this.e;
+        }
+
+    }
+
+    private int d(@Nullable K k0) {
+        return (MathHelper.g(System.identityHashCode(k0)) & Integer.MAX_VALUE) % this.b.length;
+    }
+
+    private int b(@Nullable K k0, int i) {
+        int j;
+
+        for (j = i; j < this.b.length; ++j) {
+            if (this.b[j] == k0) {
+                return j;
+            }
+
+            if (this.b[j] == RegistryID.a) {
+                return -1;
+            }
+        }
+
+        for (j = 0; j < i; ++j) {
+            if (this.b[j] == k0) {
+                return j;
+            }
+
+            if (this.b[j] == RegistryID.a) {
+                return -1;
+            }
+        }
+
+        return -1;
+    }
+
+    private int e(int i) {
+        int j;
+
+        for (j = i; j < this.b.length; ++j) {
+            if (this.b[j] == RegistryID.a) {
+                return j;
+            }
+        }
+
+        for (j = 0; j < i; ++j) {
+            if (this.b[j] == RegistryID.a) {
+                return j;
+            }
+        }
+
+        throw new RuntimeException("Overflowed :(");
+    }
+
+    public Iterator<K> iterator() {
+        return Iterators.filter(Iterators.forArray(this.d), Predicates.notNull());
+    }
+
+    public void a() {
+        Arrays.fill(this.b, (Object) null);
+        Arrays.fill(this.d, (Object) null);
+        this.e = 0;
+        this.f = 0;
+    }
+
+    public int b() {
+        return this.f;
+    }
+}
diff --git a/src/main/java/net/minecraft/util/thread/IAsyncTaskHandler.java b/src/main/java/net/minecraft/util/thread/IAsyncTaskHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..6abf1459cc97c261daf3c116521574d31a77a338
--- /dev/null
+++ b/src/main/java/net/minecraft/util/thread/IAsyncTaskHandler.java
@@ -0,0 +1,133 @@
+package net.minecraft.util.thread;
+
+import com.google.common.collect.Queues;
+import java.util.Queue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.concurrent.locks.LockSupport;
+import java.util.function.BooleanSupplier;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public abstract class IAsyncTaskHandler<R extends Runnable> implements Mailbox<R>, Executor {
+
+    private final String b;
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final Queue<R> d = Queues.newConcurrentLinkedQueue();
+    private int e;
+
+    protected IAsyncTaskHandler(String s) {
+        this.b = s;
+    }
+
+    protected abstract R postToMainThread(Runnable runnable);
+
+    protected abstract boolean canExecute(R r0);
+
+    public boolean isMainThread() {
+        return Thread.currentThread() == this.getThread();
+    }
+
+    protected abstract Thread getThread();
+
+    protected boolean isNotMainThread() {
+        return !this.isMainThread();
+    }
+
+    public int bi() {
+        return this.d.size();
+    }
+
+    @Override
+    public String bj() {
+        return this.b;
+    }
+
+    private CompletableFuture<Void> executeFuture(Runnable runnable) {
+        return CompletableFuture.supplyAsync(() -> {
+            runnable.run();
+            return null;
+        }, this);
+    }
+
+    public CompletableFuture<Void> f(Runnable runnable) {
+        if (this.isNotMainThread()) {
+            return this.executeFuture(runnable);
+        } else {
+            runnable.run();
+            return CompletableFuture.completedFuture((Object) null);
+        }
+    }
+
+    public void executeSync(Runnable runnable) {
+        if (!this.isMainThread()) {
+            this.executeFuture(runnable).join();
+        } else {
+            runnable.run();
+        }
+
+    }
+
+    public void a(R r0) {
+        this.d.add(r0);
+        LockSupport.unpark(this.getThread());
+    }
+
+    public void execute(Runnable runnable) {
+        if (this.isNotMainThread()) {
+            this.a(this.postToMainThread(runnable));
+        } else {
+            runnable.run();
+        }
+
+    }
+
+    protected void executeAll() {
+        while (this.executeNext()) {
+            ;
+        }
+
+    }
+
+    protected boolean executeNext() {
+        R r0 = (Runnable) this.d.peek();
+
+        if (r0 == null) {
+            return false;
+        } else if (this.e == 0 && !this.canExecute(r0)) {
+            return false;
+        } else {
+            this.executeTask((Runnable) this.d.remove());
+            return true;
+        }
+    }
+
+    public void awaitTasks(BooleanSupplier booleansupplier) {
+        ++this.e;
+
+        try {
+            while (!booleansupplier.getAsBoolean()) {
+                if (!this.executeNext()) {
+                    this.bm();
+                }
+            }
+        } finally {
+            --this.e;
+        }
+
+    }
+
+    protected void bm() {
+        Thread.yield();
+        LockSupport.parkNanos("waiting for tasks", 100000L);
+    }
+
+    protected void executeTask(R r0) {
+        try {
+            r0.run();
+        } catch (Exception exception) {
+            IAsyncTaskHandler.LOGGER.fatal("Error executing task on {}", this.bj(), exception);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/util/thread/PairedQueue.java b/src/main/java/net/minecraft/util/thread/PairedQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..024b414aae32c8ad32bdf031361257fc74b80eb3
--- /dev/null
+++ b/src/main/java/net/minecraft/util/thread/PairedQueue.java
@@ -0,0 +1,107 @@
+package net.minecraft.util.thread;
+
+import com.google.common.collect.Queues;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import javax.annotation.Nullable;
+
+public interface PairedQueue<T, F> {
+
+    @Nullable
+    F a();
+
+    boolean a(T t0);
+
+    boolean b();
+
+    public static final class a implements PairedQueue<PairedQueue.b, Runnable> {
+
+        private final List<Queue<Runnable>> a;
+
+        public a(int i) {
+            this.a = (List) IntStream.range(0, i).mapToObj((j) -> {
+                return Queues.newConcurrentLinkedQueue();
+            }).collect(Collectors.toList());
+        }
+
+        @Nullable
+        @Override
+        public Runnable a() {
+            Iterator iterator = this.a.iterator();
+
+            Runnable runnable;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return null;
+                }
+
+                Queue<Runnable> queue = (Queue) iterator.next();
+
+                runnable = (Runnable) queue.poll();
+            } while (runnable == null);
+
+            return runnable;
+        }
+
+        public boolean a(PairedQueue.b pairedqueue_b) {
+            int i = pairedqueue_b.a();
+
+            ((Queue) this.a.get(i)).add(pairedqueue_b);
+            return true;
+        }
+
+        @Override
+        public boolean b() {
+            return this.a.stream().allMatch(Collection::isEmpty);
+        }
+    }
+
+    public static final class b implements Runnable {
+
+        private final int a;
+        private final Runnable b;
+
+        public b(int i, Runnable runnable) {
+            this.a = i;
+            this.b = runnable;
+        }
+
+        public void run() {
+            this.b.run();
+        }
+
+        public int a() {
+            return this.a;
+        }
+    }
+
+    public static final class c<T> implements PairedQueue<T, T> {
+
+        private final Queue<T> a;
+
+        public c(Queue<T> queue) {
+            this.a = queue;
+        }
+
+        @Nullable
+        @Override
+        public T a() {
+            return this.a.poll();
+        }
+
+        @Override
+        public boolean a(T t0) {
+            return this.a.add(t0);
+        }
+
+        @Override
+        public boolean b() {
+            return this.a.isEmpty();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/util/thread/ThreadedMailbox.java b/src/main/java/net/minecraft/util/thread/ThreadedMailbox.java
new file mode 100644
index 0000000000000000000000000000000000000000..e872e5c9157ca499491042040f0cc0f14f7d2946
--- /dev/null
+++ b/src/main/java/net/minecraft/util/thread/ThreadedMailbox.java
@@ -0,0 +1,152 @@
+package net.minecraft.util.thread;
+
+import it.unimi.dsi.fastutil.ints.Int2BooleanFunction;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executor;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import net.minecraft.SharedConstants;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ThreadedMailbox<T> implements Mailbox<T>, AutoCloseable, Runnable {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final AtomicInteger c = new AtomicInteger(0);
+    public final PairedQueue<? super T, ? extends Runnable> a;
+    private final Executor d;
+    private final String e;
+
+    public static ThreadedMailbox<Runnable> a(Executor executor, String s) {
+        return new ThreadedMailbox<>(new PairedQueue.c<>(new ConcurrentLinkedQueue()), executor, s);
+    }
+
+    public ThreadedMailbox(PairedQueue<? super T, ? extends Runnable> pairedqueue, Executor executor, String s) {
+        this.d = executor;
+        this.a = pairedqueue;
+        this.e = s;
+    }
+
+    private boolean a() {
+        int i;
+
+        do {
+            i = this.c.get();
+            if ((i & 3) != 0) {
+                return false;
+            }
+        } while (!this.c.compareAndSet(i, i | 2));
+
+        return true;
+    }
+
+    private void b() {
+        int i;
+
+        do {
+            i = this.c.get();
+        } while (!this.c.compareAndSet(i, i & -3));
+
+    }
+
+    private boolean c() {
+        return (this.c.get() & 1) != 0 ? false : !this.a.b();
+    }
+
+    @Override
+    public void close() {
+        int i;
+
+        do {
+            i = this.c.get();
+        } while (!this.c.compareAndSet(i, i | 1));
+
+    }
+
+    private boolean d() {
+        return (this.c.get() & 2) != 0;
+    }
+
+    private boolean e() {
+        if (!this.d()) {
+            return false;
+        } else {
+            Runnable runnable = (Runnable) this.a.a();
+
+            if (runnable == null) {
+                return false;
+            } else {
+                Thread thread;
+                String s;
+
+                if (SharedConstants.d) {
+                    thread = Thread.currentThread();
+                    s = thread.getName();
+                    thread.setName(this.e);
+                } else {
+                    thread = null;
+                    s = null;
+                }
+
+                runnable.run();
+                if (thread != null) {
+                    thread.setName(s);
+                }
+
+                return true;
+            }
+        }
+    }
+
+    public void run() {
+        try {
+            this.a((i) -> {
+                return i == 0;
+            });
+        } finally {
+            this.b();
+            this.f();
+        }
+
+    }
+
+    @Override
+    public void a(T t0) {
+        this.a.a(t0);
+        this.f();
+    }
+
+    private void f() {
+        if (this.c() && this.a()) {
+            try {
+                this.d.execute(this);
+            } catch (RejectedExecutionException rejectedexecutionexception) {
+                try {
+                    this.d.execute(this);
+                } catch (RejectedExecutionException rejectedexecutionexception1) {
+                    ThreadedMailbox.LOGGER.error("Cound not schedule mailbox", rejectedexecutionexception1);
+                }
+            }
+        }
+
+    }
+
+    private int a(Int2BooleanFunction int2booleanfunction) {
+        int i;
+
+        for (i = 0; int2booleanfunction.get(i) && this.e(); ++i) {
+            ;
+        }
+
+        return i;
+    }
+
+    public String toString() {
+        return this.e + " " + this.c.get() + " " + this.a.b();
+    }
+
+    @Override
+    public String bj() {
+        return this.e;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/BossBattle.java b/src/main/java/net/minecraft/world/BossBattle.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3c21e73f54c7312dd2e260079d727224fc08256
--- /dev/null
+++ b/src/main/java/net/minecraft/world/BossBattle.java
@@ -0,0 +1,154 @@
+package net.minecraft.world;
+
+import java.util.UUID;
+import net.minecraft.EnumChatFormat;
+import net.minecraft.network.chat.IChatBaseComponent;
+
+public abstract class BossBattle {
+
+    private final UUID h;
+    public IChatBaseComponent title;
+    protected float b;
+    public BossBattle.BarColor color;
+    public BossBattle.BarStyle style;
+    protected boolean e;
+    protected boolean f;
+    protected boolean g;
+
+    public BossBattle(UUID uuid, IChatBaseComponent ichatbasecomponent, BossBattle.BarColor bossbattle_barcolor, BossBattle.BarStyle bossbattle_barstyle) {
+        this.h = uuid;
+        this.title = ichatbasecomponent;
+        this.color = bossbattle_barcolor;
+        this.style = bossbattle_barstyle;
+        this.b = 1.0F;
+    }
+
+    public UUID i() {
+        return this.h;
+    }
+
+    public IChatBaseComponent j() {
+        return this.title;
+    }
+
+    public void a(IChatBaseComponent ichatbasecomponent) {
+        this.title = ichatbasecomponent;
+    }
+
+    public float getProgress() {
+        return this.b;
+    }
+
+    public void setProgress(float f) {
+        this.b = f;
+    }
+
+    public BossBattle.BarColor l() {
+        return this.color;
+    }
+
+    public void a(BossBattle.BarColor bossbattle_barcolor) {
+        this.color = bossbattle_barcolor;
+    }
+
+    public BossBattle.BarStyle m() {
+        return this.style;
+    }
+
+    public void a(BossBattle.BarStyle bossbattle_barstyle) {
+        this.style = bossbattle_barstyle;
+    }
+
+    public boolean isDarkenSky() {
+        return this.e;
+    }
+
+    public BossBattle setDarkenSky(boolean flag) {
+        this.e = flag;
+        return this;
+    }
+
+    public boolean isPlayMusic() {
+        return this.f;
+    }
+
+    public BossBattle setPlayMusic(boolean flag) {
+        this.f = flag;
+        return this;
+    }
+
+    public BossBattle setCreateFog(boolean flag) {
+        this.g = flag;
+        return this;
+    }
+
+    public boolean isCreateFog() {
+        return this.g;
+    }
+
+    public static enum BarStyle {
+
+        PROGRESS("progress"), NOTCHED_6("notched_6"), NOTCHED_10("notched_10"), NOTCHED_12("notched_12"), NOTCHED_20("notched_20");
+
+        private final String f;
+
+        private BarStyle(String s) {
+            this.f = s;
+        }
+
+        public String a() {
+            return this.f;
+        }
+
+        public static BossBattle.BarStyle a(String s) {
+            BossBattle.BarStyle[] abossbattle_barstyle = values();
+            int i = abossbattle_barstyle.length;
+
+            for (int j = 0; j < i; ++j) {
+                BossBattle.BarStyle bossbattle_barstyle = abossbattle_barstyle[j];
+
+                if (bossbattle_barstyle.f.equals(s)) {
+                    return bossbattle_barstyle;
+                }
+            }
+
+            return BossBattle.BarStyle.PROGRESS;
+        }
+    }
+
+    public static enum BarColor {
+
+        PINK("pink", EnumChatFormat.RED), BLUE("blue", EnumChatFormat.BLUE), RED("red", EnumChatFormat.DARK_RED), GREEN("green", EnumChatFormat.GREEN), YELLOW("yellow", EnumChatFormat.YELLOW), PURPLE("purple", EnumChatFormat.DARK_BLUE), WHITE("white", EnumChatFormat.WHITE);
+
+        private final String h;
+        private final EnumChatFormat i;
+
+        private BarColor(String s, EnumChatFormat enumchatformat) {
+            this.h = s;
+            this.i = enumchatformat;
+        }
+
+        public EnumChatFormat a() {
+            return this.i;
+        }
+
+        public String b() {
+            return this.h;
+        }
+
+        public static BossBattle.BarColor a(String s) {
+            BossBattle.BarColor[] abossbattle_barcolor = values();
+            int i = abossbattle_barcolor.length;
+
+            for (int j = 0; j < i; ++j) {
+                BossBattle.BarColor bossbattle_barcolor = abossbattle_barcolor[j];
+
+                if (bossbattle_barcolor.h.equals(s)) {
+                    return bossbattle_barcolor;
+                }
+            }
+
+            return BossBattle.BarColor.WHITE;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/InteractionResultWrapper.java b/src/main/java/net/minecraft/world/InteractionResultWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd17c111670e637b574f5c7f38d27848900ce194
--- /dev/null
+++ b/src/main/java/net/minecraft/world/InteractionResultWrapper.java
@@ -0,0 +1,40 @@
+package net.minecraft.world;
+
+public class InteractionResultWrapper<T> {
+
+    private final EnumInteractionResult a;
+    private final T b;
+
+    public InteractionResultWrapper(EnumInteractionResult enuminteractionresult, T t0) {
+        this.a = enuminteractionresult;
+        this.b = t0;
+    }
+
+    public EnumInteractionResult a() {
+        return this.a;
+    }
+
+    public T b() {
+        return this.b;
+    }
+
+    public static <T> InteractionResultWrapper<T> success(T t0) {
+        return new InteractionResultWrapper<>(EnumInteractionResult.SUCCESS, t0);
+    }
+
+    public static <T> InteractionResultWrapper<T> consume(T t0) {
+        return new InteractionResultWrapper<>(EnumInteractionResult.CONSUME, t0);
+    }
+
+    public static <T> InteractionResultWrapper<T> pass(T t0) {
+        return new InteractionResultWrapper<>(EnumInteractionResult.PASS, t0);
+    }
+
+    public static <T> InteractionResultWrapper<T> fail(T t0) {
+        return new InteractionResultWrapper<>(EnumInteractionResult.FAIL, t0);
+    }
+
+    public static <T> InteractionResultWrapper<T> a(T t0, boolean flag) {
+        return flag ? success(t0) : consume(t0);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..f6f79ed9c38206cc6a4feb5504e854a476868aec
--- /dev/null
+++ b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
@@ -0,0 +1,227 @@
+package net.minecraft.world.damagesource;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsBlock;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+
+public class CombatTracker {
+
+    private final List<CombatEntry> a = Lists.newArrayList();
+    private final EntityLiving b;
+    private int c;
+    private int d;
+    private int e;
+    private boolean f;
+    private boolean g;
+    private String h;
+
+    public CombatTracker(EntityLiving entityliving) {
+        this.b = entityliving;
+    }
+
+    public void a() {
+        this.k();
+        Optional<BlockPosition> optional = this.b.dr();
+
+        if (optional.isPresent()) {
+            IBlockData iblockdata = this.b.world.getType((BlockPosition) optional.get());
+
+            if (!iblockdata.a(Blocks.LADDER) && !iblockdata.a((Tag) TagsBlock.TRAPDOORS)) {
+                if (iblockdata.a(Blocks.VINE)) {
+                    this.h = "vines";
+                } else if (!iblockdata.a(Blocks.WEEPING_VINES) && !iblockdata.a(Blocks.WEEPING_VINES_PLANT)) {
+                    if (!iblockdata.a(Blocks.TWISTING_VINES) && !iblockdata.a(Blocks.TWISTING_VINES_PLANT)) {
+                        if (iblockdata.a(Blocks.SCAFFOLDING)) {
+                            this.h = "scaffolding";
+                        } else {
+                            this.h = "other_climbable";
+                        }
+                    } else {
+                        this.h = "twisting_vines";
+                    }
+                } else {
+                    this.h = "weeping_vines";
+                }
+            } else {
+                this.h = "ladder";
+            }
+        } else if (this.b.isInWater()) {
+            this.h = "water";
+        }
+
+    }
+
+    public void trackDamage(DamageSource damagesource, float f, float f1) {
+        this.g();
+        this.a();
+        CombatEntry combatentry = new CombatEntry(damagesource, this.b.ticksLived, f, f1, this.h, this.b.fallDistance);
+
+        this.a.add(combatentry);
+        this.c = this.b.ticksLived;
+        this.g = true;
+        if (combatentry.f() && !this.f && this.b.isAlive()) {
+            this.f = true;
+            this.d = this.b.ticksLived;
+            this.e = this.d;
+            this.b.enterCombat();
+        }
+
+    }
+
+    public IChatBaseComponent getDeathMessage() {
+        if (this.a.isEmpty()) {
+            return new ChatMessage("death.attack.generic", new Object[]{this.b.getScoreboardDisplayName()});
+        } else {
+            CombatEntry combatentry = this.j();
+            CombatEntry combatentry1 = (CombatEntry) this.a.get(this.a.size() - 1);
+            IChatBaseComponent ichatbasecomponent = combatentry1.h();
+            Entity entity = combatentry1.a().getEntity();
+            Object object;
+
+            if (combatentry != null && combatentry1.a() == DamageSource.FALL) {
+                IChatBaseComponent ichatbasecomponent1 = combatentry.h();
+
+                if (combatentry.a() != DamageSource.FALL && combatentry.a() != DamageSource.OUT_OF_WORLD) {
+                    if (ichatbasecomponent1 != null && (ichatbasecomponent == null || !ichatbasecomponent1.equals(ichatbasecomponent))) {
+                        Entity entity1 = combatentry.a().getEntity();
+                        ItemStack itemstack = entity1 instanceof EntityLiving ? ((EntityLiving) entity1).getItemInMainHand() : ItemStack.b;
+
+                        if (!itemstack.isEmpty() && itemstack.hasName()) {
+                            object = new ChatMessage("death.fell.assist.item", new Object[]{this.b.getScoreboardDisplayName(), ichatbasecomponent1, itemstack.C()});
+                        } else {
+                            object = new ChatMessage("death.fell.assist", new Object[]{this.b.getScoreboardDisplayName(), ichatbasecomponent1});
+                        }
+                    } else if (ichatbasecomponent != null) {
+                        ItemStack itemstack1 = entity instanceof EntityLiving ? ((EntityLiving) entity).getItemInMainHand() : ItemStack.b;
+
+                        if (!itemstack1.isEmpty() && itemstack1.hasName()) {
+                            object = new ChatMessage("death.fell.finish.item", new Object[]{this.b.getScoreboardDisplayName(), ichatbasecomponent, itemstack1.C()});
+                        } else {
+                            object = new ChatMessage("death.fell.finish", new Object[]{this.b.getScoreboardDisplayName(), ichatbasecomponent});
+                        }
+                    } else {
+                        object = new ChatMessage("death.fell.killer", new Object[]{this.b.getScoreboardDisplayName()});
+                    }
+                } else {
+                    object = new ChatMessage("death.fell.accident." + this.a(combatentry), new Object[]{this.b.getScoreboardDisplayName()});
+                }
+            } else {
+                object = combatentry1.a().getLocalizedDeathMessage(this.b);
+            }
+
+            return (IChatBaseComponent) object;
+        }
+    }
+
+    @Nullable
+    public EntityLiving c() {
+        EntityLiving entityliving = null;
+        EntityHuman entityhuman = null;
+        float f = 0.0F;
+        float f1 = 0.0F;
+        Iterator iterator = this.a.iterator();
+
+        while (iterator.hasNext()) {
+            CombatEntry combatentry = (CombatEntry) iterator.next();
+
+            if (combatentry.a().getEntity() instanceof EntityHuman && (entityhuman == null || combatentry.c() > f1)) {
+                f1 = combatentry.c();
+                entityhuman = (EntityHuman) combatentry.a().getEntity();
+            }
+
+            if (combatentry.a().getEntity() instanceof EntityLiving && (entityliving == null || combatentry.c() > f)) {
+                f = combatentry.c();
+                entityliving = (EntityLiving) combatentry.a().getEntity();
+            }
+        }
+
+        if (entityhuman != null && f1 >= f / 3.0F) {
+            return entityhuman;
+        } else {
+            return entityliving;
+        }
+    }
+
+    @Nullable
+    private CombatEntry j() {
+        CombatEntry combatentry = null;
+        CombatEntry combatentry1 = null;
+        float f = 0.0F;
+        float f1 = 0.0F;
+
+        for (int i = 0; i < this.a.size(); ++i) {
+            CombatEntry combatentry2 = (CombatEntry) this.a.get(i);
+            CombatEntry combatentry3 = i > 0 ? (CombatEntry) this.a.get(i - 1) : null;
+
+            if ((combatentry2.a() == DamageSource.FALL || combatentry2.a() == DamageSource.OUT_OF_WORLD) && combatentry2.j() > 0.0F && (combatentry == null || combatentry2.j() > f1)) {
+                if (i > 0) {
+                    combatentry = combatentry3;
+                } else {
+                    combatentry = combatentry2;
+                }
+
+                f1 = combatentry2.j();
+            }
+
+            if (combatentry2.g() != null && (combatentry1 == null || combatentry2.c() > f)) {
+                combatentry1 = combatentry2;
+                f = combatentry2.c();
+            }
+        }
+
+        if (f1 > 5.0F && combatentry != null) {
+            return combatentry;
+        } else if (f > 5.0F && combatentry1 != null) {
+            return combatentry1;
+        } else {
+            return null;
+        }
+    }
+
+    private String a(CombatEntry combatentry) {
+        return combatentry.g() == null ? "generic" : combatentry.g();
+    }
+
+    public int f() {
+        return this.f ? this.b.ticksLived - this.d : this.e - this.d;
+    }
+
+    private void k() {
+        this.h = null;
+    }
+
+    public void g() {
+        int i = this.f ? 300 : 100;
+
+        if (this.g && (!this.b.isAlive() || this.b.ticksLived - this.c > i)) {
+            boolean flag = this.f;
+
+            this.g = false;
+            this.f = false;
+            this.e = this.b.ticksLived;
+            if (flag) {
+                this.b.exitCombat();
+            }
+
+            this.a.clear();
+        }
+
+    }
+
+    public EntityLiving h() {
+        return this.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/EnumItemSlot.java b/src/main/java/net/minecraft/world/entity/EnumItemSlot.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e7673c6072c3f8ddcebd7a719304ea41d809a36
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/EnumItemSlot.java
@@ -0,0 +1,71 @@
+package net.minecraft.world.entity;
+
+public enum EnumItemSlot {
+
+    MAINHAND(EnumItemSlot.Function.HAND, 0, 0, "mainhand"), OFFHAND(EnumItemSlot.Function.HAND, 1, 5, "offhand"), FEET(EnumItemSlot.Function.ARMOR, 0, 1, "feet"), LEGS(EnumItemSlot.Function.ARMOR, 1, 2, "legs"), CHEST(EnumItemSlot.Function.ARMOR, 2, 3, "chest"), HEAD(EnumItemSlot.Function.ARMOR, 3, 4, "head");
+
+    private final EnumItemSlot.Function g;
+    private final int h;
+    private final int i;
+    private final String j;
+
+    private EnumItemSlot(EnumItemSlot.Function enumitemslot_function, int i, int j, String s) {
+        this.g = enumitemslot_function;
+        this.h = i;
+        this.i = j;
+        this.j = s;
+    }
+
+    public EnumItemSlot.Function a() {
+        return this.g;
+    }
+
+    public int b() {
+        return this.h;
+    }
+
+    public int getSlotFlag() {
+        return this.i;
+    }
+
+    public String getSlotName() {
+        return this.j;
+    }
+
+    public static EnumItemSlot fromName(String s) {
+        EnumItemSlot[] aenumitemslot = values();
+        int i = aenumitemslot.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumItemSlot enumitemslot = aenumitemslot[j];
+
+            if (enumitemslot.getSlotName().equals(s)) {
+                return enumitemslot;
+            }
+        }
+
+        throw new IllegalArgumentException("Invalid slot '" + s + "'");
+    }
+
+    public static EnumItemSlot a(EnumItemSlot.Function enumitemslot_function, int i) {
+        EnumItemSlot[] aenumitemslot = values();
+        int j = aenumitemslot.length;
+
+        for (int k = 0; k < j; ++k) {
+            EnumItemSlot enumitemslot = aenumitemslot[k];
+
+            if (enumitemslot.a() == enumitemslot_function && enumitemslot.b() == i) {
+                return enumitemslot;
+            }
+        }
+
+        throw new IllegalArgumentException("Invalid slot '" + enumitemslot_function + "': " + i);
+    }
+
+    public static enum Function {
+
+        HAND, ARMOR;
+
+        private Function() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMapBase.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMapBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f6b78c68da555f96033df567da581af52195e6c
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMapBase.java
@@ -0,0 +1,138 @@
+package net.minecraft.world.entity.ai.attributes;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.Sets;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.IRegistry;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.resources.MinecraftKey;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class AttributeMapBase {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final Map<AttributeBase, AttributeModifiable> b = Maps.newHashMap();
+    private final Set<AttributeModifiable> c = Sets.newHashSet();
+    private final AttributeProvider d;
+
+    public AttributeMapBase(AttributeProvider attributeprovider) {
+        this.d = attributeprovider;
+    }
+
+    private void a(AttributeModifiable attributemodifiable) {
+        if (attributemodifiable.getAttribute().b()) {
+            this.c.add(attributemodifiable);
+        }
+
+    }
+
+    public Set<AttributeModifiable> getAttributes() {
+        return this.c;
+    }
+
+    public Collection<AttributeModifiable> b() {
+        return (Collection) this.b.values().stream().filter((attributemodifiable) -> {
+            return attributemodifiable.getAttribute().b();
+        }).collect(Collectors.toList());
+    }
+
+    @Nullable
+    public AttributeModifiable a(AttributeBase attributebase) {
+        return (AttributeModifiable) this.b.computeIfAbsent(attributebase, (attributebase1) -> {
+            return this.d.a(this::a, attributebase1);
+        });
+    }
+
+    public boolean b(AttributeBase attributebase) {
+        return this.b.get(attributebase) != null || this.d.c(attributebase);
+    }
+
+    public boolean a(AttributeBase attributebase, UUID uuid) {
+        AttributeModifiable attributemodifiable = (AttributeModifiable) this.b.get(attributebase);
+
+        return attributemodifiable != null ? attributemodifiable.a(uuid) != null : this.d.b(attributebase, uuid);
+    }
+
+    public double c(AttributeBase attributebase) {
+        AttributeModifiable attributemodifiable = (AttributeModifiable) this.b.get(attributebase);
+
+        return attributemodifiable != null ? attributemodifiable.getValue() : this.d.a(attributebase);
+    }
+
+    public double d(AttributeBase attributebase) {
+        AttributeModifiable attributemodifiable = (AttributeModifiable) this.b.get(attributebase);
+
+        return attributemodifiable != null ? attributemodifiable.getBaseValue() : this.d.b(attributebase);
+    }
+
+    public double b(AttributeBase attributebase, UUID uuid) {
+        AttributeModifiable attributemodifiable = (AttributeModifiable) this.b.get(attributebase);
+
+        return attributemodifiable != null ? attributemodifiable.a(uuid).getAmount() : this.d.a(attributebase, uuid);
+    }
+
+    public void a(Multimap<AttributeBase, AttributeModifier> multimap) {
+        multimap.asMap().forEach((attributebase, collection) -> {
+            AttributeModifiable attributemodifiable = (AttributeModifiable) this.b.get(attributebase);
+
+            if (attributemodifiable != null) {
+                collection.forEach(attributemodifiable::removeModifier);
+            }
+
+        });
+    }
+
+    public void b(Multimap<AttributeBase, AttributeModifier> multimap) {
+        multimap.forEach((attributebase, attributemodifier) -> {
+            AttributeModifiable attributemodifiable = this.a(attributebase);
+
+            if (attributemodifiable != null) {
+                attributemodifiable.removeModifier(attributemodifier);
+                attributemodifiable.b(attributemodifier);
+            }
+
+        });
+    }
+
+    public NBTTagList c() {
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.b.values().iterator();
+
+        while (iterator.hasNext()) {
+            AttributeModifiable attributemodifiable = (AttributeModifiable) iterator.next();
+
+            nbttaglist.add(attributemodifiable.g());
+        }
+
+        return nbttaglist;
+    }
+
+    public void a(NBTTagList nbttaglist) {
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound = nbttaglist.getCompound(i);
+            String s = nbttagcompound.getString("Name");
+
+            SystemUtils.a(IRegistry.ATTRIBUTE.getOptional(MinecraftKey.a(s)), (attributebase) -> {
+                AttributeModifiable attributemodifiable = this.a(attributebase);
+
+                if (attributemodifiable != null) {
+                    attributemodifiable.a(nbttagcompound);
+                }
+
+            }, () -> {
+                AttributeMapBase.LOGGER.warn("Ignoring unknown attribute '{}'", s);
+            });
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java b/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..a30b92736d8b36f750eb721d4a056bdfc98845b5
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
@@ -0,0 +1,113 @@
+package net.minecraft.world.entity.ai.behavior;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+
+public abstract class Behavior<E extends EntityLiving> {
+
+    protected final Map<MemoryModuleType<?>, MemoryStatus> a;
+    private Behavior.Status b;
+    private long c;
+    private final int d;
+    private final int e;
+
+    public Behavior(Map<MemoryModuleType<?>, MemoryStatus> map) {
+        this(map, 60);
+    }
+
+    public Behavior(Map<MemoryModuleType<?>, MemoryStatus> map, int i) {
+        this(map, i, i);
+    }
+
+    public Behavior(Map<MemoryModuleType<?>, MemoryStatus> map, int i, int j) {
+        this.b = Behavior.Status.STOPPED;
+        this.d = i;
+        this.e = j;
+        this.a = map;
+    }
+
+    public Behavior.Status a() {
+        return this.b;
+    }
+
+    public final boolean e(WorldServer worldserver, E e0, long i) {
+        if (this.a(e0) && this.a(worldserver, e0)) {
+            this.b = Behavior.Status.RUNNING;
+            int j = this.d + worldserver.getRandom().nextInt(this.e + 1 - this.d);
+
+            this.c = i + (long) j;
+            this.a(worldserver, e0, i);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    protected void a(WorldServer worldserver, E e0, long i) {}
+
+    public final void f(WorldServer worldserver, E e0, long i) {
+        if (!this.a(i) && this.b(worldserver, e0, i)) {
+            this.d(worldserver, e0, i);
+        } else {
+            this.g(worldserver, e0, i);
+        }
+
+    }
+
+    protected void d(WorldServer worldserver, E e0, long i) {}
+
+    public final void g(WorldServer worldserver, E e0, long i) {
+        this.b = Behavior.Status.STOPPED;
+        this.c(worldserver, e0, i);
+    }
+
+    protected void c(WorldServer worldserver, E e0, long i) {}
+
+    protected boolean b(WorldServer worldserver, E e0, long i) {
+        return false;
+    }
+
+    protected boolean a(long i) {
+        return i > this.c;
+    }
+
+    protected boolean a(WorldServer worldserver, E e0) {
+        return true;
+    }
+
+    public String toString() {
+        return this.getClass().getSimpleName();
+    }
+
+    private boolean a(E e0) {
+        Iterator iterator = this.a.entrySet().iterator();
+
+        MemoryModuleType memorymoduletype;
+        MemoryStatus memorystatus;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
+            }
+
+            Entry<MemoryModuleType<?>, MemoryStatus> entry = (Entry) iterator.next();
+
+            memorymoduletype = (MemoryModuleType) entry.getKey();
+            memorystatus = (MemoryStatus) entry.getValue();
+        } while (e0.getBehaviorController().a(memorymoduletype, memorystatus));
+
+        return false;
+    }
+
+    public static enum Status {
+
+        STOPPED, RUNNING;
+
+        private Status() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorFindPosition.java b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorFindPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..a04d4dc665f34687b5d744fea56bc46263f27235
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorFindPosition.java
@@ -0,0 +1,150 @@
+package net.minecraft.world.entity.ai.behavior;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableMap.Builder;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import java.util.Iterator;
+import java.util.Optional;
+import java.util.Random;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.GlobalPos;
+import net.minecraft.network.protocol.game.PacketDebug;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.EntityCreature;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import net.minecraft.world.entity.ai.village.poi.VillagePlace;
+import net.minecraft.world.entity.ai.village.poi.VillagePlaceType;
+import net.minecraft.world.level.pathfinder.PathEntity;
+
+public class BehaviorFindPosition extends Behavior<EntityCreature> {
+
+    private final VillagePlaceType b;
+    private final MemoryModuleType<GlobalPos> c;
+    private final boolean d;
+    private final Optional<Byte> e;
+    private long f;
+    private final Long2ObjectMap<BehaviorFindPosition.a> g;
+
+    public BehaviorFindPosition(VillagePlaceType villageplacetype, MemoryModuleType<GlobalPos> memorymoduletype, MemoryModuleType<GlobalPos> memorymoduletype1, boolean flag, Optional<Byte> optional) {
+        super(a(memorymoduletype, memorymoduletype1));
+        this.g = new Long2ObjectOpenHashMap();
+        this.b = villageplacetype;
+        this.c = memorymoduletype1;
+        this.d = flag;
+        this.e = optional;
+    }
+
+    public BehaviorFindPosition(VillagePlaceType villageplacetype, MemoryModuleType<GlobalPos> memorymoduletype, boolean flag, Optional<Byte> optional) {
+        this(villageplacetype, memorymoduletype, memorymoduletype, flag, optional);
+    }
+
+    private static ImmutableMap<MemoryModuleType<?>, MemoryStatus> a(MemoryModuleType<GlobalPos> memorymoduletype, MemoryModuleType<GlobalPos> memorymoduletype1) {
+        Builder<MemoryModuleType<?>, MemoryStatus> builder = ImmutableMap.builder();
+
+        builder.put(memorymoduletype, MemoryStatus.VALUE_ABSENT);
+        if (memorymoduletype1 != memorymoduletype) {
+            builder.put(memorymoduletype1, MemoryStatus.VALUE_ABSENT);
+        }
+
+        return builder.build();
+    }
+
+    protected boolean a(WorldServer worldserver, EntityCreature entitycreature) {
+        if (this.d && entitycreature.isBaby()) {
+            return false;
+        } else if (this.f == 0L) {
+            this.f = entitycreature.world.getTime() + (long) worldserver.random.nextInt(20);
+            return false;
+        } else {
+            return worldserver.getTime() >= this.f;
+        }
+    }
+
+    protected void a(WorldServer worldserver, EntityCreature entitycreature, long i) {
+        this.f = i + 20L + (long) worldserver.getRandom().nextInt(20);
+        VillagePlace villageplace = worldserver.y();
+
+        this.g.long2ObjectEntrySet().removeIf((entry) -> {
+            return !((BehaviorFindPosition.a) entry.getValue()).b(i);
+        });
+        Predicate<BlockPosition> predicate = (blockposition) -> {
+            BehaviorFindPosition.a behaviorfindposition_a = (BehaviorFindPosition.a) this.g.get(blockposition.asLong());
+
+            if (behaviorfindposition_a == null) {
+                return true;
+            } else if (!behaviorfindposition_a.c(i)) {
+                return false;
+            } else {
+                behaviorfindposition_a.a(i);
+                return true;
+            }
+        };
+        Set<BlockPosition> set = (Set) villageplace.b(this.b.c(), predicate, entitycreature.getChunkCoordinates(), 48, VillagePlace.Occupancy.HAS_SPACE).limit(5L).collect(Collectors.toSet());
+        PathEntity pathentity = entitycreature.getNavigation().a(set, this.b.d());
+
+        if (pathentity != null && pathentity.j()) {
+            BlockPosition blockposition = pathentity.m();
+
+            villageplace.c(blockposition).ifPresent((villageplacetype) -> {
+                villageplace.a(this.b.c(), (blockposition1) -> {
+                    return blockposition1.equals(blockposition);
+                }, blockposition, 1);
+                entitycreature.getBehaviorController().setMemory(this.c, (Object) GlobalPos.create(worldserver.getDimensionKey(), blockposition));
+                this.e.ifPresent((obyte) -> {
+                    worldserver.broadcastEntityEffect(entitycreature, obyte);
+                });
+                this.g.clear();
+                PacketDebug.c(worldserver, blockposition);
+            });
+        } else {
+            Iterator iterator = set.iterator();
+
+            while (iterator.hasNext()) {
+                BlockPosition blockposition1 = (BlockPosition) iterator.next();
+
+                this.g.computeIfAbsent(blockposition1.asLong(), (j) -> {
+                    return new BehaviorFindPosition.a(entitycreature.world.random, i);
+                });
+            }
+        }
+
+    }
+
+    static class a {
+
+        private final Random a;
+        private long b;
+        private long c;
+        private int d;
+
+        a(Random random, long i) {
+            this.a = random;
+            this.a(i);
+        }
+
+        public void a(long i) {
+            this.b = i;
+            int j = this.d + this.a.nextInt(40) + 40;
+
+            this.d = Math.min(j, 400);
+            this.c = i + (long) this.d;
+        }
+
+        public boolean b(long i) {
+            return i - this.b < 400L;
+        }
+
+        public boolean c(long i) {
+            return i >= this.c;
+        }
+
+        public String toString() {
+            return "RetryMarker{, previousAttemptAt=" + this.b + ", nextScheduledAttemptAt=" + this.c + ", currentDelay=" + this.d + '}';
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorGate.java b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorGate.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc926f7e59fa350902d4a24aefc3df3eac7d75db
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorGate.java
@@ -0,0 +1,126 @@
+package net.minecraft.world.entity.ai.behavior;
+
+import com.mojang.datafixers.util.Pair;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.ai.BehaviorController;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+
+public class BehaviorGate<E extends EntityLiving> extends Behavior<E> {
+
+    private final Set<MemoryModuleType<?>> b;
+    private final BehaviorGate.Order c;
+    private final BehaviorGate.Execution d;
+    private final WeightedList<Behavior<? super E>> e = new WeightedList<>();
+
+    public BehaviorGate(Map<MemoryModuleType<?>, MemoryStatus> map, Set<MemoryModuleType<?>> set, BehaviorGate.Order behaviorgate_order, BehaviorGate.Execution behaviorgate_execution, List<Pair<Behavior<? super E>, Integer>> list) {
+        super(map);
+        this.b = set;
+        this.c = behaviorgate_order;
+        this.d = behaviorgate_execution;
+        list.forEach((pair) -> {
+            this.e.a(pair.getFirst(), (Integer) pair.getSecond());
+        });
+    }
+
+    @Override
+    protected boolean b(WorldServer worldserver, E e0, long i) {
+        return this.e.c().filter((behavior) -> {
+            return behavior.a() == Behavior.Status.RUNNING;
+        }).anyMatch((behavior) -> {
+            return behavior.b(worldserver, e0, i);
+        });
+    }
+
+    @Override
+    protected boolean a(long i) {
+        return false;
+    }
+
+    @Override
+    protected void a(WorldServer worldserver, E e0, long i) {
+        this.c.a(this.e);
+        this.d.a(this.e, worldserver, e0, i);
+    }
+
+    @Override
+    protected void d(WorldServer worldserver, E e0, long i) {
+        this.e.c().filter((behavior) -> {
+            return behavior.a() == Behavior.Status.RUNNING;
+        }).forEach((behavior) -> {
+            behavior.f(worldserver, e0, i);
+        });
+    }
+
+    @Override
+    protected void c(WorldServer worldserver, E e0, long i) {
+        this.e.c().filter((behavior) -> {
+            return behavior.a() == Behavior.Status.RUNNING;
+        }).forEach((behavior) -> {
+            behavior.g(worldserver, e0, i);
+        });
+        Set set = this.b;
+        BehaviorController behaviorcontroller = e0.getBehaviorController();
+
+        set.forEach(behaviorcontroller::removeMemory);
+    }
+
+    @Override
+    public String toString() {
+        Set<? extends Behavior<? super E>> set = (Set) this.e.c().filter((behavior) -> {
+            return behavior.a() == Behavior.Status.RUNNING;
+        }).collect(Collectors.toSet());
+
+        return "(" + this.getClass().getSimpleName() + "): " + set;
+    }
+
+    static enum Execution {
+
+        RUN_ONE {
+            @Override
+            public <E extends EntityLiving> void a(WeightedList<Behavior<? super E>> weightedlist, WorldServer worldserver, E e0, long i) {
+                weightedlist.c().filter((behavior) -> {
+                    return behavior.a() == Behavior.Status.STOPPED;
+                }).filter((behavior) -> {
+                    return behavior.e(worldserver, e0, i);
+                }).findFirst();
+            }
+        },
+        TRY_ALL {
+            @Override
+            public <E extends EntityLiving> void a(WeightedList<Behavior<? super E>> weightedlist, WorldServer worldserver, E e0, long i) {
+                weightedlist.c().filter((behavior) -> {
+                    return behavior.a() == Behavior.Status.STOPPED;
+                }).forEach((behavior) -> {
+                    behavior.e(worldserver, e0, i);
+                });
+            }
+        };
+
+        private Execution() {}
+
+        public abstract <E extends EntityLiving> void a(WeightedList<Behavior<? super E>> weightedlist, WorldServer worldserver, E e0, long i);
+    }
+
+    static enum Order {
+
+        ORDERED((weightedlist) -> {
+        }), SHUFFLED(WeightedList::a);
+
+        private final Consumer<WeightedList<?>> c;
+
+        private Order(Consumer consumer) {
+            this.c = consumer;
+        }
+
+        public void a(WeightedList<?> weightedlist) {
+            this.c.accept(weightedlist);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorLookInteract.java b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorLookInteract.java
new file mode 100644
index 0000000000000000000000000000000000000000..f56072c77b9dfd0eeafb7a6970eecf593315f63e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorLookInteract.java
@@ -0,0 +1,64 @@
+package net.minecraft.world.entity.ai.behavior;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.List;
+import java.util.function.Predicate;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.ai.BehaviorController;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+
+public class BehaviorLookInteract extends Behavior<EntityLiving> {
+
+    private final EntityTypes<?> b;
+    private final int c;
+    private final Predicate<EntityLiving> d;
+    private final Predicate<EntityLiving> e;
+
+    public BehaviorLookInteract(EntityTypes<?> entitytypes, int i, Predicate<EntityLiving> predicate, Predicate<EntityLiving> predicate1) {
+        super(ImmutableMap.of(MemoryModuleType.LOOK_TARGET, MemoryStatus.REGISTERED, MemoryModuleType.INTERACTION_TARGET, MemoryStatus.VALUE_ABSENT, MemoryModuleType.VISIBLE_MOBS, MemoryStatus.VALUE_PRESENT));
+        this.b = entitytypes;
+        this.c = i * i;
+        this.d = predicate1;
+        this.e = predicate;
+    }
+
+    public BehaviorLookInteract(EntityTypes<?> entitytypes, int i) {
+        this(entitytypes, i, (entityliving) -> {
+            return true;
+        }, (entityliving) -> {
+            return true;
+        });
+    }
+
+    @Override
+    public boolean a(WorldServer worldserver, EntityLiving entityliving) {
+        return this.e.test(entityliving) && this.b(entityliving).stream().anyMatch(this::a);
+    }
+
+    @Override
+    public void a(WorldServer worldserver, EntityLiving entityliving, long i) {
+        super.a(worldserver, entityliving, i);
+        BehaviorController<?> behaviorcontroller = entityliving.getBehaviorController();
+
+        behaviorcontroller.getMemory(MemoryModuleType.VISIBLE_MOBS).ifPresent((list) -> {
+            list.stream().filter((entityliving1) -> {
+                return entityliving1.h((Entity) entityliving) <= (double) this.c;
+            }).filter(this::a).findFirst().ifPresent((entityliving1) -> {
+                behaviorcontroller.setMemory(MemoryModuleType.INTERACTION_TARGET, (Object) entityliving1);
+                behaviorcontroller.setMemory(MemoryModuleType.LOOK_TARGET, (Object) (new BehaviorPositionEntity(entityliving1, true)));
+            });
+        });
+    }
+
+    private boolean a(EntityLiving entityliving) {
+        return this.b.equals(entityliving.getEntityType()) && this.d.test(entityliving);
+    }
+
+    private List<EntityLiving> b(EntityLiving entityliving) {
+        return (List) entityliving.getBehaviorController().getMemory(MemoryModuleType.VISIBLE_MOBS).get();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorSleep.java b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorSleep.java
new file mode 100644
index 0000000000000000000000000000000000000000..84eba4c91e8e608b84623d6c71233e2512b77a54
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorSleep.java
@@ -0,0 +1,91 @@
+package net.minecraft.world.entity.ai.behavior;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.Optional;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.GlobalPos;
+import net.minecraft.core.IPosition;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsBlock;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.ai.BehaviorController;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import net.minecraft.world.entity.schedule.Activity;
+import net.minecraft.world.level.block.BlockBed;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.pathfinder.PathPoint;
+
+public class BehaviorSleep extends Behavior<EntityLiving> {
+
+    private long b;
+
+    public BehaviorSleep() {
+        super(ImmutableMap.of(MemoryModuleType.HOME, MemoryStatus.VALUE_PRESENT, MemoryModuleType.LAST_WOKEN, MemoryStatus.REGISTERED));
+    }
+
+    @Override
+    protected boolean a(WorldServer worldserver, EntityLiving entityliving) {
+        if (entityliving.isPassenger()) {
+            return false;
+        } else {
+            BehaviorController<?> behaviorcontroller = entityliving.getBehaviorController();
+            GlobalPos globalpos = (GlobalPos) behaviorcontroller.getMemory(MemoryModuleType.HOME).get();
+
+            if (worldserver.getDimensionKey() != globalpos.getDimensionManager()) {
+                return false;
+            } else {
+                Optional<Long> optional = behaviorcontroller.getMemory(MemoryModuleType.LAST_WOKEN);
+
+                if (optional.isPresent()) {
+                    long i = worldserver.getTime() - (Long) optional.get();
+
+                    if (i > 0L && i < 100L) {
+                        return false;
+                    }
+                }
+
+                IBlockData iblockdata = worldserver.getType(globalpos.getBlockPosition());
+
+                return globalpos.getBlockPosition().a((IPosition) entityliving.getPositionVector(), 2.0D) && iblockdata.getBlock().a((Tag) TagsBlock.BEDS) && !(Boolean) iblockdata.get(BlockBed.OCCUPIED);
+            }
+        }
+    }
+
+    @Override
+    protected boolean b(WorldServer worldserver, EntityLiving entityliving, long i) {
+        Optional<GlobalPos> optional = entityliving.getBehaviorController().getMemory(MemoryModuleType.HOME);
+
+        if (!optional.isPresent()) {
+            return false;
+        } else {
+            BlockPosition blockposition = ((GlobalPos) optional.get()).getBlockPosition();
+
+            return entityliving.getBehaviorController().c(Activity.REST) && entityliving.locY() > (double) blockposition.getY() + 0.4D && blockposition.a((IPosition) entityliving.getPositionVector(), 1.14D);
+        }
+    }
+
+    @Override
+    protected void a(WorldServer worldserver, EntityLiving entityliving, long i) {
+        if (i > this.b) {
+            BehaviorInteractDoor.a(worldserver, entityliving, (PathPoint) null, (PathPoint) null);
+            entityliving.entitySleep(((GlobalPos) entityliving.getBehaviorController().getMemory(MemoryModuleType.HOME).get()).getBlockPosition());
+        }
+
+    }
+
+    @Override
+    protected boolean a(long i) {
+        return false;
+    }
+
+    @Override
+    protected void c(WorldServer worldserver, EntityLiving entityliving, long i) {
+        if (entityliving.isSleeping()) {
+            entityliving.entityWakeup();
+            this.b = i + 40L;
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/WeightedList.java b/src/main/java/net/minecraft/world/entity/ai/behavior/WeightedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..f6f8c68ff3642e28901094e8b501fcf8ec2cecd7
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/WeightedList.java
@@ -0,0 +1,118 @@
+package net.minecraft.world.entity.ai.behavior;
+
+import com.google.common.collect.Lists;
+import com.mojang.datafixers.util.Pair;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Dynamic;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.OptionalDynamic;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Random;
+import java.util.stream.Stream;
+
+public class WeightedList<U> {
+
+    protected final List<WeightedList.a<U>> a;
+    private final Random b;
+
+    public WeightedList() {
+        this(Lists.newArrayList());
+    }
+
+    private WeightedList(List<WeightedList.a<U>> list) {
+        this.b = new Random();
+        this.a = Lists.newArrayList(list);
+    }
+
+    public static <U> Codec<WeightedList<U>> a(Codec<U> codec) {
+        return WeightedList.a.a(codec).listOf().xmap(WeightedList::new, (weightedlist) -> {
+            return weightedlist.a;
+        });
+    }
+
+    public WeightedList<U> a(U u0, int i) {
+        this.a.add(new WeightedList.a<>(u0, i));
+        return this;
+    }
+
+    public WeightedList<U> a() {
+        return this.a(this.b);
+    }
+
+    public WeightedList<U> a(Random random) {
+        this.a.forEach((weightedlist_a) -> {
+            weightedlist_a.a(random.nextFloat());
+        });
+        this.a.sort(Comparator.comparingDouble((object) -> {
+            return ((WeightedList.a) object).c();
+        }));
+        return this;
+    }
+
+    public boolean b() {
+        return this.a.isEmpty();
+    }
+
+    public Stream<U> c() {
+        return this.a.stream().map(WeightedList.a::a);
+    }
+
+    public U b(Random random) {
+        return this.a(random).c().findFirst().orElseThrow(RuntimeException::new);
+    }
+
+    public String toString() {
+        return "WeightedList[" + this.a + "]";
+    }
+
+    public static class a<T> {
+
+        private final T a;
+        private final int b;
+        private double c;
+
+        private a(T t0, int i) {
+            this.b = i;
+            this.a = t0;
+        }
+
+        private double c() {
+            return this.c;
+        }
+
+        private void a(float f) {
+            this.c = -Math.pow((double) f, (double) (1.0F / (float) this.b));
+        }
+
+        public T a() {
+            return this.a;
+        }
+
+        public String toString() {
+            return "" + this.b + ":" + this.a;
+        }
+
+        public static <E> Codec<WeightedList.a<E>> a(final Codec<E> codec) {
+            return new Codec<WeightedList.a<E>>() {
+                public <T> DataResult<Pair<WeightedList.a<E>, T>> decode(DynamicOps<T> dynamicops, T t0) {
+                    Dynamic<T> dynamic = new Dynamic(dynamicops, t0);
+                    OptionalDynamic optionaldynamic = dynamic.get("data");
+                    Codec codec1 = codec;
+
+                    codec.getClass();
+                    return optionaldynamic.flatMap(codec1::parse).map((object) -> {
+                        return new WeightedList.a<>(object, dynamic.get("weight").asInt(1));
+                    }).map((weightedlist_a) -> {
+                        return Pair.of(weightedlist_a, dynamicops.empty());
+                    });
+                }
+
+                public <T> DataResult<T> encode(WeightedList.a<E> weightedlist_a, DynamicOps<T> dynamicops, T t0) {
+                    return dynamicops.mapBuilder().add("weight", dynamicops.createInt(weightedlist_a.b)).add("data", codec.encodeStart(dynamicops, weightedlist_a.a)).build(t0);
+                }
+            };
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/control/ControllerJump.java b/src/main/java/net/minecraft/world/entity/ai/control/ControllerJump.java
new file mode 100644
index 0000000000000000000000000000000000000000..9767ac416fcd60a8a57b648dcb3f1e427bacd54d
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/control/ControllerJump.java
@@ -0,0 +1,22 @@
+package net.minecraft.world.entity.ai.control;
+
+import net.minecraft.world.entity.EntityInsentient;
+
+public class ControllerJump {
+
+    private final EntityInsentient b;
+    protected boolean a;
+
+    public ControllerJump(EntityInsentient entityinsentient) {
+        this.b = entityinsentient;
+    }
+
+    public void jump() {
+        this.a = true;
+    }
+
+    public void b() {
+        this.b.setJumping(this.a);
+        this.a = false;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/control/ControllerMove.java b/src/main/java/net/minecraft/world/entity/ai/control/ControllerMove.java
new file mode 100644
index 0000000000000000000000000000000000000000..4044861622294a317fef7e93aa86e96e8474b513
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/control/ControllerMove.java
@@ -0,0 +1,179 @@
+package net.minecraft.world.entity.ai.control;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsBlock;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.ai.navigation.NavigationAbstract;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.pathfinder.PathType;
+import net.minecraft.world.level.pathfinder.PathfinderAbstract;
+import net.minecraft.world.phys.shapes.VoxelShape;
+
+public class ControllerMove {
+
+    protected final EntityInsentient a;
+    protected double b;
+    protected double c;
+    protected double d;
+    protected double e;
+    protected float f;
+    protected float g;
+    protected ControllerMove.Operation h;
+
+    public ControllerMove(EntityInsentient entityinsentient) {
+        this.h = ControllerMove.Operation.WAIT;
+        this.a = entityinsentient;
+    }
+
+    public boolean b() {
+        return this.h == ControllerMove.Operation.MOVE_TO;
+    }
+
+    public double c() {
+        return this.e;
+    }
+
+    public void a(double d0, double d1, double d2, double d3) {
+        this.b = d0;
+        this.c = d1;
+        this.d = d2;
+        this.e = d3;
+        if (this.h != ControllerMove.Operation.JUMPING) {
+            this.h = ControllerMove.Operation.MOVE_TO;
+        }
+
+    }
+
+    public void a(float f, float f1) {
+        this.h = ControllerMove.Operation.STRAFE;
+        this.f = f;
+        this.g = f1;
+        this.e = 0.25D;
+    }
+
+    public void a() {
+        float f;
+
+        if (this.h == ControllerMove.Operation.STRAFE) {
+            float f1 = (float) this.a.b(GenericAttributes.MOVEMENT_SPEED);
+            float f2 = (float) this.e * f1;
+            float f3 = this.f;
+            float f4 = this.g;
+            float f5 = MathHelper.c(f3 * f3 + f4 * f4);
+
+            if (f5 < 1.0F) {
+                f5 = 1.0F;
+            }
+
+            f5 = f2 / f5;
+            f3 *= f5;
+            f4 *= f5;
+            float f6 = MathHelper.sin(this.a.yaw * 0.017453292F);
+            float f7 = MathHelper.cos(this.a.yaw * 0.017453292F);
+            float f8 = f3 * f7 - f4 * f6;
+
+            f = f4 * f7 + f3 * f6;
+            if (!this.b(f8, f)) {
+                this.f = 1.0F;
+                this.g = 0.0F;
+            }
+
+            this.a.q(f2);
+            this.a.t(this.f);
+            this.a.v(this.g);
+            this.h = ControllerMove.Operation.WAIT;
+        } else if (this.h == ControllerMove.Operation.MOVE_TO) {
+            this.h = ControllerMove.Operation.WAIT;
+            double d0 = this.b - this.a.locX();
+            double d1 = this.d - this.a.locZ();
+            double d2 = this.c - this.a.locY();
+            double d3 = d0 * d0 + d2 * d2 + d1 * d1;
+
+            if (d3 < 2.500000277905201E-7D) {
+                this.a.t(0.0F);
+                return;
+            }
+
+            f = (float) (MathHelper.d(d1, d0) * 57.2957763671875D) - 90.0F;
+            this.a.yaw = this.a(this.a.yaw, f, 90.0F);
+            this.a.q((float) (this.e * this.a.b(GenericAttributes.MOVEMENT_SPEED)));
+            BlockPosition blockposition = this.a.getChunkCoordinates();
+            IBlockData iblockdata = this.a.world.getType(blockposition);
+            Block block = iblockdata.getBlock();
+            VoxelShape voxelshape = iblockdata.getCollisionShape(this.a.world, blockposition);
+
+            if (d2 > (double) this.a.G && d0 * d0 + d1 * d1 < (double) Math.max(1.0F, this.a.getWidth()) || !voxelshape.isEmpty() && this.a.locY() < voxelshape.c(EnumDirection.EnumAxis.Y) + (double) blockposition.getY() && !block.a((Tag) TagsBlock.DOORS) && !block.a((Tag) TagsBlock.FENCES)) {
+                this.a.getControllerJump().jump();
+                this.h = ControllerMove.Operation.JUMPING;
+            }
+        } else if (this.h == ControllerMove.Operation.JUMPING) {
+            this.a.q((float) (this.e * this.a.b(GenericAttributes.MOVEMENT_SPEED)));
+            if (this.a.isOnGround()) {
+                this.h = ControllerMove.Operation.WAIT;
+            }
+        } else {
+            this.a.t(0.0F);
+        }
+
+    }
+
+    private boolean b(float f, float f1) {
+        NavigationAbstract navigationabstract = this.a.getNavigation();
+
+        if (navigationabstract != null) {
+            PathfinderAbstract pathfinderabstract = navigationabstract.q();
+
+            if (pathfinderabstract != null && pathfinderabstract.a(this.a.world, MathHelper.floor(this.a.locX() + (double) f), MathHelper.floor(this.a.locY()), MathHelper.floor(this.a.locZ() + (double) f1)) != PathType.WALKABLE) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    protected float a(float f, float f1, float f2) {
+        float f3 = MathHelper.g(f1 - f);
+
+        if (f3 > f2) {
+            f3 = f2;
+        }
+
+        if (f3 < -f2) {
+            f3 = -f2;
+        }
+
+        float f4 = f + f3;
+
+        if (f4 < 0.0F) {
+            f4 += 360.0F;
+        } else if (f4 > 360.0F) {
+            f4 -= 360.0F;
+        }
+
+        return f4;
+    }
+
+    public double d() {
+        return this.b;
+    }
+
+    public double e() {
+        return this.c;
+    }
+
+    public double f() {
+        return this.d;
+    }
+
+    public static enum Operation {
+
+        WAIT, MOVE_TO, STRAFE, JUMPING;
+
+        private Operation() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/control/ControllerMoveFlying.java b/src/main/java/net/minecraft/world/entity/ai/control/ControllerMoveFlying.java
new file mode 100644
index 0000000000000000000000000000000000000000..80cba36bc59e89c40c96ca556594a4285f06fc6f
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/control/ControllerMoveFlying.java
@@ -0,0 +1,61 @@
+package net.minecraft.world.entity.ai.control;
+
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+
+public class ControllerMoveFlying extends ControllerMove {
+
+    private final int i;
+    private final boolean j;
+
+    public ControllerMoveFlying(EntityInsentient entityinsentient, int i, boolean flag) {
+        super(entityinsentient);
+        this.i = i;
+        this.j = flag;
+    }
+
+    @Override
+    public void a() {
+        if (this.h == ControllerMove.Operation.MOVE_TO) {
+            this.h = ControllerMove.Operation.WAIT;
+            this.a.setNoGravity(true);
+            double d0 = this.b - this.a.locX();
+            double d1 = this.c - this.a.locY();
+            double d2 = this.d - this.a.locZ();
+            double d3 = d0 * d0 + d1 * d1 + d2 * d2;
+
+            if (d3 < 2.500000277905201E-7D) {
+                this.a.u(0.0F);
+                this.a.t(0.0F);
+                return;
+            }
+
+            float f = (float) (MathHelper.d(d2, d0) * 57.2957763671875D) - 90.0F;
+
+            this.a.yaw = this.a(this.a.yaw, f, 90.0F);
+            float f1;
+
+            if (this.a.isOnGround()) {
+                f1 = (float) (this.e * this.a.b(GenericAttributes.MOVEMENT_SPEED));
+            } else {
+                f1 = (float) (this.e * this.a.b(GenericAttributes.FLYING_SPEED));
+            }
+
+            this.a.q(f1);
+            double d4 = (double) MathHelper.sqrt(d0 * d0 + d2 * d2);
+            float f2 = (float) (-(MathHelper.d(d1, d4) * 57.2957763671875D));
+
+            this.a.pitch = this.a(this.a.pitch, f2, (float) this.i);
+            this.a.u(d1 > 0.0D ? f1 : -f1);
+        } else {
+            if (!this.j) {
+                this.a.setNoGravity(false);
+            }
+
+            this.a.u(0.0F);
+            this.a.t(0.0F);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoal.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e599d88a150c907f50acbb58ad1725c3fe361e4
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoal.java
@@ -0,0 +1,46 @@
+package net.minecraft.world.entity.ai.goal;
+
+import java.util.EnumSet;
+
+public abstract class PathfinderGoal {
+
+    private final EnumSet<PathfinderGoal.Type> a = EnumSet.noneOf(PathfinderGoal.Type.class);
+
+    public PathfinderGoal() {}
+
+    public abstract boolean a();
+
+    public boolean b() {
+        return this.a();
+    }
+
+    public boolean C_() {
+        return true;
+    }
+
+    public void c() {}
+
+    public void d() {}
+
+    public void e() {}
+
+    public void a(EnumSet<PathfinderGoal.Type> enumset) {
+        this.a.clear();
+        this.a.addAll(enumset);
+    }
+
+    public String toString() {
+        return this.getClass().getSimpleName();
+    }
+
+    public EnumSet<PathfinderGoal.Type> i() {
+        return this.a;
+    }
+
+    public static enum Type {
+
+        MOVE, LOOK, JUMP, TARGET;
+
+        private Type() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalFloat.java b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalFloat.java
new file mode 100644
index 0000000000000000000000000000000000000000..8dfa1a6ade7f51e5d68b290f5376d999bb4c60ab
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalFloat.java
@@ -0,0 +1,30 @@
+package net.minecraft.world.entity.ai.goal;
+
+import java.util.EnumSet;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsFluid;
+import net.minecraft.world.entity.EntityInsentient;
+
+public class PathfinderGoalFloat extends PathfinderGoal {
+
+    private final EntityInsentient a;
+
+    public PathfinderGoalFloat(EntityInsentient entityinsentient) {
+        this.a = entityinsentient;
+        this.a(EnumSet.of(PathfinderGoal.Type.JUMP));
+        entityinsentient.getNavigation().d(true);
+    }
+
+    @Override
+    public boolean a() {
+        return this.a.isInWater() && this.a.b((Tag) TagsFluid.WATER) > this.a.cx() || this.a.aQ();
+    }
+
+    @Override
+    public void e() {
+        if (this.a.getRandom().nextFloat() < 0.8F) {
+            this.a.getControllerJump().jump();
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalGotoTarget.java b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalGotoTarget.java
new file mode 100644
index 0000000000000000000000000000000000000000..62276550627bfe453794a2b3101426fe05a585ff
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalGotoTarget.java
@@ -0,0 +1,125 @@
+package net.minecraft.world.entity.ai.goal;
+
+import java.util.EnumSet;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IPosition;
+import net.minecraft.world.entity.EntityCreature;
+import net.minecraft.world.level.IWorldReader;
+
+public abstract class PathfinderGoalGotoTarget extends PathfinderGoal {
+
+    protected final EntityCreature a;
+    public final double b;
+    protected int c;
+    protected int d;
+    private int g;
+    protected BlockPosition e;
+    private boolean h;
+    private final int i;
+    private final int j;
+    protected int f;
+
+    public PathfinderGoalGotoTarget(EntityCreature entitycreature, double d0, int i) {
+        this(entitycreature, d0, i, 1);
+    }
+
+    public PathfinderGoalGotoTarget(EntityCreature entitycreature, double d0, int i, int j) {
+        this.e = BlockPosition.ZERO;
+        this.a = entitycreature;
+        this.b = d0;
+        this.i = i;
+        this.f = 0;
+        this.j = j;
+        this.a(EnumSet.of(PathfinderGoal.Type.MOVE, PathfinderGoal.Type.JUMP));
+    }
+
+    @Override
+    public boolean a() {
+        if (this.c > 0) {
+            --this.c;
+            return false;
+        } else {
+            this.c = this.a(this.a);
+            return this.m();
+        }
+    }
+
+    protected int a(EntityCreature entitycreature) {
+        return 200 + entitycreature.getRandom().nextInt(200);
+    }
+
+    @Override
+    public boolean b() {
+        return this.d >= -this.g && this.d <= 1200 && this.a(this.a.world, this.e);
+    }
+
+    @Override
+    public void c() {
+        this.g();
+        this.d = 0;
+        this.g = this.a.getRandom().nextInt(this.a.getRandom().nextInt(1200) + 1200) + 1200;
+    }
+
+    protected void g() {
+        this.a.getNavigation().a((double) ((float) this.e.getX()) + 0.5D, (double) (this.e.getY() + 1), (double) ((float) this.e.getZ()) + 0.5D, this.b);
+    }
+
+    public double h() {
+        return 1.0D;
+    }
+
+    protected BlockPosition j() {
+        return this.e.up();
+    }
+
+    @Override
+    public void e() {
+        BlockPosition blockposition = this.j();
+
+        if (!blockposition.a((IPosition) this.a.getPositionVector(), this.h())) {
+            this.h = false;
+            ++this.d;
+            if (this.k()) {
+                this.a.getNavigation().a((double) ((float) blockposition.getX()) + 0.5D, (double) blockposition.getY(), (double) ((float) blockposition.getZ()) + 0.5D, this.b);
+            }
+        } else {
+            this.h = true;
+            --this.d;
+        }
+
+    }
+
+    public boolean k() {
+        return this.d % 40 == 0;
+    }
+
+    protected boolean l() {
+        return this.h;
+    }
+
+    protected boolean m() {
+        int i = this.i;
+        int j = this.j;
+        BlockPosition blockposition = this.a.getChunkCoordinates();
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        for (int k = this.f; k <= j; k = k > 0 ? -k : 1 - k) {
+            for (int l = 0; l < i; ++l) {
+                for (int i1 = 0; i1 <= l; i1 = i1 > 0 ? -i1 : 1 - i1) {
+                    for (int j1 = i1 < l && i1 > -l ? l : 0; j1 <= l; j1 = j1 > 0 ? -j1 : 1 - j1) {
+                        blockposition_mutableblockposition.a((BaseBlockPosition) blockposition, i1, k - 1, j1);
+                        if (this.a.a((BlockPosition) blockposition_mutableblockposition) && this.a(this.a.world, blockposition_mutableblockposition)) {
+                            this.e = blockposition_mutableblockposition;
+                            return true;
+                        }
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    protected abstract boolean a(IWorldReader iworldreader, BlockPosition blockposition);
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalSelector.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9aaa63fcb0abe5628798827003c677c883c2a18
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalSelector.java
@@ -0,0 +1,127 @@
+package net.minecraft.world.entity.ai.goal;
+
+import com.google.common.collect.Sets;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+import net.minecraft.util.profiling.GameProfilerFiller;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class PathfinderGoalSelector {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final PathfinderGoalWrapped b = new PathfinderGoalWrapped(Integer.MAX_VALUE, new PathfinderGoal() {
+        @Override
+        public boolean a() {
+            return false;
+        }
+    }) {
+        @Override
+        public boolean g() {
+            return false;
+        }
+    };
+    private final Map<PathfinderGoal.Type, PathfinderGoalWrapped> c = new EnumMap(PathfinderGoal.Type.class);
+    private final Set<PathfinderGoalWrapped> d = Sets.newLinkedHashSet();
+    private final Supplier<GameProfilerFiller> e;
+    private final EnumSet<PathfinderGoal.Type> f = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private int g = 3;
+
+    public PathfinderGoalSelector(Supplier<GameProfilerFiller> supplier) {
+        this.e = supplier;
+    }
+
+    public void a(int i, PathfinderGoal pathfindergoal) {
+        this.d.add(new PathfinderGoalWrapped(i, pathfindergoal));
+    }
+
+    public void a(PathfinderGoal pathfindergoal) {
+        this.d.stream().filter((pathfindergoalwrapped) -> {
+            return pathfindergoalwrapped.j() == pathfindergoal;
+        }).filter(PathfinderGoalWrapped::g).forEach(PathfinderGoalWrapped::d);
+        this.d.removeIf((pathfindergoalwrapped) -> {
+            return pathfindergoalwrapped.j() == pathfindergoal;
+        });
+    }
+
+    public void doTick() {
+        GameProfilerFiller gameprofilerfiller = (GameProfilerFiller) this.e.get();
+
+        gameprofilerfiller.enter("goalCleanup");
+        this.d().filter((pathfindergoalwrapped) -> {
+            boolean flag;
+
+            if (pathfindergoalwrapped.g()) {
+                Stream stream = pathfindergoalwrapped.i().stream();
+                EnumSet enumset = this.f;
+
+                this.f.getClass();
+                if (!stream.anyMatch(enumset::contains) && pathfindergoalwrapped.b()) {
+                    flag = false;
+                    return flag;
+                }
+            }
+
+            flag = true;
+            return flag;
+        }).forEach(PathfinderGoal::d);
+        this.c.forEach((pathfindergoal_type, pathfindergoalwrapped) -> {
+            if (!pathfindergoalwrapped.g()) {
+                this.c.remove(pathfindergoal_type);
+            }
+
+        });
+        gameprofilerfiller.exit();
+        gameprofilerfiller.enter("goalUpdate");
+        this.d.stream().filter((pathfindergoalwrapped) -> {
+            return !pathfindergoalwrapped.g();
+        }).filter((pathfindergoalwrapped) -> {
+            Stream stream = pathfindergoalwrapped.i().stream();
+            EnumSet enumset = this.f;
+
+            this.f.getClass();
+            return stream.noneMatch(enumset::contains);
+        }).filter((pathfindergoalwrapped) -> {
+            return pathfindergoalwrapped.i().stream().allMatch((pathfindergoal_type) -> {
+                return ((PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b)).a(pathfindergoalwrapped);
+            });
+        }).filter(PathfinderGoalWrapped::a).forEach((pathfindergoalwrapped) -> {
+            pathfindergoalwrapped.i().forEach((pathfindergoal_type) -> {
+                PathfinderGoalWrapped pathfindergoalwrapped1 = (PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b);
+
+                pathfindergoalwrapped1.d();
+                this.c.put(pathfindergoal_type, pathfindergoalwrapped);
+            });
+            pathfindergoalwrapped.c();
+        });
+        gameprofilerfiller.exit();
+        gameprofilerfiller.enter("goalTick");
+        this.d().forEach(PathfinderGoalWrapped::e);
+        gameprofilerfiller.exit();
+    }
+
+    public Stream<PathfinderGoalWrapped> d() {
+        return this.d.stream().filter(PathfinderGoalWrapped::g);
+    }
+
+    public void a(PathfinderGoal.Type pathfindergoal_type) {
+        this.f.add(pathfindergoal_type);
+    }
+
+    public void b(PathfinderGoal.Type pathfindergoal_type) {
+        this.f.remove(pathfindergoal_type);
+    }
+
+    public void a(PathfinderGoal.Type pathfindergoal_type, boolean flag) {
+        if (flag) {
+            this.b(pathfindergoal_type);
+        } else {
+            this.a(pathfindergoal_type);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalWrapped.java b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalWrapped.java
new file mode 100644
index 0000000000000000000000000000000000000000..7395335ee97237376d34e315ea1d7d46766b278a
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/PathfinderGoalWrapped.java
@@ -0,0 +1,86 @@
+package net.minecraft.world.entity.ai.goal;
+
+import java.util.EnumSet;
+import javax.annotation.Nullable;
+
+public class PathfinderGoalWrapped extends PathfinderGoal {
+
+    private final PathfinderGoal a;
+    private final int b;
+    private boolean c;
+
+    public PathfinderGoalWrapped(int i, PathfinderGoal pathfindergoal) {
+        this.b = i;
+        this.a = pathfindergoal;
+    }
+
+    public boolean a(PathfinderGoalWrapped pathfindergoalwrapped) {
+        return this.C_() && pathfindergoalwrapped.h() < this.h();
+    }
+
+    @Override
+    public boolean a() {
+        return this.a.a();
+    }
+
+    @Override
+    public boolean b() {
+        return this.a.b();
+    }
+
+    @Override
+    public boolean C_() {
+        return this.a.C_();
+    }
+
+    @Override
+    public void c() {
+        if (!this.c) {
+            this.c = true;
+            this.a.c();
+        }
+    }
+
+    @Override
+    public void d() {
+        if (this.c) {
+            this.c = false;
+            this.a.d();
+        }
+    }
+
+    @Override
+    public void e() {
+        this.a.e();
+    }
+
+    @Override
+    public void a(EnumSet<PathfinderGoal.Type> enumset) {
+        this.a.a(enumset);
+    }
+
+    @Override
+    public EnumSet<PathfinderGoal.Type> i() {
+        return this.a.i();
+    }
+
+    public boolean g() {
+        return this.c;
+    }
+
+    public int h() {
+        return this.b;
+    }
+
+    public PathfinderGoal j() {
+        return this.a;
+    }
+
+    public boolean equals(@Nullable Object object) {
+        return this == object ? true : (object != null && this.getClass() == object.getClass() ? this.a.equals(((PathfinderGoalWrapped) object).a) : false);
+    }
+
+    public int hashCode() {
+        return this.a.hashCode();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/gossip/Reputation.java b/src/main/java/net/minecraft/world/entity/ai/gossip/Reputation.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7f5e4a499c1f6fb1450e536dbf117a8af3b3b84
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/gossip/Reputation.java
@@ -0,0 +1,233 @@
+package net.minecraft.world.entity.ai.gossip;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Dynamic;
+import com.mojang.serialization.DynamicOps;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.UUID;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.MinecraftSerializableUUID;
+
+public class Reputation {
+
+    private final Map<UUID, Reputation.a> a = Maps.newHashMap();
+
+    public Reputation() {}
+
+    public void b() {
+        Iterator iterator = this.a.values().iterator();
+
+        while (iterator.hasNext()) {
+            Reputation.a reputation_a = (Reputation.a) iterator.next();
+
+            reputation_a.a();
+            if (reputation_a.b()) {
+                iterator.remove();
+            }
+        }
+
+    }
+
+    private Stream<Reputation.b> c() {
+        return this.a.entrySet().stream().flatMap((entry) -> {
+            return ((Reputation.a) entry.getValue()).a((UUID) entry.getKey());
+        });
+    }
+
+    private Collection<Reputation.b> a(Random random, int i) {
+        List<Reputation.b> list = (List) this.c().collect(Collectors.toList());
+
+        if (list.isEmpty()) {
+            return Collections.emptyList();
+        } else {
+            int[] aint = new int[list.size()];
+            int j = 0;
+
+            for (int k = 0; k < list.size(); ++k) {
+                Reputation.b reputation_b = (Reputation.b) list.get(k);
+
+                j += Math.abs(reputation_b.a());
+                aint[k] = j - 1;
+            }
+
+            Set<Reputation.b> set = Sets.newIdentityHashSet();
+
+            for (int l = 0; l < i; ++l) {
+                int i1 = random.nextInt(j);
+                int j1 = Arrays.binarySearch(aint, i1);
+
+                set.add(list.get(j1 < 0 ? -j1 - 1 : j1));
+            }
+
+            return set;
+        }
+    }
+
+    private Reputation.a a(UUID uuid) {
+        return (Reputation.a) this.a.computeIfAbsent(uuid, (uuid1) -> {
+            return new Reputation.a();
+        });
+    }
+
+    public void a(Reputation reputation, Random random, int i) {
+        Collection<Reputation.b> collection = reputation.a(random, i);
+
+        collection.forEach((reputation_b) -> {
+            int j = reputation_b.c - reputation_b.b.j;
+
+            if (j >= 2) {
+                this.a(reputation_b.a).a.mergeInt(reputation_b.b, j, Reputation::a);
+            }
+
+        });
+    }
+
+    public int a(UUID uuid, Predicate<ReputationType> predicate) {
+        Reputation.a reputation_a = (Reputation.a) this.a.get(uuid);
+
+        return reputation_a != null ? reputation_a.a(predicate) : 0;
+    }
+
+    public void a(UUID uuid, ReputationType reputationtype, int i) {
+        Reputation.a reputation_a = this.a(uuid);
+
+        reputation_a.a.mergeInt(reputationtype, i, (integer, integer1) -> {
+            return this.a(reputationtype, integer, integer1);
+        });
+        reputation_a.a(reputationtype);
+        if (reputation_a.b()) {
+            this.a.remove(uuid);
+        }
+
+    }
+
+    public <T> Dynamic<T> a(DynamicOps<T> dynamicops) {
+        return new Dynamic(dynamicops, dynamicops.createList(this.c().map((reputation_b) -> {
+            return reputation_b.a(dynamicops);
+        }).map(Dynamic::getValue)));
+    }
+
+    public void a(Dynamic<?> dynamic) {
+        dynamic.asStream().map(Reputation.b::a).flatMap((dataresult) -> {
+            return SystemUtils.a(dataresult.result());
+        }).forEach((reputation_b) -> {
+            this.a(reputation_b.a).a.put(reputation_b.b, reputation_b.c);
+        });
+    }
+
+    private static int a(int i, int j) {
+        return Math.max(i, j);
+    }
+
+    private int a(ReputationType reputationtype, int i, int j) {
+        int k = i + j;
+
+        return k > reputationtype.h ? Math.max(reputationtype.h, i) : k;
+    }
+
+    static class a {
+
+        private final Object2IntMap<ReputationType> a;
+
+        private a() {
+            this.a = new Object2IntOpenHashMap();
+        }
+
+        public int a(Predicate<ReputationType> predicate) {
+            return this.a.object2IntEntrySet().stream().filter((entry) -> {
+                return predicate.test(entry.getKey());
+            }).mapToInt((entry) -> {
+                return entry.getIntValue() * ((ReputationType) entry.getKey()).g;
+            }).sum();
+        }
+
+        public Stream<Reputation.b> a(UUID uuid) {
+            return this.a.object2IntEntrySet().stream().map((entry) -> {
+                return new Reputation.b(uuid, (ReputationType) entry.getKey(), entry.getIntValue());
+            });
+        }
+
+        public void a() {
+            ObjectIterator objectiterator = this.a.object2IntEntrySet().iterator();
+
+            while (objectiterator.hasNext()) {
+                Entry<ReputationType> entry = (Entry) objectiterator.next();
+                int i = entry.getIntValue() - ((ReputationType) entry.getKey()).i;
+
+                if (i < 2) {
+                    objectiterator.remove();
+                } else {
+                    entry.setValue(i);
+                }
+            }
+
+        }
+
+        public boolean b() {
+            return this.a.isEmpty();
+        }
+
+        public void a(ReputationType reputationtype) {
+            int i = this.a.getInt(reputationtype);
+
+            if (i > reputationtype.h) {
+                this.a.put(reputationtype, reputationtype.h);
+            }
+
+            if (i < 2) {
+                this.b(reputationtype);
+            }
+
+        }
+
+        public void b(ReputationType reputationtype) {
+            this.a.removeInt(reputationtype);
+        }
+    }
+
+    static class b {
+
+        public final UUID a;
+        public final ReputationType b;
+        public final int c;
+
+        public b(UUID uuid, ReputationType reputationtype, int i) {
+            this.a = uuid;
+            this.b = reputationtype;
+            this.c = i;
+        }
+
+        public int a() {
+            return this.c * this.b.g;
+        }
+
+        public String toString() {
+            return "GossipEntry{target=" + this.a + ", type=" + this.b + ", value=" + this.c + '}';
+        }
+
+        public <T> Dynamic<T> a(DynamicOps<T> dynamicops) {
+            return new Dynamic(dynamicops, dynamicops.createMap(ImmutableMap.of(dynamicops.createString("Target"), MinecraftSerializableUUID.a.encodeStart(dynamicops, this.a).result().orElseThrow(RuntimeException::new), dynamicops.createString("Type"), dynamicops.createString(this.b.f), dynamicops.createString("Value"), dynamicops.createInt(this.c))));
+        }
+
+        public static DataResult<Reputation.b> a(Dynamic<?> dynamic) {
+            return DataResult.unbox(DataResult.instance().group(dynamic.get("Target").read(MinecraftSerializableUUID.a), dynamic.get("Type").asString().map(ReputationType::a), dynamic.get("Value").asNumber().map(Number::intValue)).apply(DataResult.instance(), Reputation.b::new));
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/gossip/ReputationType.java b/src/main/java/net/minecraft/world/entity/ai/gossip/ReputationType.java
new file mode 100644
index 0000000000000000000000000000000000000000..89651e6e3bb1cfbb8eb8a120b3c3e553cd831a68
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/gossip/ReputationType.java
@@ -0,0 +1,34 @@
+package net.minecraft.world.entity.ai.gossip;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+
+public enum ReputationType {
+
+    MAJOR_NEGATIVE("major_negative", -5, 100, 10, 10), MINOR_NEGATIVE("minor_negative", -1, 200, 20, 20), MINOR_POSITIVE("minor_positive", 1, 200, 1, 5), MAJOR_POSITIVE("major_positive", 5, 100, 0, 100), TRADING("trading", 1, 25, 2, 20);
+
+    public final String f;
+    public final int g;
+    public final int h;
+    public final int i;
+    public final int j;
+    private static final Map<String, ReputationType> k = (Map) Stream.of(values()).collect(ImmutableMap.toImmutableMap((reputationtype) -> {
+        return reputationtype.f;
+    }, Function.identity()));
+
+    private ReputationType(String s, int i, int j, int k, int l) {
+        this.f = s;
+        this.g = i;
+        this.h = j;
+        this.i = k;
+        this.j = l;
+    }
+
+    @Nullable
+    public static ReputationType a(String s) {
+        return (ReputationType) ReputationType.k.get(s);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/Navigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/Navigation.java
new file mode 100644
index 0000000000000000000000000000000000000000..942e03578836524ba746bc37699677eb06cc7803
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/Navigation.java
@@ -0,0 +1,260 @@
+package net.minecraft.world.entity.ai.navigation;
+
+import java.util.Iterator;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.pathfinder.PathEntity;
+import net.minecraft.world.level.pathfinder.PathMode;
+import net.minecraft.world.level.pathfinder.PathPoint;
+import net.minecraft.world.level.pathfinder.PathType;
+import net.minecraft.world.level.pathfinder.Pathfinder;
+import net.minecraft.world.level.pathfinder.PathfinderNormal;
+import net.minecraft.world.phys.Vec3D;
+
+public class Navigation extends NavigationAbstract {
+
+    private boolean p;
+
+    public Navigation(EntityInsentient entityinsentient, World world) {
+        super(entityinsentient, world);
+    }
+
+    @Override
+    protected Pathfinder a(int i) {
+        this.o = new PathfinderNormal();
+        this.o.a(true);
+        return new Pathfinder(this.o, i);
+    }
+
+    @Override
+    protected boolean a() {
+        return this.a.isOnGround() || this.p() || this.a.isPassenger();
+    }
+
+    @Override
+    protected Vec3D b() {
+        return new Vec3D(this.a.locX(), (double) this.u(), this.a.locZ());
+    }
+
+    @Override
+    public PathEntity a(BlockPosition blockposition, int i) {
+        BlockPosition blockposition1;
+
+        if (this.b.getType(blockposition).isAir()) {
+            for (blockposition1 = blockposition.down(); blockposition1.getY() > 0 && this.b.getType(blockposition1).isAir(); blockposition1 = blockposition1.down()) {
+                ;
+            }
+
+            if (blockposition1.getY() > 0) {
+                return super.a(blockposition1.up(), i);
+            }
+
+            while (blockposition1.getY() < this.b.getBuildHeight() && this.b.getType(blockposition1).isAir()) {
+                blockposition1 = blockposition1.up();
+            }
+
+            blockposition = blockposition1;
+        }
+
+        if (!this.b.getType(blockposition).getMaterial().isBuildable()) {
+            return super.a(blockposition, i);
+        } else {
+            for (blockposition1 = blockposition.up(); blockposition1.getY() < this.b.getBuildHeight() && this.b.getType(blockposition1).getMaterial().isBuildable(); blockposition1 = blockposition1.up()) {
+                ;
+            }
+
+            return super.a(blockposition1, i);
+        }
+    }
+
+    @Override
+    public PathEntity a(Entity entity, int i) {
+        return this.a(entity.getChunkCoordinates(), i);
+    }
+
+    private int u() {
+        if (this.a.isInWater() && this.r()) {
+            int i = MathHelper.floor(this.a.locY());
+            Block block = this.b.getType(new BlockPosition(this.a.locX(), (double) i, this.a.locZ())).getBlock();
+            int j = 0;
+
+            do {
+                if (block != Blocks.WATER) {
+                    return i;
+                }
+
+                ++i;
+                block = this.b.getType(new BlockPosition(this.a.locX(), (double) i, this.a.locZ())).getBlock();
+                ++j;
+            } while (j <= 16);
+
+            return MathHelper.floor(this.a.locY());
+        } else {
+            return MathHelper.floor(this.a.locY() + 0.5D);
+        }
+    }
+
+    @Override
+    protected void D_() {
+        super.D_();
+        if (this.p) {
+            if (this.b.e(new BlockPosition(this.a.locX(), this.a.locY() + 0.5D, this.a.locZ()))) {
+                return;
+            }
+
+            for (int i = 0; i < this.c.e(); ++i) {
+                PathPoint pathpoint = this.c.a(i);
+
+                if (this.b.e(new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c))) {
+                    this.c.b(i);
+                    return;
+                }
+            }
+        }
+
+    }
+
+    @Override
+    protected boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k) {
+        int l = MathHelper.floor(vec3d.x);
+        int i1 = MathHelper.floor(vec3d.z);
+        double d0 = vec3d1.x - vec3d.x;
+        double d1 = vec3d1.z - vec3d.z;
+        double d2 = d0 * d0 + d1 * d1;
+
+        if (d2 < 1.0E-8D) {
+            return false;
+        } else {
+            double d3 = 1.0D / Math.sqrt(d2);
+
+            d0 *= d3;
+            d1 *= d3;
+            i += 2;
+            k += 2;
+            if (!this.a(l, MathHelper.floor(vec3d.y), i1, i, j, k, vec3d, d0, d1)) {
+                return false;
+            } else {
+                i -= 2;
+                k -= 2;
+                double d4 = 1.0D / Math.abs(d0);
+                double d5 = 1.0D / Math.abs(d1);
+                double d6 = (double) l - vec3d.x;
+                double d7 = (double) i1 - vec3d.z;
+
+                if (d0 >= 0.0D) {
+                    ++d6;
+                }
+
+                if (d1 >= 0.0D) {
+                    ++d7;
+                }
+
+                d6 /= d0;
+                d7 /= d1;
+                int j1 = d0 < 0.0D ? -1 : 1;
+                int k1 = d1 < 0.0D ? -1 : 1;
+                int l1 = MathHelper.floor(vec3d1.x);
+                int i2 = MathHelper.floor(vec3d1.z);
+                int j2 = l1 - l;
+                int k2 = i2 - i1;
+
+                do {
+                    if (j2 * j1 <= 0 && k2 * k1 <= 0) {
+                        return true;
+                    }
+
+                    if (d6 < d7) {
+                        d6 += d4;
+                        l += j1;
+                        j2 = l1 - l;
+                    } else {
+                        d7 += d5;
+                        i1 += k1;
+                        k2 = i2 - i1;
+                    }
+                } while (this.a(l, MathHelper.floor(vec3d.y), i1, i, j, k, vec3d, d0, d1));
+
+                return false;
+            }
+        }
+    }
+
+    private boolean a(int i, int j, int k, int l, int i1, int j1, Vec3D vec3d, double d0, double d1) {
+        int k1 = i - l / 2;
+        int l1 = k - j1 / 2;
+
+        if (!this.b(k1, j, l1, l, i1, j1, vec3d, d0, d1)) {
+            return false;
+        } else {
+            for (int i2 = k1; i2 < k1 + l; ++i2) {
+                for (int j2 = l1; j2 < l1 + j1; ++j2) {
+                    double d2 = (double) i2 + 0.5D - vec3d.x;
+                    double d3 = (double) j2 + 0.5D - vec3d.z;
+
+                    if (d2 * d0 + d3 * d1 >= 0.0D) {
+                        PathType pathtype = this.o.a(this.b, i2, j - 1, j2, this.a, l, i1, j1, true, true);
+
+                        if (!this.a(pathtype)) {
+                            return false;
+                        }
+
+                        pathtype = this.o.a(this.b, i2, j, j2, this.a, l, i1, j1, true, true);
+                        float f = this.a.a(pathtype);
+
+                        if (f < 0.0F || f >= 8.0F) {
+                            return false;
+                        }
+
+                        if (pathtype == PathType.DAMAGE_FIRE || pathtype == PathType.DANGER_FIRE || pathtype == PathType.DAMAGE_OTHER) {
+                            return false;
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+
+    protected boolean a(PathType pathtype) {
+        return pathtype == PathType.WATER ? false : (pathtype == PathType.LAVA ? false : pathtype != PathType.OPEN);
+    }
+
+    private boolean b(int i, int j, int k, int l, int i1, int j1, Vec3D vec3d, double d0, double d1) {
+        Iterator iterator = BlockPosition.a(new BlockPosition(i, j, k), new BlockPosition(i + l - 1, j + i1 - 1, k + j1 - 1)).iterator();
+
+        BlockPosition blockposition;
+        double d2;
+        double d3;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
+            }
+
+            blockposition = (BlockPosition) iterator.next();
+            d2 = (double) blockposition.getX() + 0.5D - vec3d.x;
+            d3 = (double) blockposition.getZ() + 0.5D - vec3d.z;
+        } while (d2 * d0 + d3 * d1 < 0.0D || this.b.getType(blockposition).a((IBlockAccess) this.b, blockposition, PathMode.LAND));
+
+        return false;
+    }
+
+    public void a(boolean flag) {
+        this.o.b(flag);
+    }
+
+    public boolean f() {
+        return this.o.c();
+    }
+
+    public void c(boolean flag) {
+        this.p = flag;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/NavigationAbstract.java b/src/main/java/net/minecraft/world/entity/ai/navigation/NavigationAbstract.java
new file mode 100644
index 0000000000000000000000000000000000000000..8848a7552a0ef3944560a71f71620c6bd0f08c10
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/NavigationAbstract.java
@@ -0,0 +1,381 @@
+package net.minecraft.world.entity.ai.navigation;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IPosition;
+import net.minecraft.network.protocol.game.PacketDebug;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.level.ChunkCache;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.pathfinder.PathEntity;
+import net.minecraft.world.level.pathfinder.PathPoint;
+import net.minecraft.world.level.pathfinder.Pathfinder;
+import net.minecraft.world.level.pathfinder.PathfinderAbstract;
+import net.minecraft.world.level.pathfinder.PathfinderNormal;
+import net.minecraft.world.phys.Vec3D;
+
+public abstract class NavigationAbstract {
+
+    protected final EntityInsentient a;
+    protected final World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    protected int e;
+    protected int f;
+    protected Vec3D g;
+    protected BaseBlockPosition h;
+    protected long i;
+    protected long j;
+    protected double k;
+    protected float l;
+    protected boolean m;
+    protected long n;
+    protected PathfinderAbstract o;
+    private BlockPosition p;
+    private int q;
+    private float r;
+    private final Pathfinder s;
+    private boolean t;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.g = Vec3D.ORIGIN;
+        this.h = BaseBlockPosition.ZERO;
+        this.l = 0.5F;
+        this.r = 1.0F;
+        this.a = entityinsentient;
+        this.b = world;
+        int i = MathHelper.floor(entityinsentient.b(GenericAttributes.FOLLOW_RANGE) * 16.0D);
+
+        this.s = this.a(i);
+    }
+
+    public void g() {
+        this.r = 1.0F;
+    }
+
+    public void a(float f) {
+        this.r = f;
+    }
+
+    public BlockPosition h() {
+        return this.p;
+    }
+
+    protected abstract Pathfinder a(int i);
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public boolean i() {
+        return this.m;
+    }
+
+    public void j() {
+        if (this.b.getTime() - this.n > 20L) {
+            if (this.p != null) {
+                this.c = null;
+                this.c = this.a(this.p, this.q);
+                this.n = this.b.getTime();
+                this.m = false;
+            }
+        } else {
+            this.m = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2, int i) {
+        return this.a(new BlockPosition(d0, d1, d2), i);
+    }
+
+    @Nullable
+    public PathEntity a(Stream<BlockPosition> stream, int i) {
+        return this.a((Set) stream.collect(Collectors.toSet()), 8, false, i);
+    }
+
+    @Nullable
+    public PathEntity a(Set<BlockPosition> set, int i) {
+        return this.a(set, 8, false, i);
+    }
+
+    @Nullable
+    public PathEntity a(BlockPosition blockposition, int i) {
+        return this.a(ImmutableSet.of(blockposition), 8, false, i);
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity, int i) {
+        return this.a(ImmutableSet.of(entity.getChunkCoordinates()), 16, true, i);
+    }
+
+    @Nullable
+    protected PathEntity a(Set<BlockPosition> set, int i, boolean flag, int j) {
+        if (set.isEmpty()) {
+            return null;
+        } else if (this.a.locY() < 0.0D) {
+            return null;
+        } else if (!this.a()) {
+            return null;
+        } else if (this.c != null && !this.c.c() && set.contains(this.p)) {
+            return this.c;
+        } else {
+            this.b.getMethodProfiler().enter("pathfind");
+            float f = (float) this.a.b(GenericAttributes.FOLLOW_RANGE);
+            BlockPosition blockposition = flag ? this.a.getChunkCoordinates().up() : this.a.getChunkCoordinates();
+            int k = (int) (f + (float) i);
+            ChunkCache chunkcache = new ChunkCache(this.b, blockposition.b(-k, -k, -k), blockposition.b(k, k, k));
+            PathEntity pathentity = this.s.a(chunkcache, this.a, set, f, j, this.r);
+
+            this.b.getMethodProfiler().exit();
+            if (pathentity != null && pathentity.m() != null) {
+                this.p = pathentity.m();
+                this.q = j;
+                this.f();
+            }
+
+            return pathentity;
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        return this.a(this.a(d0, d1, d2, 1), d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity, 1);
+
+        return pathentity != null && this.a(pathentity, d0);
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            if (this.m()) {
+                return false;
+            } else {
+                this.D_();
+                if (this.c.e() <= 0) {
+                    return false;
+                } else {
+                    this.d = d0;
+                    Vec3D vec3d = this.b();
+
+                    this.f = this.e;
+                    this.g = vec3d;
+                    return true;
+                }
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity k() {
+        return this.c;
+    }
+
+    public void c() {
+        ++this.e;
+        if (this.m) {
+            this.j();
+        }
+
+        if (!this.m()) {
+            Vec3D vec3d;
+
+            if (this.a()) {
+                this.l();
+            } else if (this.c != null && !this.c.c()) {
+                vec3d = this.b();
+                Vec3D vec3d1 = this.c.a((Entity) this.a);
+
+                if (vec3d.y > vec3d1.y && !this.a.isOnGround() && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.a();
+                }
+            }
+
+            PacketDebug.a(this.b, this.a, this.c, this.l);
+            if (!this.m()) {
+                vec3d = this.c.a((Entity) this.a);
+                BlockPosition blockposition = new BlockPosition(vec3d);
+
+                this.a.getControllerMove().a(vec3d.x, this.b.getType(blockposition.down()).isAir() ? vec3d.y : PathfinderNormal.a((IBlockAccess) this.b, blockposition), vec3d.z, this.d);
+            }
+        }
+    }
+
+    protected void l() {
+        Vec3D vec3d = this.b();
+
+        this.l = this.a.getWidth() > 0.75F ? this.a.getWidth() / 2.0F : 0.75F - this.a.getWidth() / 2.0F;
+        BlockPosition blockposition = this.c.g();
+        double d0 = Math.abs(this.a.locX() - ((double) blockposition.getX() + 0.5D));
+        double d1 = Math.abs(this.a.locY() - (double) blockposition.getY());
+        double d2 = Math.abs(this.a.locZ() - ((double) blockposition.getZ() + 0.5D));
+        boolean flag = d0 < (double) this.l && d2 < (double) this.l && d1 < 1.0D;
+
+        if (flag || this.a.b(this.c.h().l) && this.b(vec3d)) {
+            this.c.a();
+        }
+
+        this.a(vec3d);
+    }
+
+    private boolean b(Vec3D vec3d) {
+        if (this.c.f() + 1 >= this.c.e()) {
+            return false;
+        } else {
+            Vec3D vec3d1 = Vec3D.c((BaseBlockPosition) this.c.g());
+
+            if (!vec3d.a((IPosition) vec3d1, 2.0D)) {
+                return false;
+            } else {
+                Vec3D vec3d2 = Vec3D.c((BaseBlockPosition) this.c.d(this.c.f() + 1));
+                Vec3D vec3d3 = vec3d2.d(vec3d1);
+                Vec3D vec3d4 = vec3d.d(vec3d1);
+
+                return vec3d3.b(vec3d4) > 0.0D;
+            }
+        }
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.e - this.f > 100) {
+            if (vec3d.distanceSquared(this.g) < 2.25D) {
+                this.t = true;
+                this.o();
+            } else {
+                this.t = false;
+            }
+
+            this.f = this.e;
+            this.g = vec3d;
+        }
+
+        if (this.c != null && !this.c.c()) {
+            BlockPosition blockposition = this.c.g();
+
+            if (blockposition.equals(this.h)) {
+                this.i += SystemUtils.getMonotonicMillis() - this.j;
+            } else {
+                this.h = blockposition;
+                double d0 = vec3d.f(Vec3D.c(this.h));
+
+                this.k = this.a.dN() > 0.0F ? d0 / (double) this.a.dN() * 1000.0D : 0.0D;
+            }
+
+            if (this.k > 0.0D && (double) this.i > this.k * 3.0D) {
+                this.e();
+            }
+
+            this.j = SystemUtils.getMonotonicMillis();
+        }
+
+    }
+
+    private void e() {
+        this.f();
+        this.o();
+    }
+
+    private void f() {
+        this.h = BaseBlockPosition.ZERO;
+        this.i = 0L;
+        this.k = 0.0D;
+        this.t = false;
+    }
+
+    public boolean m() {
+        return this.c == null || this.c.c();
+    }
+
+    public boolean n() {
+        return !this.m();
+    }
+
+    public void o() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D b();
+
+    protected abstract boolean a();
+
+    protected boolean p() {
+        return this.a.aH() || this.a.aQ();
+    }
+
+    protected void D_() {
+        if (this.c != null) {
+            for (int i = 0; i < this.c.e(); ++i) {
+                PathPoint pathpoint = this.c.a(i);
+                PathPoint pathpoint1 = i + 1 < this.c.e() ? this.c.a(i + 1) : null;
+                IBlockData iblockdata = this.b.getType(new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c));
+
+                if (iblockdata.a(Blocks.CAULDRON)) {
+                    this.c.a(i, pathpoint.a(pathpoint.a, pathpoint.b + 1, pathpoint.c));
+                    if (pathpoint1 != null && pathpoint.b >= pathpoint1.b) {
+                        this.c.a(i + 1, pathpoint.a(pathpoint1.a, pathpoint.b + 1, pathpoint1.c));
+                    }
+                }
+            }
+
+        }
+    }
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean a(BlockPosition blockposition) {
+        BlockPosition blockposition1 = blockposition.down();
+
+        return this.b.getType(blockposition1).i(this.b, blockposition1);
+    }
+
+    public PathfinderAbstract q() {
+        return this.o;
+    }
+
+    public void d(boolean flag) {
+        this.o.c(flag);
+    }
+
+    public boolean r() {
+        return this.o.e();
+    }
+
+    public void b(BlockPosition blockposition) {
+        if (this.c != null && !this.c.c() && this.c.e() != 0) {
+            PathPoint pathpoint = this.c.d();
+            Vec3D vec3d = new Vec3D(((double) pathpoint.a + this.a.locX()) / 2.0D, ((double) pathpoint.b + this.a.locY()) / 2.0D, ((double) pathpoint.c + this.a.locZ()) / 2.0D);
+
+            if (blockposition.a((IPosition) vec3d, (double) (this.c.e() - this.c.f()))) {
+                this.j();
+            }
+
+        }
+    }
+
+    public boolean t() {
+        return this.t;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/NavigationFlying.java b/src/main/java/net/minecraft/world/entity/ai/navigation/NavigationFlying.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e1efe7a048f64d494260d10a4ae5dba86af5e6c
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/NavigationFlying.java
@@ -0,0 +1,152 @@
+package net.minecraft.world.entity.ai.navigation;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.network.protocol.game.PacketDebug;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.pathfinder.PathEntity;
+import net.minecraft.world.level.pathfinder.Pathfinder;
+import net.minecraft.world.level.pathfinder.PathfinderFlying;
+import net.minecraft.world.phys.Vec3D;
+
+public class NavigationFlying extends NavigationAbstract {
+
+    public NavigationFlying(EntityInsentient entityinsentient, World world) {
+        super(entityinsentient, world);
+    }
+
+    @Override
+    protected Pathfinder a(int i) {
+        this.o = new PathfinderFlying();
+        this.o.a(true);
+        return new Pathfinder(this.o, i);
+    }
+
+    @Override
+    protected boolean a() {
+        return this.r() && this.p() || !this.a.isPassenger();
+    }
+
+    @Override
+    protected Vec3D b() {
+        return this.a.getPositionVector();
+    }
+
+    @Override
+    public PathEntity a(Entity entity, int i) {
+        return this.a(entity.getChunkCoordinates(), i);
+    }
+
+    @Override
+    public void c() {
+        ++this.e;
+        if (this.m) {
+            this.j();
+        }
+
+        if (!this.m()) {
+            Vec3D vec3d;
+
+            if (this.a()) {
+                this.l();
+            } else if (this.c != null && !this.c.c()) {
+                vec3d = this.c.a((Entity) this.a);
+                if (MathHelper.floor(this.a.locX()) == MathHelper.floor(vec3d.x) && MathHelper.floor(this.a.locY()) == MathHelper.floor(vec3d.y) && MathHelper.floor(this.a.locZ()) == MathHelper.floor(vec3d.z)) {
+                    this.c.a();
+                }
+            }
+
+            PacketDebug.a(this.b, this.a, this.c, this.l);
+            if (!this.m()) {
+                vec3d = this.c.a((Entity) this.a);
+                this.a.getControllerMove().a(vec3d.x, vec3d.y, vec3d.z, this.d);
+            }
+        }
+    }
+
+    @Override
+    protected boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k) {
+        int l = MathHelper.floor(vec3d.x);
+        int i1 = MathHelper.floor(vec3d.y);
+        int j1 = MathHelper.floor(vec3d.z);
+        double d0 = vec3d1.x - vec3d.x;
+        double d1 = vec3d1.y - vec3d.y;
+        double d2 = vec3d1.z - vec3d.z;
+        double d3 = d0 * d0 + d1 * d1 + d2 * d2;
+
+        if (d3 < 1.0E-8D) {
+            return false;
+        } else {
+            double d4 = 1.0D / Math.sqrt(d3);
+
+            d0 *= d4;
+            d1 *= d4;
+            d2 *= d4;
+            double d5 = 1.0D / Math.abs(d0);
+            double d6 = 1.0D / Math.abs(d1);
+            double d7 = 1.0D / Math.abs(d2);
+            double d8 = (double) l - vec3d.x;
+            double d9 = (double) i1 - vec3d.y;
+            double d10 = (double) j1 - vec3d.z;
+
+            if (d0 >= 0.0D) {
+                ++d8;
+            }
+
+            if (d1 >= 0.0D) {
+                ++d9;
+            }
+
+            if (d2 >= 0.0D) {
+                ++d10;
+            }
+
+            d8 /= d0;
+            d9 /= d1;
+            d10 /= d2;
+            int k1 = d0 < 0.0D ? -1 : 1;
+            int l1 = d1 < 0.0D ? -1 : 1;
+            int i2 = d2 < 0.0D ? -1 : 1;
+            int j2 = MathHelper.floor(vec3d1.x);
+            int k2 = MathHelper.floor(vec3d1.y);
+            int l2 = MathHelper.floor(vec3d1.z);
+            int i3 = j2 - l;
+            int j3 = k2 - i1;
+            int k3 = l2 - j1;
+
+            while (i3 * k1 > 0 || j3 * l1 > 0 || k3 * i2 > 0) {
+                if (d8 < d10 && d8 <= d9) {
+                    d8 += d5;
+                    l += k1;
+                    i3 = j2 - l;
+                } else if (d9 < d8 && d9 <= d10) {
+                    d9 += d6;
+                    i1 += l1;
+                    j3 = k2 - i1;
+                } else {
+                    d10 += d7;
+                    j1 += i2;
+                    k3 = l2 - j1;
+                }
+            }
+
+            return true;
+        }
+    }
+
+    public void a(boolean flag) {
+        this.o.b(flag);
+    }
+
+    public void b(boolean flag) {
+        this.o.a(flag);
+    }
+
+    @Override
+    public boolean a(BlockPosition blockposition) {
+        return this.b.getType(blockposition).a((IBlockAccess) this.b, blockposition, (Entity) this.a);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SensorGolemLastSeen.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorGolemLastSeen.java
new file mode 100644
index 0000000000000000000000000000000000000000..41f1aecbf6b506231a1b3b525fe0ce23b35c7840
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorGolemLastSeen.java
@@ -0,0 +1,50 @@
+package net.minecraft.world.entity.ai.sensing;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+
+public class SensorGolemLastSeen extends Sensor<EntityLiving> {
+
+    public SensorGolemLastSeen() {
+        this(200);
+    }
+
+    public SensorGolemLastSeen(int i) {
+        super(i);
+    }
+
+    @Override
+    protected void a(WorldServer worldserver, EntityLiving entityliving) {
+        a(entityliving);
+    }
+
+    @Override
+    public Set<MemoryModuleType<?>> a() {
+        return ImmutableSet.of(MemoryModuleType.MOBS);
+    }
+
+    public static void a(EntityLiving entityliving) {
+        Optional<List<EntityLiving>> optional = entityliving.getBehaviorController().getMemory(MemoryModuleType.MOBS);
+
+        if (optional.isPresent()) {
+            boolean flag = ((List) optional.get()).stream().anyMatch((entityliving1) -> {
+                return entityliving1.getEntityType().equals(EntityTypes.IRON_GOLEM);
+            });
+
+            if (flag) {
+                b(entityliving);
+            }
+
+        }
+    }
+
+    public static void b(EntityLiving entityliving) {
+        entityliving.getBehaviorController().a(MemoryModuleType.GOLEM_DETECTED_RECENTLY, true, 600L);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestBed.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestBed.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e58a06860125243d0f7c062aca095dd2aae98f2
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestBed.java
@@ -0,0 +1,68 @@
+package net.minecraft.world.entity.ai.sensing;
+
+import com.google.common.collect.ImmutableSet;
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.village.poi.VillagePlace;
+import net.minecraft.world.entity.ai.village.poi.VillagePlaceType;
+import net.minecraft.world.level.pathfinder.PathEntity;
+
+public class SensorNearestBed extends Sensor<EntityInsentient> {
+
+    private final Long2LongMap a = new Long2LongOpenHashMap();
+    private int b;
+    private long c;
+
+    public SensorNearestBed() {
+        super(20);
+    }
+
+    @Override
+    public Set<MemoryModuleType<?>> a() {
+        return ImmutableSet.of(MemoryModuleType.NEAREST_BED);
+    }
+
+    protected void a(WorldServer worldserver, EntityInsentient entityinsentient) {
+        if (entityinsentient.isBaby()) {
+            this.b = 0;
+            this.c = worldserver.getTime() + (long) worldserver.getRandom().nextInt(20);
+            VillagePlace villageplace = worldserver.y();
+            Predicate<BlockPosition> predicate = (blockposition) -> {
+                long i = blockposition.asLong();
+
+                if (this.a.containsKey(i)) {
+                    return false;
+                } else if (++this.b >= 5) {
+                    return false;
+                } else {
+                    this.a.put(i, this.c + 40L);
+                    return true;
+                }
+            };
+            Stream<BlockPosition> stream = villageplace.a(VillagePlaceType.r.c(), predicate, entityinsentient.getChunkCoordinates(), 48, VillagePlace.Occupancy.ANY);
+            PathEntity pathentity = entityinsentient.getNavigation().a(stream, VillagePlaceType.r.d());
+
+            if (pathentity != null && pathentity.j()) {
+                BlockPosition blockposition = pathentity.m();
+                Optional<VillagePlaceType> optional = villageplace.c(blockposition);
+
+                if (optional.isPresent()) {
+                    entityinsentient.getBehaviorController().setMemory(MemoryModuleType.NEAREST_BED, (Object) blockposition);
+                }
+            } else if (this.b < 5) {
+                this.a.long2LongEntrySet().removeIf((entry) -> {
+                    return entry.getLongValue() < this.c;
+                });
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestItems.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestItems.java
new file mode 100644
index 0000000000000000000000000000000000000000..418cd6d8b40d35aa3be73eb12f2e3b75597238b9
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestItems.java
@@ -0,0 +1,44 @@
+package net.minecraft.world.entity.ai.sensing;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Stream;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.ai.BehaviorController;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.item.EntityItem;
+
+public class SensorNearestItems extends Sensor<EntityInsentient> {
+
+    public SensorNearestItems() {}
+
+    @Override
+    public Set<MemoryModuleType<?>> a() {
+        return ImmutableSet.of(MemoryModuleType.NEAREST_VISIBLE_WANTED_ITEM);
+    }
+
+    protected void a(WorldServer worldserver, EntityInsentient entityinsentient) {
+        BehaviorController<?> behaviorcontroller = entityinsentient.getBehaviorController();
+        List<EntityItem> list = worldserver.a(EntityItem.class, entityinsentient.getBoundingBox().grow(8.0D, 4.0D, 8.0D), (entityitem) -> {
+            return true;
+        });
+
+        entityinsentient.getClass();
+        list.sort(Comparator.comparingDouble(entityinsentient::h));
+        Stream stream = list.stream().filter((entityitem) -> {
+            return entityinsentient.i(entityitem.getItemStack());
+        }).filter((entityitem) -> {
+            return entityitem.a((Entity) entityinsentient, 9.0D);
+        });
+
+        entityinsentient.getClass();
+        Optional<EntityItem> optional = stream.filter(entityinsentient::hasLineOfSight).findFirst();
+
+        behaviorcontroller.setMemory(MemoryModuleType.NEAREST_VISIBLE_WANTED_ITEM, optional);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestLivingEntities.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestLivingEntities.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3bb1c02d80fcd3586030b07f84e7ebdd97d873e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestLivingEntities.java
@@ -0,0 +1,39 @@
+package net.minecraft.world.entity.ai.sensing;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.ai.BehaviorController;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.phys.AxisAlignedBB;
+
+public class SensorNearestLivingEntities extends Sensor<EntityLiving> {
+
+    public SensorNearestLivingEntities() {}
+
+    @Override
+    protected void a(WorldServer worldserver, EntityLiving entityliving) {
+        AxisAlignedBB axisalignedbb = entityliving.getBoundingBox().grow(16.0D, 16.0D, 16.0D);
+        List<EntityLiving> list = worldserver.a(EntityLiving.class, axisalignedbb, (entityliving1) -> {
+            return entityliving1 != entityliving && entityliving1.isAlive();
+        });
+
+        entityliving.getClass();
+        list.sort(Comparator.comparingDouble(entityliving::h));
+        BehaviorController<?> behaviorcontroller = entityliving.getBehaviorController();
+
+        behaviorcontroller.setMemory(MemoryModuleType.MOBS, (Object) list);
+        behaviorcontroller.setMemory(MemoryModuleType.VISIBLE_MOBS, list.stream().filter((entityliving1) -> {
+            return a(entityliving, entityliving1);
+        }).collect(Collectors.toList()));
+    }
+
+    @Override
+    public Set<MemoryModuleType<?>> a() {
+        return ImmutableSet.of(MemoryModuleType.MOBS, MemoryModuleType.VISIBLE_MOBS);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestPlayers.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestPlayers.java
new file mode 100644
index 0000000000000000000000000000000000000000..29abc7feec5358dce7d16958f0c5807f4bda992f
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorNearestPlayers.java
@@ -0,0 +1,47 @@
+package net.minecraft.world.entity.ai.sensing;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.IEntitySelector;
+import net.minecraft.world.entity.ai.BehaviorController;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.player.EntityHuman;
+
+public class SensorNearestPlayers extends Sensor<EntityLiving> {
+
+    public SensorNearestPlayers() {}
+
+    @Override
+    public Set<MemoryModuleType<?>> a() {
+        return ImmutableSet.of(MemoryModuleType.NEAREST_PLAYERS, MemoryModuleType.NEAREST_VISIBLE_PLAYER, MemoryModuleType.NEAREST_VISIBLE_TARGETABLE_PLAYER);
+    }
+
+    @Override
+    protected void a(WorldServer worldserver, EntityLiving entityliving) {
+        Stream stream = worldserver.getPlayers().stream().filter(IEntitySelector.g).filter((entityplayer) -> {
+            return entityliving.a((Entity) entityplayer, 16.0D);
+        });
+
+        entityliving.getClass();
+        List<EntityHuman> list = (List) stream.sorted(Comparator.comparingDouble(entityliving::h)).collect(Collectors.toList());
+        BehaviorController<?> behaviorcontroller = entityliving.getBehaviorController();
+
+        behaviorcontroller.setMemory(MemoryModuleType.NEAREST_PLAYERS, (Object) list);
+        List<EntityHuman> list1 = (List) list.stream().filter((entityhuman) -> {
+            return a(entityliving, (EntityLiving) entityhuman);
+        }).collect(Collectors.toList());
+
+        behaviorcontroller.setMemory(MemoryModuleType.NEAREST_VISIBLE_PLAYER, (Object) (list1.isEmpty() ? null : (EntityHuman) list1.get(0)));
+        Optional<EntityHuman> optional = list1.stream().filter(IEntitySelector.f).findFirst();
+
+        behaviorcontroller.setMemory(MemoryModuleType.NEAREST_VISIBLE_TARGETABLE_PLAYER, optional);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SensorVillagerBabies.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorVillagerBabies.java
new file mode 100644
index 0000000000000000000000000000000000000000..e5e246143f014d78dac765c97a5d9e3ac91a7793
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SensorVillagerBabies.java
@@ -0,0 +1,38 @@
+package net.minecraft.world.entity.ai.sensing;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+
+public class SensorVillagerBabies extends Sensor<EntityLiving> {
+
+    public SensorVillagerBabies() {}
+
+    @Override
+    public Set<MemoryModuleType<?>> a() {
+        return ImmutableSet.of(MemoryModuleType.VISIBLE_VILLAGER_BABIES);
+    }
+
+    @Override
+    protected void a(WorldServer worldserver, EntityLiving entityliving) {
+        entityliving.getBehaviorController().setMemory(MemoryModuleType.VISIBLE_VILLAGER_BABIES, (Object) this.a(entityliving));
+    }
+
+    private List<EntityLiving> a(EntityLiving entityliving) {
+        return (List) this.c(entityliving).stream().filter(this::b).collect(Collectors.toList());
+    }
+
+    private boolean b(EntityLiving entityliving) {
+        return entityliving.getEntityType() == EntityTypes.VILLAGER && entityliving.isBaby();
+    }
+
+    private List<EntityLiving> c(EntityLiving entityliving) {
+        return (List) entityliving.getBehaviorController().getMemory(MemoryModuleType.VISIBLE_MOBS).orElse(Lists.newArrayList());
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/targeting/PathfinderTargetCondition.java b/src/main/java/net/minecraft/world/entity/ai/targeting/PathfinderTargetCondition.java
new file mode 100644
index 0000000000000000000000000000000000000000..0de32bcf24a94efe5af922b877d4cdc3578e0cbd
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/targeting/PathfinderTargetCondition.java
@@ -0,0 +1,101 @@
+package net.minecraft.world.entity.ai.targeting;
+
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.EntityLiving;
+
+public class PathfinderTargetCondition {
+
+    public static final PathfinderTargetCondition a = new PathfinderTargetCondition();
+    private double b = -1.0D;
+    private boolean c;
+    private boolean d;
+    private boolean e;
+    private boolean f;
+    private boolean g = true;
+    private Predicate<EntityLiving> h;
+
+    public PathfinderTargetCondition() {}
+
+    public PathfinderTargetCondition a(double d0) {
+        this.b = d0;
+        return this;
+    }
+
+    public PathfinderTargetCondition a() {
+        this.c = true;
+        return this;
+    }
+
+    public PathfinderTargetCondition b() {
+        this.d = true;
+        return this;
+    }
+
+    public PathfinderTargetCondition c() {
+        this.e = true;
+        return this;
+    }
+
+    public PathfinderTargetCondition d() {
+        this.f = true;
+        return this;
+    }
+
+    public PathfinderTargetCondition e() {
+        this.g = false;
+        return this;
+    }
+
+    public PathfinderTargetCondition a(@Nullable Predicate<EntityLiving> predicate) {
+        this.h = predicate;
+        return this;
+    }
+
+    public boolean a(@Nullable EntityLiving entityliving, EntityLiving entityliving1) {
+        if (entityliving == entityliving1) {
+            return false;
+        } else if (entityliving1.isSpectator()) {
+            return false;
+        } else if (!entityliving1.isAlive()) {
+            return false;
+        } else if (!this.c && entityliving1.isInvulnerable()) {
+            return false;
+        } else if (this.h != null && !this.h.test(entityliving1)) {
+            return false;
+        } else {
+            if (entityliving != null) {
+                if (!this.f) {
+                    if (!entityliving.c(entityliving1)) {
+                        return false;
+                    }
+
+                    if (!entityliving.a(entityliving1.getEntityType())) {
+                        return false;
+                    }
+                }
+
+                if (!this.d && entityliving.r(entityliving1)) {
+                    return false;
+                }
+
+                if (this.b > 0.0D) {
+                    double d0 = this.g ? entityliving1.A(entityliving) : 1.0D;
+                    double d1 = Math.max(this.b * d0, 2.0D);
+                    double d2 = entityliving.h(entityliving1.locX(), entityliving1.locY(), entityliving1.locZ());
+
+                    if (d2 > d1 * d1) {
+                        return false;
+                    }
+                }
+
+                if (!this.e && entityliving instanceof EntityInsentient && !((EntityInsentient) entityliving).getEntitySenses().a(entityliving1)) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/util/RandomPositionGenerator.java b/src/main/java/net/minecraft/world/entity/ai/util/RandomPositionGenerator.java
new file mode 100644
index 0000000000000000000000000000000000000000..129ea3857969ddb99e15ae817ee3eec67b4c3ccf
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/util/RandomPositionGenerator.java
@@ -0,0 +1,212 @@
+package net.minecraft.world.entity.ai.util;
+
+import java.util.Random;
+import java.util.function.Predicate;
+import java.util.function.ToDoubleFunction;
+import javax.annotation.Nullable;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IPosition;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsFluid;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.EntityCreature;
+import net.minecraft.world.entity.ai.navigation.NavigationAbstract;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.pathfinder.PathType;
+import net.minecraft.world.level.pathfinder.PathfinderNormal;
+import net.minecraft.world.phys.Vec3D;
+
+public class RandomPositionGenerator {
+
+    @Nullable
+    public static Vec3D a(EntityCreature entitycreature, int i, int j) {
+        return a(entitycreature, i, j, 0, (Vec3D) null, true, 1.5707963705062866D, entitycreature::f, false, 0, 0, true);
+    }
+
+    @Nullable
+    public static Vec3D a(EntityCreature entitycreature, int i, int j, int k, @Nullable Vec3D vec3d, double d0) {
+        return a(entitycreature, i, j, k, vec3d, true, d0, entitycreature::f, true, 0, 0, false);
+    }
+
+    @Nullable
+    public static Vec3D b(EntityCreature entitycreature, int i, int j) {
+        entitycreature.getClass();
+        return a(entitycreature, i, j, entitycreature::f);
+    }
+
+    @Nullable
+    public static Vec3D a(EntityCreature entitycreature, int i, int j, ToDoubleFunction<BlockPosition> todoublefunction) {
+        return a(entitycreature, i, j, 0, (Vec3D) null, false, 0.0D, todoublefunction, true, 0, 0, true);
+    }
+
+    @Nullable
+    public static Vec3D a(EntityCreature entitycreature, int i, int j, Vec3D vec3d, float f, int k, int l) {
+        return a(entitycreature, i, j, 0, vec3d, false, (double) f, entitycreature::f, true, k, l, true);
+    }
+
+    @Nullable
+    public static Vec3D a(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        Vec3D vec3d1 = vec3d.a(entitycreature.locX(), entitycreature.locY(), entitycreature.locZ());
+
+        return a(entitycreature, i, j, 0, vec3d1, false, 1.5707963705062866D, entitycreature::f, true, 0, 0, true);
+    }
+
+    @Nullable
+    public static Vec3D b(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        Vec3D vec3d1 = vec3d.a(entitycreature.locX(), entitycreature.locY(), entitycreature.locZ());
+
+        return a(entitycreature, i, j, 0, vec3d1, true, 1.5707963705062866D, entitycreature::f, false, 0, 0, true);
+    }
+
+    @Nullable
+    public static Vec3D a(EntityCreature entitycreature, int i, int j, Vec3D vec3d, double d0) {
+        Vec3D vec3d1 = vec3d.a(entitycreature.locX(), entitycreature.locY(), entitycreature.locZ());
+
+        return a(entitycreature, i, j, 0, vec3d1, true, d0, entitycreature::f, false, 0, 0, true);
+    }
+
+    @Nullable
+    public static Vec3D b(EntityCreature entitycreature, int i, int j, int k, Vec3D vec3d, double d0) {
+        Vec3D vec3d1 = vec3d.a(entitycreature.locX(), entitycreature.locY(), entitycreature.locZ());
+
+        return a(entitycreature, i, j, k, vec3d1, false, d0, entitycreature::f, true, 0, 0, false);
+    }
+
+    @Nullable
+    public static Vec3D c(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        Vec3D vec3d1 = entitycreature.getPositionVector().d(vec3d);
+
+        return a(entitycreature, i, j, 0, vec3d1, true, 1.5707963705062866D, entitycreature::f, false, 0, 0, true);
+    }
+
+    @Nullable
+    public static Vec3D d(EntityCreature entitycreature, int i, int j, Vec3D vec3d) {
+        Vec3D vec3d1 = entitycreature.getPositionVector().d(vec3d);
+
+        return a(entitycreature, i, j, 0, vec3d1, false, 1.5707963705062866D, entitycreature::f, true, 0, 0, true);
+    }
+
+    @Nullable
+    private static Vec3D a(EntityCreature entitycreature, int i, int j, int k, @Nullable Vec3D vec3d, boolean flag, double d0, ToDoubleFunction<BlockPosition> todoublefunction, boolean flag1, int l, int i1, boolean flag2) {
+        NavigationAbstract navigationabstract = entitycreature.getNavigation();
+        Random random = entitycreature.getRandom();
+        boolean flag3;
+
+        if (entitycreature.ez()) {
+            flag3 = entitycreature.ew().a((IPosition) entitycreature.getPositionVector(), (double) (entitycreature.ex() + (float) i) + 1.0D);
+        } else {
+            flag3 = false;
+        }
+
+        boolean flag4 = false;
+        double d1 = Double.NEGATIVE_INFINITY;
+        BlockPosition blockposition = entitycreature.getChunkCoordinates();
+
+        for (int j1 = 0; j1 < 10; ++j1) {
+            BlockPosition blockposition1 = a(random, i, j, k, vec3d, d0);
+
+            if (blockposition1 != null) {
+                int k1 = blockposition1.getX();
+                int l1 = blockposition1.getY();
+                int i2 = blockposition1.getZ();
+                BlockPosition blockposition2;
+
+                if (entitycreature.ez() && i > 1) {
+                    blockposition2 = entitycreature.ew();
+                    if (entitycreature.locX() > (double) blockposition2.getX()) {
+                        k1 -= random.nextInt(i / 2);
+                    } else {
+                        k1 += random.nextInt(i / 2);
+                    }
+
+                    if (entitycreature.locZ() > (double) blockposition2.getZ()) {
+                        i2 -= random.nextInt(i / 2);
+                    } else {
+                        i2 += random.nextInt(i / 2);
+                    }
+                }
+
+                blockposition2 = new BlockPosition((double) k1 + entitycreature.locX(), (double) l1 + entitycreature.locY(), (double) i2 + entitycreature.locZ());
+                if (blockposition2.getY() >= 0 && blockposition2.getY() <= entitycreature.world.getBuildHeight() && (!flag3 || entitycreature.a(blockposition2)) && (!flag2 || navigationabstract.a(blockposition2))) {
+                    if (flag1) {
+                        blockposition2 = a(blockposition2, random.nextInt(l + 1) + i1, entitycreature.world.getBuildHeight(), (blockposition3) -> {
+                            return entitycreature.world.getType(blockposition3).getMaterial().isBuildable();
+                        });
+                    }
+
+                    if (flag || !entitycreature.world.getFluid(blockposition2).a((Tag) TagsFluid.WATER)) {
+                        PathType pathtype = PathfinderNormal.a((IBlockAccess) entitycreature.world, blockposition2.i());
+
+                        if (entitycreature.a(pathtype) == 0.0F) {
+                            double d2 = todoublefunction.applyAsDouble(blockposition2);
+
+                            if (d2 > d1) {
+                                d1 = d2;
+                                blockposition = blockposition2;
+                                flag4 = true;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        if (flag4) {
+            return Vec3D.c((BaseBlockPosition) blockposition);
+        } else {
+            return null;
+        }
+    }
+
+    @Nullable
+    private static BlockPosition a(Random random, int i, int j, int k, @Nullable Vec3D vec3d, double d0) {
+        if (vec3d != null && d0 < 3.141592653589793D) {
+            double d1 = MathHelper.d(vec3d.z, vec3d.x) - 1.5707963705062866D;
+            double d2 = d1 + (double) (2.0F * random.nextFloat() - 1.0F) * d0;
+            double d3 = Math.sqrt(random.nextDouble()) * (double) MathHelper.a * (double) i;
+            double d4 = -d3 * Math.sin(d2);
+            double d5 = d3 * Math.cos(d2);
+
+            if (Math.abs(d4) <= (double) i && Math.abs(d5) <= (double) i) {
+                int l = random.nextInt(2 * j + 1) - j + k;
+
+                return new BlockPosition(d4, (double) l, d5);
+            } else {
+                return null;
+            }
+        } else {
+            int i1 = random.nextInt(2 * i + 1) - i;
+            int j1 = random.nextInt(2 * j + 1) - j + k;
+            int k1 = random.nextInt(2 * i + 1) - i;
+
+            return new BlockPosition(i1, j1, k1);
+        }
+    }
+
+    static BlockPosition a(BlockPosition blockposition, int i, int j, Predicate<BlockPosition> predicate) {
+        if (i < 0) {
+            throw new IllegalArgumentException("aboveSolidAmount was " + i + ", expected >= 0");
+        } else if (!predicate.test(blockposition)) {
+            return blockposition;
+        } else {
+            BlockPosition blockposition1;
+
+            for (blockposition1 = blockposition.up(); blockposition1.getY() < j && predicate.test(blockposition1); blockposition1 = blockposition1.up()) {
+                ;
+            }
+
+            BlockPosition blockposition2;
+            BlockPosition blockposition3;
+
+            for (blockposition3 = blockposition1; blockposition3.getY() < j && blockposition3.getY() - blockposition1.getY() < i; blockposition3 = blockposition2) {
+                blockposition2 = blockposition3.up();
+                if (predicate.test(blockposition2)) {
+                    break;
+                }
+            }
+
+            return blockposition3;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlace.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlace.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe5dcce3873ca2724ac9d416d6f5d3c65d0fdafe
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlace.java
@@ -0,0 +1,274 @@
+package net.minecraft.world.entity.ai.village.poi;
+
+import com.mojang.datafixers.DataFixer;
+import com.mojang.datafixers.util.Pair;
+import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import java.io.File;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+import java.util.Random;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.BooleanSupplier;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.server.level.LightEngineGraphSection;
+import net.minecraft.util.datafix.DataFixTypes;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.IWorldReader;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.ChunkSection;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.storage.RegionFileSection;
+
+public class VillagePlace extends RegionFileSection<VillagePlaceSection> {
+
+    private final VillagePlace.a a = new VillagePlace.a();
+    private final LongSet b = new LongOpenHashSet();
+
+    public VillagePlace(File file, DataFixer datafixer, boolean flag) {
+        super(file, VillagePlaceSection::a, VillagePlaceSection::new, datafixer, DataFixTypes.POI_CHUNK, flag);
+    }
+
+    public void a(BlockPosition blockposition, VillagePlaceType villageplacetype) {
+        ((VillagePlaceSection) this.e(SectionPosition.a(blockposition).s())).a(blockposition, villageplacetype);
+    }
+
+    public void a(BlockPosition blockposition) {
+        ((VillagePlaceSection) this.e(SectionPosition.a(blockposition).s())).a(blockposition);
+    }
+
+    public long a(Predicate<VillagePlaceType> predicate, BlockPosition blockposition, int i, VillagePlace.Occupancy villageplace_occupancy) {
+        return this.c(predicate, blockposition, i, villageplace_occupancy).count();
+    }
+
+    public boolean a(VillagePlaceType villageplacetype, BlockPosition blockposition) {
+        Optional<VillagePlaceType> optional = ((VillagePlaceSection) this.e(SectionPosition.a(blockposition).s())).d(blockposition);
+
+        return optional.isPresent() && ((VillagePlaceType) optional.get()).equals(villageplacetype);
+    }
+
+    public Stream<VillagePlaceRecord> b(Predicate<VillagePlaceType> predicate, BlockPosition blockposition, int i, VillagePlace.Occupancy villageplace_occupancy) {
+        int j = Math.floorDiv(i, 16) + 1;
+
+        return ChunkCoordIntPair.a(new ChunkCoordIntPair(blockposition), j).flatMap((chunkcoordintpair) -> {
+            return this.a(predicate, chunkcoordintpair, villageplace_occupancy);
+        }).filter((villageplacerecord) -> {
+            BlockPosition blockposition1 = villageplacerecord.f();
+
+            return Math.abs(blockposition1.getX() - blockposition.getX()) <= i && Math.abs(blockposition1.getZ() - blockposition.getZ()) <= i;
+        });
+    }
+
+    public Stream<VillagePlaceRecord> c(Predicate<VillagePlaceType> predicate, BlockPosition blockposition, int i, VillagePlace.Occupancy villageplace_occupancy) {
+        int j = i * i;
+
+        return this.b(predicate, blockposition, i, villageplace_occupancy).filter((villageplacerecord) -> {
+            return villageplacerecord.f().j(blockposition) <= (double) j;
+        });
+    }
+
+    public Stream<VillagePlaceRecord> a(Predicate<VillagePlaceType> predicate, ChunkCoordIntPair chunkcoordintpair, VillagePlace.Occupancy villageplace_occupancy) {
+        return IntStream.range(0, 16).boxed().map((integer) -> {
+            return this.d(SectionPosition.a(chunkcoordintpair, integer).s());
+        }).filter(Optional::isPresent).flatMap((optional) -> {
+            return ((VillagePlaceSection) optional.get()).a(predicate, villageplace_occupancy);
+        });
+    }
+
+    public Stream<BlockPosition> a(Predicate<VillagePlaceType> predicate, Predicate<BlockPosition> predicate1, BlockPosition blockposition, int i, VillagePlace.Occupancy villageplace_occupancy) {
+        return this.c(predicate, blockposition, i, villageplace_occupancy).map(VillagePlaceRecord::f).filter(predicate1);
+    }
+
+    public Stream<BlockPosition> b(Predicate<VillagePlaceType> predicate, Predicate<BlockPosition> predicate1, BlockPosition blockposition, int i, VillagePlace.Occupancy villageplace_occupancy) {
+        return this.a(predicate, predicate1, blockposition, i, villageplace_occupancy).sorted(Comparator.comparingDouble((blockposition1) -> {
+            return blockposition1.j(blockposition);
+        }));
+    }
+
+    public Optional<BlockPosition> c(Predicate<VillagePlaceType> predicate, Predicate<BlockPosition> predicate1, BlockPosition blockposition, int i, VillagePlace.Occupancy villageplace_occupancy) {
+        return this.a(predicate, predicate1, blockposition, i, villageplace_occupancy).findFirst();
+    }
+
+    public Optional<BlockPosition> d(Predicate<VillagePlaceType> predicate, BlockPosition blockposition, int i, VillagePlace.Occupancy villageplace_occupancy) {
+        return this.c(predicate, blockposition, i, villageplace_occupancy).map(VillagePlaceRecord::f).min(Comparator.comparingDouble((blockposition1) -> {
+            return blockposition1.j(blockposition);
+        }));
+    }
+
+    public Optional<BlockPosition> a(Predicate<VillagePlaceType> predicate, Predicate<BlockPosition> predicate1, BlockPosition blockposition, int i) {
+        return this.c(predicate, blockposition, i, VillagePlace.Occupancy.HAS_SPACE).filter((villageplacerecord) -> {
+            return predicate1.test(villageplacerecord.f());
+        }).findFirst().map((villageplacerecord) -> {
+            villageplacerecord.b();
+            return villageplacerecord.f();
+        });
+    }
+
+    public Optional<BlockPosition> a(Predicate<VillagePlaceType> predicate, Predicate<BlockPosition> predicate1, VillagePlace.Occupancy villageplace_occupancy, BlockPosition blockposition, int i, Random random) {
+        List<VillagePlaceRecord> list = (List) this.c(predicate, blockposition, i, villageplace_occupancy).collect(Collectors.toList());
+
+        Collections.shuffle(list, random);
+        return list.stream().filter((villageplacerecord) -> {
+            return predicate1.test(villageplacerecord.f());
+        }).findFirst().map(VillagePlaceRecord::f);
+    }
+
+    public boolean b(BlockPosition blockposition) {
+        return ((VillagePlaceSection) this.e(SectionPosition.a(blockposition).s())).c(blockposition);
+    }
+
+    public boolean a(BlockPosition blockposition, Predicate<VillagePlaceType> predicate) {
+        return (Boolean) this.d(SectionPosition.a(blockposition).s()).map((villageplacesection) -> {
+            return villageplacesection.a(blockposition, predicate);
+        }).orElse(false);
+    }
+
+    public Optional<VillagePlaceType> c(BlockPosition blockposition) {
+        VillagePlaceSection villageplacesection = (VillagePlaceSection) this.e(SectionPosition.a(blockposition).s());
+
+        return villageplacesection.d(blockposition);
+    }
+
+    public int a(SectionPosition sectionposition) {
+        this.a.a();
+        return this.a.c(sectionposition.s());
+    }
+
+    private boolean f(long i) {
+        Optional<VillagePlaceSection> optional = this.c(i);
+
+        return optional == null ? false : (Boolean) optional.map((villageplacesection) -> {
+            return villageplacesection.a(VillagePlaceType.b, VillagePlace.Occupancy.IS_OCCUPIED).count() > 0L;
+        }).orElse(false);
+    }
+
+    @Override
+    public void a(BooleanSupplier booleansupplier) {
+        super.a(booleansupplier);
+        this.a.a();
+    }
+
+    @Override
+    protected void a(long i) {
+        super.a(i);
+        this.a.b(i, this.a.b(i), false);
+    }
+
+    @Override
+    protected void b(long i) {
+        this.a.b(i, this.a.b(i), false);
+    }
+
+    public void a(ChunkCoordIntPair chunkcoordintpair, ChunkSection chunksection) {
+        SectionPosition sectionposition = SectionPosition.a(chunkcoordintpair, chunksection.getYPosition() >> 4);
+
+        SystemUtils.a(this.d(sectionposition.s()), (villageplacesection) -> {
+            villageplacesection.a((biconsumer) -> {
+                if (a(chunksection)) {
+                    this.a(chunksection, sectionposition, biconsumer);
+                }
+
+            });
+        }, () -> {
+            if (a(chunksection)) {
+                VillagePlaceSection villageplacesection = (VillagePlaceSection) this.e(sectionposition.s());
+
+                this.a(chunksection, sectionposition, villageplacesection::a);
+            }
+
+        });
+    }
+
+    private static boolean a(ChunkSection chunksection) {
+        Set set = VillagePlaceType.x;
+
+        set.getClass();
+        return chunksection.a(set::contains);
+    }
+
+    private void a(ChunkSection chunksection, SectionPosition sectionposition, BiConsumer<BlockPosition, VillagePlaceType> biconsumer) {
+        sectionposition.t().forEach((blockposition) -> {
+            IBlockData iblockdata = chunksection.getType(SectionPosition.b(blockposition.getX()), SectionPosition.b(blockposition.getY()), SectionPosition.b(blockposition.getZ()));
+
+            VillagePlaceType.b(iblockdata).ifPresent((villageplacetype) -> {
+                biconsumer.accept(blockposition, villageplacetype);
+            });
+        });
+    }
+
+    public void a(IWorldReader iworldreader, BlockPosition blockposition, int i) {
+        SectionPosition.b(new ChunkCoordIntPair(blockposition), Math.floorDiv(i, 16)).map((sectionposition) -> {
+            return Pair.of(sectionposition, this.d(sectionposition.s()));
+        }).filter((pair) -> {
+            return !(Boolean) ((Optional) pair.getSecond()).map(VillagePlaceSection::a).orElse(false);
+        }).map((pair) -> {
+            return ((SectionPosition) pair.getFirst()).r();
+        }).filter((chunkcoordintpair) -> {
+            return this.b.add(chunkcoordintpair.pair());
+        }).forEach((chunkcoordintpair) -> {
+            iworldreader.getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z, ChunkStatus.EMPTY);
+        });
+    }
+
+    final class a extends LightEngineGraphSection {
+
+        private final Long2ByteMap b = new Long2ByteOpenHashMap();
+
+        protected a() {
+            super(7, 16, 256);
+            this.b.defaultReturnValue((byte) 7);
+        }
+
+        @Override
+        protected int b(long i) {
+            return VillagePlace.this.f(i) ? 0 : 7;
+        }
+
+        @Override
+        protected int c(long i) {
+            return this.b.get(i);
+        }
+
+        @Override
+        protected void a(long i, int j) {
+            if (j > 6) {
+                this.b.remove(i);
+            } else {
+                this.b.put(i, (byte) j);
+            }
+
+        }
+
+        public void a() {
+            super.b(Integer.MAX_VALUE);
+        }
+    }
+
+    public static enum Occupancy {
+
+        HAS_SPACE(VillagePlaceRecord::d), IS_OCCUPIED(VillagePlaceRecord::e), ANY((villageplacerecord) -> {
+            return true;
+        });
+
+        private final Predicate<? super VillagePlaceRecord> d;
+
+        private Occupancy(Predicate predicate) {
+            this.d = predicate;
+        }
+
+        public Predicate<? super VillagePlaceRecord> a() {
+            return this.d;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlaceRecord.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlaceRecord.java
new file mode 100644
index 0000000000000000000000000000000000000000..3fcbf223c4835b92a7da0df9e5443ca1e5217bb4
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlaceRecord.java
@@ -0,0 +1,82 @@
+package net.minecraft.world.entity.ai.village.poi;
+
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import java.util.Objects;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IRegistry;
+
+public class VillagePlaceRecord {
+
+    private final BlockPosition a;
+    private final VillagePlaceType b;
+    private int c;
+    private final Runnable d;
+
+    public static Codec<VillagePlaceRecord> a(Runnable runnable) {
+        return RecordCodecBuilder.create((instance) -> {
+            return instance.group(BlockPosition.a.fieldOf("pos").forGetter((villageplacerecord) -> {
+                return villageplacerecord.a;
+            }), IRegistry.POINT_OF_INTEREST_TYPE.fieldOf("type").forGetter((villageplacerecord) -> {
+                return villageplacerecord.b;
+            }), Codec.INT.fieldOf("free_tickets").orElse(0).forGetter((villageplacerecord) -> {
+                return villageplacerecord.c;
+            }), RecordCodecBuilder.point(runnable)).apply(instance, VillagePlaceRecord::new);
+        });
+    }
+
+    private VillagePlaceRecord(BlockPosition blockposition, VillagePlaceType villageplacetype, int i, Runnable runnable) {
+        this.a = blockposition.immutableCopy();
+        this.b = villageplacetype;
+        this.c = i;
+        this.d = runnable;
+    }
+
+    public VillagePlaceRecord(BlockPosition blockposition, VillagePlaceType villageplacetype, Runnable runnable) {
+        this(blockposition, villageplacetype, villageplacetype.b(), runnable);
+    }
+
+    protected boolean b() {
+        if (this.c <= 0) {
+            return false;
+        } else {
+            --this.c;
+            this.d.run();
+            return true;
+        }
+    }
+
+    protected boolean c() {
+        if (this.c >= this.b.b()) {
+            return false;
+        } else {
+            ++this.c;
+            this.d.run();
+            return true;
+        }
+    }
+
+    public boolean d() {
+        return this.c > 0;
+    }
+
+    public boolean e() {
+        return this.c != this.b.b();
+    }
+
+    public BlockPosition f() {
+        return this.a;
+    }
+
+    public VillagePlaceType g() {
+        return this.b;
+    }
+
+    public boolean equals(Object object) {
+        return this == object ? true : (object != null && this.getClass() == object.getClass() ? Objects.equals(this.a, ((VillagePlaceRecord) object).a) : false);
+    }
+
+    public int hashCode() {
+        return this.a.hashCode();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlaceSection.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlaceSection.java
new file mode 100644
index 0000000000000000000000000000000000000000..a72bd9ce8f683ae3f4d9c08c973292e3433e8f16
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlaceSection.java
@@ -0,0 +1,175 @@
+package net.minecraft.world.entity.ai.village.poi;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import it.unimi.dsi.fastutil.shorts.Short2ObjectMap;
+import it.unimi.dsi.fastutil.shorts.Short2ObjectOpenHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import net.minecraft.SharedConstants;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.SectionPosition;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.util.Supplier;
+
+public class VillagePlaceSection {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final Short2ObjectMap<VillagePlaceRecord> b;
+    private final Map<VillagePlaceType, Set<VillagePlaceRecord>> c;
+    private final Runnable d;
+    private boolean e;
+
+    public static Codec<VillagePlaceSection> a(Runnable runnable) {
+        Codec codec = RecordCodecBuilder.create((instance) -> {
+            return instance.group(RecordCodecBuilder.point(runnable), Codec.BOOL.optionalFieldOf("Valid", false).forGetter((villageplacesection) -> {
+                return villageplacesection.e;
+            }), VillagePlaceRecord.a(runnable).listOf().fieldOf("Records").forGetter((villageplacesection) -> {
+                return ImmutableList.copyOf(villageplacesection.b.values());
+            })).apply(instance, VillagePlaceSection::new);
+        });
+        Logger logger = VillagePlaceSection.LOGGER;
+
+        logger.getClass();
+        return codec.orElseGet(SystemUtils.a("Failed to read POI section: ", logger::error), () -> {
+            return new VillagePlaceSection(runnable, false, ImmutableList.of());
+        });
+    }
+
+    public VillagePlaceSection(Runnable runnable) {
+        this(runnable, true, ImmutableList.of());
+    }
+
+    private VillagePlaceSection(Runnable runnable, boolean flag, List<VillagePlaceRecord> list) {
+        this.b = new Short2ObjectOpenHashMap();
+        this.c = Maps.newHashMap();
+        this.d = runnable;
+        this.e = flag;
+        list.forEach(this::a);
+    }
+
+    public Stream<VillagePlaceRecord> a(Predicate<VillagePlaceType> predicate, VillagePlace.Occupancy villageplace_occupancy) {
+        return this.c.entrySet().stream().filter((entry) -> {
+            return predicate.test(entry.getKey());
+        }).flatMap((entry) -> {
+            return ((Set) entry.getValue()).stream();
+        }).filter(villageplace_occupancy.a());
+    }
+
+    public void a(BlockPosition blockposition, VillagePlaceType villageplacetype) {
+        if (this.a(new VillagePlaceRecord(blockposition, villageplacetype, this.d))) {
+            VillagePlaceSection.LOGGER.debug("Added POI of type {} @ {}", new Supplier[]{() -> {
+                        return villageplacetype;
+                    }, () -> {
+                        return blockposition;
+                    }});
+            this.d.run();
+        }
+
+    }
+
+    private boolean a(VillagePlaceRecord villageplacerecord) {
+        BlockPosition blockposition = villageplacerecord.f();
+        VillagePlaceType villageplacetype = villageplacerecord.g();
+        short short0 = SectionPosition.b(blockposition);
+        VillagePlaceRecord villageplacerecord1 = (VillagePlaceRecord) this.b.get(short0);
+
+        if (villageplacerecord1 != null) {
+            if (villageplacetype.equals(villageplacerecord1.g())) {
+                return false;
+            }
+
+            String s = "POI data mismatch: already registered at " + blockposition;
+
+            if (SharedConstants.d) {
+                throw (IllegalStateException) SystemUtils.c((Throwable) (new IllegalStateException(s)));
+            }
+
+            VillagePlaceSection.LOGGER.error(s);
+        }
+
+        this.b.put(short0, villageplacerecord);
+        ((Set) this.c.computeIfAbsent(villageplacetype, (villageplacetype1) -> {
+            return Sets.newHashSet();
+        })).add(villageplacerecord);
+        return true;
+    }
+
+    public void a(BlockPosition blockposition) {
+        VillagePlaceRecord villageplacerecord = (VillagePlaceRecord) this.b.remove(SectionPosition.b(blockposition));
+
+        if (villageplacerecord == null) {
+            VillagePlaceSection.LOGGER.error("POI data mismatch: never registered at " + blockposition);
+        } else {
+            ((Set) this.c.get(villageplacerecord.g())).remove(villageplacerecord);
+            VillagePlaceSection.LOGGER.debug("Removed POI of type {} @ {}", new Supplier[]{villageplacerecord::g, villageplacerecord::f});
+            this.d.run();
+        }
+    }
+
+    public boolean c(BlockPosition blockposition) {
+        VillagePlaceRecord villageplacerecord = (VillagePlaceRecord) this.b.get(SectionPosition.b(blockposition));
+
+        if (villageplacerecord == null) {
+            throw (IllegalStateException) SystemUtils.c((Throwable) (new IllegalStateException("POI never registered at " + blockposition)));
+        } else {
+            boolean flag = villageplacerecord.c();
+
+            this.d.run();
+            return flag;
+        }
+    }
+
+    public boolean a(BlockPosition blockposition, Predicate<VillagePlaceType> predicate) {
+        short short0 = SectionPosition.b(blockposition);
+        VillagePlaceRecord villageplacerecord = (VillagePlaceRecord) this.b.get(short0);
+
+        return villageplacerecord != null && predicate.test(villageplacerecord.g());
+    }
+
+    public Optional<VillagePlaceType> d(BlockPosition blockposition) {
+        short short0 = SectionPosition.b(blockposition);
+        VillagePlaceRecord villageplacerecord = (VillagePlaceRecord) this.b.get(short0);
+
+        return villageplacerecord != null ? Optional.of(villageplacerecord.g()) : Optional.empty();
+    }
+
+    public void a(Consumer<BiConsumer<BlockPosition, VillagePlaceType>> consumer) {
+        if (!this.e) {
+            Short2ObjectMap<VillagePlaceRecord> short2objectmap = new Short2ObjectOpenHashMap(this.b);
+
+            this.b();
+            consumer.accept((blockposition, villageplacetype) -> {
+                short short0 = SectionPosition.b(blockposition);
+                VillagePlaceRecord villageplacerecord = (VillagePlaceRecord) short2objectmap.computeIfAbsent(short0, (i) -> {
+                    return new VillagePlaceRecord(blockposition, villageplacetype, this.d);
+                });
+
+                this.a(villageplacerecord);
+            });
+            this.e = true;
+            this.d.run();
+        }
+
+    }
+
+    private void b() {
+        this.b.clear();
+        this.c.clear();
+    }
+
+    boolean a() {
+        return this.e;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/EntityHorseChestedAbstract.java b/src/main/java/net/minecraft/world/entity/animal/horse/EntityHorseChestedAbstract.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa12a0c9f30cd2b8a6de75ff9822843da808ae64
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/EntityHorseChestedAbstract.java
@@ -0,0 +1,198 @@
+package net.minecraft.world.entity.animal.horse;
+
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.network.syncher.DataWatcher;
+import net.minecraft.network.syncher.DataWatcherObject;
+import net.minecraft.network.syncher.DataWatcherRegistry;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.EnumInteractionResult;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.ai.attributes.AttributeProvider;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.IMaterial;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Blocks;
+
+public abstract class EntityHorseChestedAbstract extends EntityHorseAbstract {
+
+    private static final DataWatcherObject<Boolean> bw = DataWatcher.a(EntityHorseChestedAbstract.class, DataWatcherRegistry.i);
+
+    protected EntityHorseChestedAbstract(EntityTypes<? extends EntityHorseChestedAbstract> entitytypes, World world) {
+        super(entitytypes, world);
+        this.bu = false;
+    }
+
+    @Override
+    protected void eK() {
+        this.getAttributeInstance(GenericAttributes.MAX_HEALTH).setValue((double) this.fp());
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        super.initDatawatcher();
+        this.datawatcher.register(EntityHorseChestedAbstract.bw, false);
+    }
+
+    public static AttributeProvider.Builder eL() {
+        return fi().a(GenericAttributes.MOVEMENT_SPEED, 0.17499999701976776D).a(GenericAttributes.JUMP_STRENGTH, 0.5D);
+    }
+
+    public boolean isCarryingChest() {
+        return (Boolean) this.datawatcher.get(EntityHorseChestedAbstract.bw);
+    }
+
+    public void setCarryingChest(boolean flag) {
+        this.datawatcher.set(EntityHorseChestedAbstract.bw, flag);
+    }
+
+    @Override
+    protected int getChestSlots() {
+        return this.isCarryingChest() ? 17 : super.getChestSlots();
+    }
+
+    @Override
+    public double bc() {
+        return super.bc() - 0.25D;
+    }
+
+    @Override
+    protected void dropInventory() {
+        super.dropInventory();
+        if (this.isCarryingChest()) {
+            if (!this.world.isClientSide) {
+                this.a((IMaterial) Blocks.CHEST);
+            }
+
+            this.setCarryingChest(false);
+        }
+
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setBoolean("ChestedHorse", this.isCarryingChest());
+        if (this.isCarryingChest()) {
+            NBTTagList nbttaglist = new NBTTagList();
+
+            for (int i = 2; i < this.inventoryChest.getSize(); ++i) {
+                ItemStack itemstack = this.inventoryChest.getItem(i);
+
+                if (!itemstack.isEmpty()) {
+                    NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                    nbttagcompound1.setByte("Slot", (byte) i);
+                    itemstack.save(nbttagcompound1);
+                    nbttaglist.add(nbttagcompound1);
+                }
+            }
+
+            nbttagcompound.set("Items", nbttaglist);
+        }
+
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        this.setCarryingChest(nbttagcompound.getBoolean("ChestedHorse"));
+        if (this.isCarryingChest()) {
+            NBTTagList nbttaglist = nbttagcompound.getList("Items", 10);
+
+            this.loadChest();
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                NBTTagCompound nbttagcompound1 = nbttaglist.getCompound(i);
+                int j = nbttagcompound1.getByte("Slot") & 255;
+
+                if (j >= 2 && j < this.inventoryChest.getSize()) {
+                    this.inventoryChest.setItem(j, ItemStack.a(nbttagcompound1));
+                }
+            }
+        }
+
+        this.fe();
+    }
+
+    @Override
+    public boolean a_(int i, ItemStack itemstack) {
+        if (i == 499) {
+            if (this.isCarryingChest() && itemstack.isEmpty()) {
+                this.setCarryingChest(false);
+                this.loadChest();
+                return true;
+            }
+
+            if (!this.isCarryingChest() && itemstack.getItem() == Blocks.CHEST.getItem()) {
+                this.setCarryingChest(true);
+                this.loadChest();
+                return true;
+            }
+        }
+
+        return super.a_(i, itemstack);
+    }
+
+    @Override
+    public EnumInteractionResult b(EntityHuman entityhuman, EnumHand enumhand) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+
+        if (!this.isBaby()) {
+            if (this.isTamed() && entityhuman.eq()) {
+                this.f(entityhuman);
+                return EnumInteractionResult.a(this.world.isClientSide);
+            }
+
+            if (this.isVehicle()) {
+                return super.b(entityhuman, enumhand);
+            }
+        }
+
+        if (!itemstack.isEmpty()) {
+            if (this.k(itemstack)) {
+                return this.b(entityhuman, itemstack);
+            }
+
+            if (!this.isTamed()) {
+                this.fm();
+                return EnumInteractionResult.a(this.world.isClientSide);
+            }
+
+            if (!this.isCarryingChest() && itemstack.getItem() == Blocks.CHEST.getItem()) {
+                this.setCarryingChest(true);
+                this.eO();
+                if (!entityhuman.abilities.canInstantlyBuild) {
+                    itemstack.subtract(1);
+                }
+
+                this.loadChest();
+                return EnumInteractionResult.a(this.world.isClientSide);
+            }
+
+            if (!this.isBaby() && !this.hasSaddle() && itemstack.getItem() == Items.SADDLE) {
+                this.f(entityhuman);
+                return EnumInteractionResult.a(this.world.isClientSide);
+            }
+        }
+
+        if (this.isBaby()) {
+            return super.b(entityhuman, enumhand);
+        } else {
+            this.h(entityhuman);
+            return EnumInteractionResult.a(this.world.isClientSide);
+        }
+    }
+
+    protected void eO() {
+        this.playSound(SoundEffects.ENTITY_DONKEY_CHEST, 1.0F, (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F);
+    }
+
+    public int eU() {
+        return 5;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/EntityHorseSkeleton.java b/src/main/java/net/minecraft/world/entity/animal/horse/EntityHorseSkeleton.java
new file mode 100644
index 0000000000000000000000000000000000000000..0ddb676a2d1c38c97cd7750c1594fd6468156d0a
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/EntityHorseSkeleton.java
@@ -0,0 +1,201 @@
+package net.minecraft.world.entity.animal.horse;
+
+import javax.annotation.Nullable;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsFluid;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.EnumInteractionResult;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.EntityAgeable;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.EnumMonsterType;
+import net.minecraft.world.entity.ai.attributes.AttributeProvider;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.ai.goal.PathfinderGoal;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.World;
+
+public class EntityHorseSkeleton extends EntityHorseAbstract {
+
+    private final PathfinderGoalHorseTrap bw = new PathfinderGoalHorseTrap(this);
+    private boolean bx;
+    private int by;
+
+    public EntityHorseSkeleton(EntityTypes<? extends EntityHorseSkeleton> entitytypes, World world) {
+        super(entitytypes, world);
+    }
+
+    public static AttributeProvider.Builder eL() {
+        return fi().a(GenericAttributes.MAX_HEALTH, 15.0D).a(GenericAttributes.MOVEMENT_SPEED, 0.20000000298023224D);
+    }
+
+    @Override
+    protected void eK() {
+        this.getAttributeInstance(GenericAttributes.JUMP_STRENGTH).setValue(this.fq());
+    }
+
+    @Override
+    protected void eV() {}
+
+    @Override
+    protected SoundEffect getSoundAmbient() {
+        super.getSoundAmbient();
+        return this.a((Tag) TagsFluid.WATER) ? SoundEffects.ENTITY_SKELETON_HORSE_AMBIENT_WATER : SoundEffects.ENTITY_SKELETON_HORSE_AMBIENT;
+    }
+
+    @Override
+    protected SoundEffect getSoundDeath() {
+        super.getSoundDeath();
+        return SoundEffects.ENTITY_SKELETON_HORSE_DEATH;
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        super.getSoundHurt(damagesource);
+        return SoundEffects.ENTITY_SKELETON_HORSE_HURT;
+    }
+
+    @Override
+    protected SoundEffect getSoundSwim() {
+        if (this.onGround) {
+            if (!this.isVehicle()) {
+                return SoundEffects.ENTITY_SKELETON_HORSE_STEP_WATER;
+            }
+
+            ++this.bv;
+            if (this.bv > 5 && this.bv % 3 == 0) {
+                return SoundEffects.ENTITY_SKELETON_HORSE_GALLOP_WATER;
+            }
+
+            if (this.bv <= 5) {
+                return SoundEffects.ENTITY_SKELETON_HORSE_STEP_WATER;
+            }
+        }
+
+        return SoundEffects.ENTITY_SKELETON_HORSE_SWIM;
+    }
+
+    @Override
+    protected void d(float f) {
+        if (this.onGround) {
+            super.d(0.3F);
+        } else {
+            super.d(Math.min(0.1F, f * 25.0F));
+        }
+
+    }
+
+    @Override
+    protected void fn() {
+        if (this.isInWater()) {
+            this.playSound(SoundEffects.ENTITY_SKELETON_HORSE_JUMP_WATER, 0.4F, 1.0F);
+        } else {
+            super.fn();
+        }
+
+    }
+
+    @Override
+    public EnumMonsterType getMonsterType() {
+        return EnumMonsterType.UNDEAD;
+    }
+
+    @Override
+    public double bc() {
+        return super.bc() - 0.1875D;
+    }
+
+    @Override
+    public void movementTick() {
+        super.movementTick();
+        if (this.eM() && this.by++ >= 18000) {
+            this.die();
+        }
+
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setBoolean("SkeletonTrap", this.eM());
+        nbttagcompound.setInt("SkeletonTrapTime", this.by);
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        this.t(nbttagcompound.getBoolean("SkeletonTrap"));
+        this.by = nbttagcompound.getInt("SkeletonTrapTime");
+    }
+
+    @Override
+    public boolean bt() {
+        return true;
+    }
+
+    @Override
+    protected float dM() {
+        return 0.96F;
+    }
+
+    public boolean eM() {
+        return this.bx;
+    }
+
+    public void t(boolean flag) {
+        if (flag != this.bx) {
+            this.bx = flag;
+            if (flag) {
+                this.goalSelector.a(1, this.bw);
+            } else {
+                this.goalSelector.a((PathfinderGoal) this.bw);
+            }
+
+        }
+    }
+
+    @Nullable
+    @Override
+    public EntityAgeable createChild(WorldServer worldserver, EntityAgeable entityageable) {
+        return (EntityAgeable) EntityTypes.SKELETON_HORSE.a((World) worldserver);
+    }
+
+    @Override
+    public EnumInteractionResult b(EntityHuman entityhuman, EnumHand enumhand) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+
+        if (!this.isTamed()) {
+            return EnumInteractionResult.PASS;
+        } else if (this.isBaby()) {
+            return super.b(entityhuman, enumhand);
+        } else if (entityhuman.eq()) {
+            this.f(entityhuman);
+            return EnumInteractionResult.a(this.world.isClientSide);
+        } else if (this.isVehicle()) {
+            return super.b(entityhuman, enumhand);
+        } else {
+            if (!itemstack.isEmpty()) {
+                if (itemstack.getItem() == Items.SADDLE && !this.hasSaddle()) {
+                    this.f(entityhuman);
+                    return EnumInteractionResult.a(this.world.isClientSide);
+                }
+
+                EnumInteractionResult enuminteractionresult = itemstack.a(entityhuman, (EntityLiving) this, enumhand);
+
+                if (enuminteractionresult.a()) {
+                    return enuminteractionresult;
+                }
+            }
+
+            this.h(entityhuman);
+            return EnumInteractionResult.a(this.world.isClientSide);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/EntityLlama.java b/src/main/java/net/minecraft/world/entity/animal/horse/EntityLlama.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b09aaa30dd753fd34bea155890bdd9e5cb180f5
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/EntityLlama.java
@@ -0,0 +1,533 @@
+package net.minecraft.world.entity.animal.horse;
+
+import java.util.Iterator;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.particles.Particles;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.syncher.DataWatcher;
+import net.minecraft.network.syncher.DataWatcherObject;
+import net.minecraft.network.syncher.DataWatcherRegistry;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.tags.TagsItem;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.DifficultyDamageScaler;
+import net.minecraft.world.IInventory;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityAgeable;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.EnumMobSpawn;
+import net.minecraft.world.entity.GroupDataEntity;
+import net.minecraft.world.entity.ai.attributes.AttributeProvider;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalArrowAttack;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalBreed;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalFloat;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalFollowParent;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalLlamaFollow;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalLookAtPlayer;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalPanic;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalRandomLookaround;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalRandomStrollLand;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalTame;
+import net.minecraft.world.entity.ai.goal.target.PathfinderGoalHurtByTarget;
+import net.minecraft.world.entity.ai.goal.target.PathfinderGoalNearestAttackableTarget;
+import net.minecraft.world.entity.animal.EntityAnimal;
+import net.minecraft.world.entity.animal.EntityWolf;
+import net.minecraft.world.entity.monster.IRangedEntity;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.EntityLlamaSpit;
+import net.minecraft.world.item.EnumColor;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.crafting.RecipeItemStack;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.WorldAccess;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BlockCarpet;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+
+public class EntityLlama extends EntityHorseChestedAbstract implements IRangedEntity {
+
+    private static final RecipeItemStack bw = RecipeItemStack.a(Items.WHEAT, Blocks.HAY_BLOCK.getItem());
+    private static final DataWatcherObject<Integer> bx = DataWatcher.a(EntityLlama.class, DataWatcherRegistry.b);
+    private static final DataWatcherObject<Integer> by = DataWatcher.a(EntityLlama.class, DataWatcherRegistry.b);
+    private static final DataWatcherObject<Integer> bz = DataWatcher.a(EntityLlama.class, DataWatcherRegistry.b);
+    private boolean bA;
+    @Nullable
+    private EntityLlama bB;
+    @Nullable
+    private EntityLlama bC;
+
+    public EntityLlama(EntityTypes<? extends EntityLlama> entitytypes, World world) {
+        super(entitytypes, world);
+    }
+
+    public void setStrength(int i) {
+        this.datawatcher.set(EntityLlama.bx, Math.max(1, Math.min(5, i)));
+    }
+
+    private void fE() {
+        int i = this.random.nextFloat() < 0.04F ? 5 : 3;
+
+        this.setStrength(1 + this.random.nextInt(i));
+    }
+
+    public int getStrength() {
+        return (Integer) this.datawatcher.get(EntityLlama.bx);
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setInt("Variant", this.getVariant());
+        nbttagcompound.setInt("Strength", this.getStrength());
+        if (!this.inventoryChest.getItem(1).isEmpty()) {
+            nbttagcompound.set("DecorItem", this.inventoryChest.getItem(1).save(new NBTTagCompound()));
+        }
+
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        this.setStrength(nbttagcompound.getInt("Strength"));
+        super.loadData(nbttagcompound);
+        this.setVariant(nbttagcompound.getInt("Variant"));
+        if (nbttagcompound.hasKeyOfType("DecorItem", 10)) {
+            this.inventoryChest.setItem(1, ItemStack.a(nbttagcompound.getCompound("DecorItem")));
+        }
+
+        this.fe();
+    }
+
+    @Override
+    protected void initPathfinder() {
+        this.goalSelector.a(0, new PathfinderGoalFloat(this));
+        this.goalSelector.a(1, new PathfinderGoalTame(this, 1.2D));
+        this.goalSelector.a(2, new PathfinderGoalLlamaFollow(this, 2.0999999046325684D));
+        this.goalSelector.a(3, new PathfinderGoalArrowAttack(this, 1.25D, 40, 20.0F));
+        this.goalSelector.a(3, new PathfinderGoalPanic(this, 1.2D));
+        this.goalSelector.a(4, new PathfinderGoalBreed(this, 1.0D));
+        this.goalSelector.a(5, new PathfinderGoalFollowParent(this, 1.0D));
+        this.goalSelector.a(6, new PathfinderGoalRandomStrollLand(this, 0.7D));
+        this.goalSelector.a(7, new PathfinderGoalLookAtPlayer(this, EntityHuman.class, 6.0F));
+        this.goalSelector.a(8, new PathfinderGoalRandomLookaround(this));
+        this.targetSelector.a(1, new EntityLlama.c(this));
+        this.targetSelector.a(2, new EntityLlama.a(this));
+    }
+
+    public static AttributeProvider.Builder fw() {
+        return eL().a(GenericAttributes.FOLLOW_RANGE, 40.0D);
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        super.initDatawatcher();
+        this.datawatcher.register(EntityLlama.bx, 0);
+        this.datawatcher.register(EntityLlama.by, -1);
+        this.datawatcher.register(EntityLlama.bz, 0);
+    }
+
+    public int getVariant() {
+        return MathHelper.clamp((Integer) this.datawatcher.get(EntityLlama.bz), 0, 3);
+    }
+
+    public void setVariant(int i) {
+        this.datawatcher.set(EntityLlama.bz, i);
+    }
+
+    @Override
+    protected int getChestSlots() {
+        return this.isCarryingChest() ? 2 + 3 * this.eU() : super.getChestSlots();
+    }
+
+    @Override
+    public void k(Entity entity) {
+        if (this.w(entity)) {
+            float f = MathHelper.cos(this.aA * 0.017453292F);
+            float f1 = MathHelper.sin(this.aA * 0.017453292F);
+            float f2 = 0.3F;
+
+            entity.setPosition(this.locX() + (double) (0.3F * f1), this.locY() + this.bc() + entity.bb(), this.locZ() - (double) (0.3F * f));
+        }
+    }
+
+    @Override
+    public double bc() {
+        return (double) this.getHeight() * 0.67D;
+    }
+
+    @Override
+    public boolean er() {
+        return false;
+    }
+
+    @Override
+    public boolean k(ItemStack itemstack) {
+        return EntityLlama.bw.test(itemstack);
+    }
+
+    @Override
+    protected boolean c(EntityHuman entityhuman, ItemStack itemstack) {
+        byte b0 = 0;
+        byte b1 = 0;
+        float f = 0.0F;
+        boolean flag = false;
+        Item item = itemstack.getItem();
+
+        if (item == Items.WHEAT) {
+            b0 = 10;
+            b1 = 3;
+            f = 2.0F;
+        } else if (item == Blocks.HAY_BLOCK.getItem()) {
+            b0 = 90;
+            b1 = 6;
+            f = 10.0F;
+            if (this.isTamed() && this.getAge() == 0 && this.eP()) {
+                flag = true;
+                this.g(entityhuman);
+            }
+        }
+
+        if (this.getHealth() < this.getMaxHealth() && f > 0.0F) {
+            this.heal(f);
+            flag = true;
+        }
+
+        if (this.isBaby() && b0 > 0) {
+            this.world.addParticle(Particles.HAPPY_VILLAGER, this.d(1.0D), this.cF() + 0.5D, this.g(1.0D), 0.0D, 0.0D, 0.0D);
+            if (!this.world.isClientSide) {
+                this.setAge(b0);
+            }
+
+            flag = true;
+        }
+
+        if (b1 > 0 && (flag || !this.isTamed()) && this.getTemper() < this.getMaxDomestication()) {
+            flag = true;
+            if (!this.world.isClientSide) {
+                this.v(b1);
+            }
+        }
+
+        if (flag && !this.isSilent()) {
+            SoundEffect soundeffect = this.fg();
+
+            if (soundeffect != null) {
+                this.world.playSound((EntityHuman) null, this.locX(), this.locY(), this.locZ(), this.fg(), this.getSoundCategory(), 1.0F, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.2F);
+            }
+        }
+
+        return flag;
+    }
+
+    @Override
+    protected boolean isFrozen() {
+        return this.dl() || this.eZ();
+    }
+
+    @Nullable
+    @Override
+    public GroupDataEntity prepare(WorldAccess worldaccess, DifficultyDamageScaler difficultydamagescaler, EnumMobSpawn enummobspawn, @Nullable GroupDataEntity groupdataentity, @Nullable NBTTagCompound nbttagcompound) {
+        this.fE();
+        int i;
+
+        if (groupdataentity instanceof EntityLlama.b) {
+            i = ((EntityLlama.b) groupdataentity).a;
+        } else {
+            i = this.random.nextInt(4);
+            groupdataentity = new EntityLlama.b(i);
+        }
+
+        this.setVariant(i);
+        return super.prepare(worldaccess, difficultydamagescaler, enummobspawn, (GroupDataEntity) groupdataentity, nbttagcompound);
+    }
+
+    @Override
+    protected SoundEffect getSoundAngry() {
+        return SoundEffects.ENTITY_LLAMA_ANGRY;
+    }
+
+    @Override
+    protected SoundEffect getSoundAmbient() {
+        return SoundEffects.ENTITY_LLAMA_AMBIENT;
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return SoundEffects.ENTITY_LLAMA_HURT;
+    }
+
+    @Override
+    protected SoundEffect getSoundDeath() {
+        return SoundEffects.ENTITY_LLAMA_DEATH;
+    }
+
+    @Nullable
+    @Override
+    protected SoundEffect fg() {
+        return SoundEffects.ENTITY_LLAMA_EAT;
+    }
+
+    @Override
+    protected void b(BlockPosition blockposition, IBlockData iblockdata) {
+        this.playSound(SoundEffects.ENTITY_LLAMA_STEP, 0.15F, 1.0F);
+    }
+
+    @Override
+    protected void eO() {
+        this.playSound(SoundEffects.ENTITY_LLAMA_CHEST, 1.0F, (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F);
+    }
+
+    @Override
+    public void fm() {
+        SoundEffect soundeffect = this.getSoundAngry();
+
+        if (soundeffect != null) {
+            this.playSound(soundeffect, this.getSoundVolume(), this.dH());
+        }
+
+    }
+
+    @Override
+    public int eU() {
+        return this.getStrength();
+    }
+
+    @Override
+    public boolean fs() {
+        return true;
+    }
+
+    @Override
+    public boolean ft() {
+        return !this.inventoryChest.getItem(1).isEmpty();
+    }
+
+    @Override
+    public boolean l(ItemStack itemstack) {
+        Item item = itemstack.getItem();
+
+        return TagsItem.CARPETS.isTagged(item);
+    }
+
+    @Override
+    public boolean canSaddle() {
+        return false;
+    }
+
+    @Override
+    public void a(IInventory iinventory) {
+        EnumColor enumcolor = this.fy();
+
+        super.a(iinventory);
+        EnumColor enumcolor1 = this.fy();
+
+        if (this.ticksLived > 20 && enumcolor1 != null && enumcolor1 != enumcolor) {
+            this.playSound(SoundEffects.ENTITY_LLAMA_SWAG, 0.5F, 1.0F);
+        }
+
+    }
+
+    @Override
+    protected void fe() {
+        if (!this.world.isClientSide) {
+            super.fe();
+            this.a(m(this.inventoryChest.getItem(1)));
+        }
+    }
+
+    private void a(@Nullable EnumColor enumcolor) {
+        this.datawatcher.set(EntityLlama.by, enumcolor == null ? -1 : enumcolor.getColorIndex());
+    }
+
+    @Nullable
+    private static EnumColor m(ItemStack itemstack) {
+        Block block = Block.asBlock(itemstack.getItem());
+
+        return block instanceof BlockCarpet ? ((BlockCarpet) block).c() : null;
+    }
+
+    @Nullable
+    public EnumColor fy() {
+        int i = (Integer) this.datawatcher.get(EntityLlama.by);
+
+        return i == -1 ? null : EnumColor.fromColorIndex(i);
+    }
+
+    @Override
+    public int getMaxDomestication() {
+        return 30;
+    }
+
+    @Override
+    public boolean mate(EntityAnimal entityanimal) {
+        return entityanimal != this && entityanimal instanceof EntityLlama && this.fo() && ((EntityLlama) entityanimal).fo();
+    }
+
+    @Override
+    public EntityLlama createChild(WorldServer worldserver, EntityAgeable entityageable) {
+        EntityLlama entityllama = this.fz();
+
+        this.a(entityageable, (EntityHorseAbstract) entityllama);
+        EntityLlama entityllama1 = (EntityLlama) entityageable;
+        int i = this.random.nextInt(Math.max(this.getStrength(), entityllama1.getStrength())) + 1;
+
+        if (this.random.nextFloat() < 0.03F) {
+            ++i;
+        }
+
+        entityllama.setStrength(i);
+        entityllama.setVariant(this.random.nextBoolean() ? this.getVariant() : entityllama1.getVariant());
+        return entityllama;
+    }
+
+    protected EntityLlama fz() {
+        return (EntityLlama) EntityTypes.LLAMA.a(this.world);
+    }
+
+    private void i(EntityLiving entityliving) {
+        EntityLlamaSpit entityllamaspit = new EntityLlamaSpit(this.world, this);
+        double d0 = entityliving.locX() - this.locX();
+        double d1 = entityliving.e(0.3333333333333333D) - entityllamaspit.locY();
+        double d2 = entityliving.locZ() - this.locZ();
+        float f = MathHelper.sqrt(d0 * d0 + d2 * d2) * 0.2F;
+
+        entityllamaspit.shoot(d0, d1 + (double) f, d2, 1.5F, 10.0F);
+        if (!this.isSilent()) {
+            this.world.playSound((EntityHuman) null, this.locX(), this.locY(), this.locZ(), SoundEffects.ENTITY_LLAMA_SPIT, this.getSoundCategory(), 1.0F, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.2F);
+        }
+
+        this.world.addEntity(entityllamaspit);
+        this.bA = true;
+    }
+
+    private void A(boolean flag) {
+        this.bA = flag;
+    }
+
+    @Override
+    public boolean b(float f, float f1) {
+        int i = this.e(f, f1);
+
+        if (i <= 0) {
+            return false;
+        } else {
+            if (f >= 6.0F) {
+                this.damageEntity(DamageSource.FALL, (float) i);
+                if (this.isVehicle()) {
+                    Iterator iterator = this.getAllPassengers().iterator();
+
+                    while (iterator.hasNext()) {
+                        Entity entity = (Entity) iterator.next();
+
+                        entity.damageEntity(DamageSource.FALL, (float) i);
+                    }
+                }
+            }
+
+            this.playBlockStepSound();
+            return true;
+        }
+    }
+
+    public void fA() {
+        if (this.bB != null) {
+            this.bB.bC = null;
+        }
+
+        this.bB = null;
+    }
+
+    public void a(EntityLlama entityllama) {
+        this.bB = entityllama;
+        this.bB.bC = this;
+    }
+
+    public boolean fB() {
+        return this.bC != null;
+    }
+
+    public boolean fC() {
+        return this.bB != null;
+    }
+
+    @Nullable
+    public EntityLlama fD() {
+        return this.bB;
+    }
+
+    @Override
+    protected double eJ() {
+        return 2.0D;
+    }
+
+    @Override
+    protected void fk() {
+        if (!this.fC() && this.isBaby()) {
+            super.fk();
+        }
+
+    }
+
+    @Override
+    public boolean fl() {
+        return false;
+    }
+
+    @Override
+    public void a(EntityLiving entityliving, float f) {
+        this.i(entityliving);
+    }
+
+    static class a extends PathfinderGoalNearestAttackableTarget<EntityWolf> {
+
+        public a(EntityLlama entityllama) {
+            super(entityllama, EntityWolf.class, 16, false, true, (entityliving) -> {
+                return !((EntityWolf) entityliving).isTamed();
+            });
+        }
+
+        @Override
+        protected double k() {
+            return super.k() * 0.25D;
+        }
+    }
+
+    static class c extends PathfinderGoalHurtByTarget {
+
+        public c(EntityLlama entityllama) {
+            super(entityllama);
+        }
+
+        @Override
+        public boolean b() {
+            if (this.e instanceof EntityLlama) {
+                EntityLlama entityllama = (EntityLlama) this.e;
+
+                if (entityllama.bA) {
+                    entityllama.A(false);
+                    return false;
+                }
+            }
+
+            return super.b();
+        }
+    }
+
+    static class b extends EntityAgeable.a {
+
+        public final int a;
+
+        private b(int i) {
+            super(true);
+            this.a = i;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/phases/DragonControllerLandedFlame.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/phases/DragonControllerLandedFlame.java
new file mode 100644
index 0000000000000000000000000000000000000000..fbecb61b8c511fc7daa21690b2a653254be74246
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/phases/DragonControllerLandedFlame.java
@@ -0,0 +1,111 @@
+package net.minecraft.world.entity.boss.enderdragon.phases;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.particles.Particles;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.EntityAreaEffectCloud;
+import net.minecraft.world.entity.boss.enderdragon.EntityEnderDragon;
+import net.minecraft.world.phys.Vec3D;
+
+public class DragonControllerLandedFlame extends AbstractDragonControllerLanded {
+
+    private int b;
+    private int c;
+    private EntityAreaEffectCloud d;
+
+    public DragonControllerLandedFlame(EntityEnderDragon entityenderdragon) {
+        super(entityenderdragon);
+    }
+
+    @Override
+    public void b() {
+        ++this.b;
+        if (this.b % 2 == 0 && this.b < 10) {
+            Vec3D vec3d = this.a.x(1.0F).d();
+
+            vec3d.b(-0.7853982F);
+            double d0 = this.a.bo.locX();
+            double d1 = this.a.bo.e(0.5D);
+            double d2 = this.a.bo.locZ();
+
+            for (int i = 0; i < 8; ++i) {
+                double d3 = d0 + this.a.getRandom().nextGaussian() / 2.0D;
+                double d4 = d1 + this.a.getRandom().nextGaussian() / 2.0D;
+                double d5 = d2 + this.a.getRandom().nextGaussian() / 2.0D;
+
+                for (int j = 0; j < 6; ++j) {
+                    this.a.world.addParticle(Particles.DRAGON_BREATH, d3, d4, d5, -vec3d.x * 0.07999999821186066D * (double) j, -vec3d.y * 0.6000000238418579D, -vec3d.z * 0.07999999821186066D * (double) j);
+                }
+
+                vec3d.b(0.19634955F);
+            }
+        }
+
+    }
+
+    @Override
+    public void c() {
+        ++this.b;
+        if (this.b >= 200) {
+            if (this.c >= 4) {
+                this.a.getDragonControllerManager().setControllerPhase(DragonControllerPhase.TAKEOFF);
+            } else {
+                this.a.getDragonControllerManager().setControllerPhase(DragonControllerPhase.SITTING_SCANNING);
+            }
+        } else if (this.b == 10) {
+            Vec3D vec3d = (new Vec3D(this.a.bo.locX() - this.a.locX(), 0.0D, this.a.bo.locZ() - this.a.locZ())).d();
+            float f = 5.0F;
+            double d0 = this.a.bo.locX() + vec3d.x * 5.0D / 2.0D;
+            double d1 = this.a.bo.locZ() + vec3d.z * 5.0D / 2.0D;
+            double d2 = this.a.bo.e(0.5D);
+            double d3 = d2;
+            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(d0, d2, d1);
+
+            while (this.a.world.isEmpty(blockposition_mutableblockposition)) {
+                --d3;
+                if (d3 < 0.0D) {
+                    d3 = d2;
+                    break;
+                }
+
+                blockposition_mutableblockposition.c(d0, d3, d1);
+            }
+
+            d3 = (double) (MathHelper.floor(d3) + 1);
+            this.d = new EntityAreaEffectCloud(this.a.world, d0, d3, d1);
+            this.d.setSource(this.a);
+            this.d.setRadius(5.0F);
+            this.d.setDuration(200);
+            this.d.setParticle(Particles.DRAGON_BREATH);
+            this.d.addEffect(new MobEffect(MobEffects.HARM));
+            this.a.world.addEntity(this.d);
+        }
+
+    }
+
+    @Override
+    public void d() {
+        this.b = 0;
+        ++this.c;
+    }
+
+    @Override
+    public void e() {
+        if (this.d != null) {
+            this.d.die();
+            this.d = null;
+        }
+
+    }
+
+    @Override
+    public DragonControllerPhase<DragonControllerLandedFlame> getControllerPhase() {
+        return DragonControllerPhase.SITTING_FLAMING;
+    }
+
+    public void j() {
+        this.c = 0;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/phases/DragonControllerStrafe.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/phases/DragonControllerStrafe.java
new file mode 100644
index 0000000000000000000000000000000000000000..db3cef26c8d5cdf740bb151a5525d8740a0e8bbd
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/phases/DragonControllerStrafe.java
@@ -0,0 +1,198 @@
+package net.minecraft.world.entity.boss.enderdragon.phases;
+
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.boss.enderdragon.EntityEnderDragon;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.EntityDragonFireball;
+import net.minecraft.world.level.pathfinder.PathEntity;
+import net.minecraft.world.level.pathfinder.PathPoint;
+import net.minecraft.world.phys.Vec3D;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class DragonControllerStrafe extends AbstractDragonController {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private int c;
+    private PathEntity d;
+    private Vec3D e;
+    private EntityLiving f;
+    private boolean g;
+
+    public DragonControllerStrafe(EntityEnderDragon entityenderdragon) {
+        super(entityenderdragon);
+    }
+
+    @Override
+    public void c() {
+        if (this.f == null) {
+            DragonControllerStrafe.LOGGER.warn("Skipping player strafe phase because no player was found");
+            this.a.getDragonControllerManager().setControllerPhase(DragonControllerPhase.HOLDING_PATTERN);
+        } else {
+            double d0;
+            double d1;
+            double d2;
+
+            if (this.d != null && this.d.c()) {
+                d0 = this.f.locX();
+                d1 = this.f.locZ();
+                double d3 = d0 - this.a.locX();
+                double d4 = d1 - this.a.locZ();
+
+                d2 = (double) MathHelper.sqrt(d3 * d3 + d4 * d4);
+                double d5 = Math.min(0.4000000059604645D + d2 / 80.0D - 1.0D, 10.0D);
+
+                this.e = new Vec3D(d0, this.f.locY() + d5, d1);
+            }
+
+            d0 = this.e == null ? 0.0D : this.e.c(this.a.locX(), this.a.locY(), this.a.locZ());
+            if (d0 < 100.0D || d0 > 22500.0D) {
+                this.j();
+            }
+
+            d1 = 64.0D;
+            if (this.f.h((Entity) this.a) < 4096.0D) {
+                if (this.a.hasLineOfSight(this.f)) {
+                    ++this.c;
+                    Vec3D vec3d = (new Vec3D(this.f.locX() - this.a.locX(), 0.0D, this.f.locZ() - this.a.locZ())).d();
+                    Vec3D vec3d1 = (new Vec3D((double) MathHelper.sin(this.a.yaw * 0.017453292F), 0.0D, (double) (-MathHelper.cos(this.a.yaw * 0.017453292F)))).d();
+                    float f = (float) vec3d1.b(vec3d);
+                    float f1 = (float) (Math.acos((double) f) * 57.2957763671875D);
+
+                    f1 += 0.5F;
+                    if (this.c >= 5 && f1 >= 0.0F && f1 < 10.0F) {
+                        d2 = 1.0D;
+                        Vec3D vec3d2 = this.a.f(1.0F);
+                        double d6 = this.a.bo.locX() - vec3d2.x * 1.0D;
+                        double d7 = this.a.bo.e(0.5D) + 0.5D;
+                        double d8 = this.a.bo.locZ() - vec3d2.z * 1.0D;
+                        double d9 = this.f.locX() - d6;
+                        double d10 = this.f.e(0.5D) - d7;
+                        double d11 = this.f.locZ() - d8;
+
+                        if (!this.a.isSilent()) {
+                            this.a.world.a((EntityHuman) null, 1017, this.a.getChunkCoordinates(), 0);
+                        }
+
+                        EntityDragonFireball entitydragonfireball = new EntityDragonFireball(this.a.world, this.a, d9, d10, d11);
+
+                        entitydragonfireball.setPositionRotation(d6, d7, d8, 0.0F, 0.0F);
+                        this.a.world.addEntity(entitydragonfireball);
+                        this.c = 0;
+                        if (this.d != null) {
+                            while (!this.d.c()) {
+                                this.d.a();
+                            }
+                        }
+
+                        this.a.getDragonControllerManager().setControllerPhase(DragonControllerPhase.HOLDING_PATTERN);
+                    }
+                } else if (this.c > 0) {
+                    --this.c;
+                }
+            } else if (this.c > 0) {
+                --this.c;
+            }
+
+        }
+    }
+
+    private void j() {
+        if (this.d == null || this.d.c()) {
+            int i = this.a.eI();
+            int j = i;
+
+            if (this.a.getRandom().nextInt(8) == 0) {
+                this.g = !this.g;
+                j = i + 6;
+            }
+
+            if (this.g) {
+                ++j;
+            } else {
+                --j;
+            }
+
+            if (this.a.getEnderDragonBattle() != null && this.a.getEnderDragonBattle().c() > 0) {
+                j %= 12;
+                if (j < 0) {
+                    j += 12;
+                }
+            } else {
+                j -= 12;
+                j &= 7;
+                j += 12;
+            }
+
+            this.d = this.a.a(i, j, (PathPoint) null);
+            if (this.d != null) {
+                this.d.a();
+            }
+        }
+
+        this.k();
+    }
+
+    private void k() {
+        if (this.d != null && !this.d.c()) {
+            BlockPosition blockposition = this.d.g();
+
+            this.d.a();
+            double d0 = (double) blockposition.getX();
+            double d1 = (double) blockposition.getZ();
+
+            double d2;
+
+            do {
+                d2 = (double) ((float) blockposition.getY() + this.a.getRandom().nextFloat() * 20.0F);
+            } while (d2 < (double) blockposition.getY());
+
+            this.e = new Vec3D(d0, d2, d1);
+        }
+
+    }
+
+    @Override
+    public void d() {
+        this.c = 0;
+        this.e = null;
+        this.d = null;
+        this.f = null;
+    }
+
+    public void a(EntityLiving entityliving) {
+        this.f = entityliving;
+        int i = this.a.eI();
+        int j = this.a.p(this.f.locX(), this.f.locY(), this.f.locZ());
+        int k = MathHelper.floor(this.f.locX());
+        int l = MathHelper.floor(this.f.locZ());
+        double d0 = (double) k - this.a.locX();
+        double d1 = (double) l - this.a.locZ();
+        double d2 = (double) MathHelper.sqrt(d0 * d0 + d1 * d1);
+        double d3 = Math.min(0.4000000059604645D + d2 / 80.0D - 1.0D, 10.0D);
+        int i1 = MathHelper.floor(this.f.locY() + d3);
+        PathPoint pathpoint = new PathPoint(k, i1, l);
+
+        this.d = this.a.a(i, j, pathpoint);
+        if (this.d != null) {
+            this.d.a();
+            this.k();
+        }
+
+    }
+
+    @Nullable
+    @Override
+    public Vec3D g() {
+        return this.e;
+    }
+
+    @Override
+    public DragonControllerPhase<DragonControllerStrafe> getControllerPhase() {
+        return DragonControllerPhase.STRAFE_PLAYER;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/monster/EntityDrowned.java b/src/main/java/net/minecraft/world/entity/monster/EntityDrowned.java
new file mode 100644
index 0000000000000000000000000000000000000000..c3457fc7c0f72af79b12dc50c270ca24b7590c22
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/monster/EntityDrowned.java
@@ -0,0 +1,505 @@
+package net.minecraft.world.entity.monster;
+
+import java.util.EnumSet;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Random;
+import javax.annotation.Nullable;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsFluid;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.DifficultyDamageScaler;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityCreature;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.EnumItemSlot;
+import net.minecraft.world.entity.EnumMobSpawn;
+import net.minecraft.world.entity.EnumMoveType;
+import net.minecraft.world.entity.GroupDataEntity;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.ai.control.ControllerMove;
+import net.minecraft.world.entity.ai.goal.PathfinderGoal;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalArrowAttack;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalGotoTarget;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalRandomStroll;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalZombieAttack;
+import net.minecraft.world.entity.ai.goal.target.PathfinderGoalHurtByTarget;
+import net.minecraft.world.entity.ai.goal.target.PathfinderGoalNearestAttackableTarget;
+import net.minecraft.world.entity.ai.navigation.Navigation;
+import net.minecraft.world.entity.ai.navigation.NavigationGuardian;
+import net.minecraft.world.entity.ai.util.RandomPositionGenerator;
+import net.minecraft.world.entity.animal.EntityIronGolem;
+import net.minecraft.world.entity.animal.EntityTurtle;
+import net.minecraft.world.entity.npc.EntityVillagerAbstract;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.EntityThrownTrident;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.GeneratorAccess;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.IWorldReader;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.WorldAccess;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.pathfinder.PathEntity;
+import net.minecraft.world.level.pathfinder.PathType;
+import net.minecraft.world.phys.Vec3D;
+
+public class EntityDrowned extends EntityZombie implements IRangedEntity {
+
+    private boolean d;
+    public final NavigationGuardian navigationWater;
+    public final Navigation navigationLand;
+
+    public EntityDrowned(EntityTypes<? extends EntityDrowned> entitytypes, World world) {
+        super(entitytypes, world);
+        this.G = 1.0F;
+        this.moveController = new EntityDrowned.d(this);
+        this.a(PathType.WATER, 0.0F);
+        this.navigationWater = new NavigationGuardian(this, world);
+        this.navigationLand = new Navigation(this, world);
+    }
+
+    @Override
+    protected void m() {
+        this.goalSelector.a(1, new EntityDrowned.c(this, 1.0D));
+        this.goalSelector.a(2, new EntityDrowned.f(this, 1.0D, 40, 10.0F));
+        this.goalSelector.a(2, new EntityDrowned.a(this, 1.0D, false));
+        this.goalSelector.a(5, new EntityDrowned.b(this, 1.0D));
+        this.goalSelector.a(6, new EntityDrowned.e(this, 1.0D, this.world.getSeaLevel()));
+        this.goalSelector.a(7, new PathfinderGoalRandomStroll(this, 1.0D));
+        this.targetSelector.a(1, (new PathfinderGoalHurtByTarget(this, new Class[]{EntityDrowned.class})).a(EntityPigZombie.class));
+        this.targetSelector.a(2, new PathfinderGoalNearestAttackableTarget<>(this, EntityHuman.class, 10, true, false, this::i));
+        this.targetSelector.a(3, new PathfinderGoalNearestAttackableTarget<>(this, EntityVillagerAbstract.class, false));
+        this.targetSelector.a(3, new PathfinderGoalNearestAttackableTarget<>(this, EntityIronGolem.class, true));
+        this.targetSelector.a(5, new PathfinderGoalNearestAttackableTarget<>(this, EntityTurtle.class, 10, true, false, EntityTurtle.bo));
+    }
+
+    @Override
+    public GroupDataEntity prepare(WorldAccess worldaccess, DifficultyDamageScaler difficultydamagescaler, EnumMobSpawn enummobspawn, @Nullable GroupDataEntity groupdataentity, @Nullable NBTTagCompound nbttagcompound) {
+        groupdataentity = super.prepare(worldaccess, difficultydamagescaler, enummobspawn, groupdataentity, nbttagcompound);
+        if (this.getEquipment(EnumItemSlot.OFFHAND).isEmpty() && this.random.nextFloat() < 0.03F) {
+            this.setSlot(EnumItemSlot.OFFHAND, new ItemStack(Items.NAUTILUS_SHELL));
+            this.dropChanceHand[EnumItemSlot.OFFHAND.b()] = 2.0F;
+        }
+
+        return groupdataentity;
+    }
+
+    public static boolean a(EntityTypes<EntityDrowned> entitytypes, WorldAccess worldaccess, EnumMobSpawn enummobspawn, BlockPosition blockposition, Random random) {
+        Optional<ResourceKey<BiomeBase>> optional = worldaccess.i(blockposition);
+        boolean flag = worldaccess.getDifficulty() != EnumDifficulty.PEACEFUL && a(worldaccess, blockposition, random) && (enummobspawn == EnumMobSpawn.SPAWNER || worldaccess.getFluid(blockposition).a((Tag) TagsFluid.WATER));
+
+        return !Objects.equals(optional, Optional.of(Biomes.RIVER)) && !Objects.equals(optional, Optional.of(Biomes.FROZEN_RIVER)) ? random.nextInt(40) == 0 && a((GeneratorAccess) worldaccess, blockposition) && flag : random.nextInt(15) == 0 && flag;
+    }
+
+    private static boolean a(GeneratorAccess generatoraccess, BlockPosition blockposition) {
+        return blockposition.getY() < generatoraccess.getSeaLevel() - 5;
+    }
+
+    @Override
+    protected boolean eK() {
+        return false;
+    }
+
+    @Override
+    protected SoundEffect getSoundAmbient() {
+        return this.isInWater() ? SoundEffects.ENTITY_DROWNED_AMBIENT_WATER : SoundEffects.ENTITY_DROWNED_AMBIENT;
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return this.isInWater() ? SoundEffects.ENTITY_DROWNED_HURT_WATER : SoundEffects.ENTITY_DROWNED_HURT;
+    }
+
+    @Override
+    protected SoundEffect getSoundDeath() {
+        return this.isInWater() ? SoundEffects.ENTITY_DROWNED_DEATH_WATER : SoundEffects.ENTITY_DROWNED_DEATH;
+    }
+
+    @Override
+    protected SoundEffect getSoundStep() {
+        return SoundEffects.ENTITY_DROWNED_STEP;
+    }
+
+    @Override
+    protected SoundEffect getSoundSwim() {
+        return SoundEffects.ENTITY_DROWNED_SWIM;
+    }
+
+    @Override
+    protected ItemStack eM() {
+        return ItemStack.b;
+    }
+
+    @Override
+    protected void a(DifficultyDamageScaler difficultydamagescaler) {
+        if ((double) this.random.nextFloat() > 0.9D) {
+            int i = this.random.nextInt(16);
+
+            if (i < 10) {
+                this.setSlot(EnumItemSlot.MAINHAND, new ItemStack(Items.TRIDENT));
+            } else {
+                this.setSlot(EnumItemSlot.MAINHAND, new ItemStack(Items.FISHING_ROD));
+            }
+        }
+
+    }
+
+    @Override
+    protected boolean a(ItemStack itemstack, ItemStack itemstack1) {
+        return itemstack1.getItem() == Items.NAUTILUS_SHELL ? false : (itemstack1.getItem() == Items.TRIDENT ? (itemstack.getItem() == Items.TRIDENT ? itemstack.getDamage() < itemstack1.getDamage() : false) : (itemstack.getItem() == Items.TRIDENT ? true : super.a(itemstack, itemstack1)));
+    }
+
+    @Override
+    protected boolean eN() {
+        return false;
+    }
+
+    @Override
+    public boolean a(IWorldReader iworldreader) {
+        return iworldreader.j((Entity) this);
+    }
+
+    public boolean i(@Nullable EntityLiving entityliving) {
+        return entityliving != null ? !this.world.isDay() || entityliving.isInWater() : false;
+    }
+
+    @Override
+    public boolean bV() {
+        return !this.isSwimming();
+    }
+
+    private boolean eW() {
+        if (this.d) {
+            return true;
+        } else {
+            EntityLiving entityliving = this.getGoalTarget();
+
+            return entityliving != null && entityliving.isInWater();
+        }
+    }
+
+    @Override
+    public void g(Vec3D vec3d) {
+        if (this.doAITick() && this.isInWater() && this.eW()) {
+            this.a(0.01F, vec3d);
+            this.move(EnumMoveType.SELF, this.getMot());
+            this.setMot(this.getMot().a(0.9D));
+        } else {
+            super.g(vec3d);
+        }
+
+    }
+
+    @Override
+    public void aJ() {
+        if (!this.world.isClientSide) {
+            if (this.doAITick() && this.isInWater() && this.eW()) {
+                this.navigation = this.navigationWater;
+                this.setSwimming(true);
+            } else {
+                this.navigation = this.navigationLand;
+                this.setSwimming(false);
+            }
+        }
+
+    }
+
+    protected boolean eO() {
+        PathEntity pathentity = this.getNavigation().k();
+
+        if (pathentity != null) {
+            BlockPosition blockposition = pathentity.m();
+
+            if (blockposition != null) {
+                double d0 = this.h((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ());
+
+                if (d0 < 4.0D) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public void a(EntityLiving entityliving, float f) {
+        EntityThrownTrident entitythrowntrident = new EntityThrownTrident(this.world, this, new ItemStack(Items.TRIDENT));
+        double d0 = entityliving.locX() - this.locX();
+        double d1 = entityliving.e(0.3333333333333333D) - entitythrowntrident.locY();
+        double d2 = entityliving.locZ() - this.locZ();
+        double d3 = (double) MathHelper.sqrt(d0 * d0 + d2 * d2);
+
+        entitythrowntrident.shoot(d0, d1 + d3 * 0.20000000298023224D, d2, 1.6F, (float) (14 - this.world.getDifficulty().a() * 4));
+        this.playSound(SoundEffects.ENTITY_DROWNED_SHOOT, 1.0F, 1.0F / (this.getRandom().nextFloat() * 0.4F + 0.8F));
+        this.world.addEntity(entitythrowntrident);
+    }
+
+    public void t(boolean flag) {
+        this.d = flag;
+    }
+
+    static class d extends ControllerMove {
+
+        private final EntityDrowned i;
+
+        public d(EntityDrowned entitydrowned) {
+            super(entitydrowned);
+            this.i = entitydrowned;
+        }
+
+        @Override
+        public void a() {
+            EntityLiving entityliving = this.i.getGoalTarget();
+
+            if (this.i.eW() && this.i.isInWater()) {
+                if (entityliving != null && entityliving.locY() > this.i.locY() || this.i.d) {
+                    this.i.setMot(this.i.getMot().add(0.0D, 0.002D, 0.0D));
+                }
+
+                if (this.h != ControllerMove.Operation.MOVE_TO || this.i.getNavigation().m()) {
+                    this.i.q(0.0F);
+                    return;
+                }
+
+                double d0 = this.b - this.i.locX();
+                double d1 = this.c - this.i.locY();
+                double d2 = this.d - this.i.locZ();
+                double d3 = (double) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+
+                d1 /= d3;
+                float f = (float) (MathHelper.d(d2, d0) * 57.2957763671875D) - 90.0F;
+
+                this.i.yaw = this.a(this.i.yaw, f, 90.0F);
+                this.i.aA = this.i.yaw;
+                float f1 = (float) (this.e * this.i.b(GenericAttributes.MOVEMENT_SPEED));
+                float f2 = MathHelper.g(0.125F, this.i.dN(), f1);
+
+                this.i.q(f2);
+                this.i.setMot(this.i.getMot().add((double) f2 * d0 * 0.005D, (double) f2 * d1 * 0.1D, (double) f2 * d2 * 0.005D));
+            } else {
+                if (!this.i.onGround) {
+                    this.i.setMot(this.i.getMot().add(0.0D, -0.008D, 0.0D));
+                }
+
+                super.a();
+            }
+
+        }
+    }
+
+    static class a extends PathfinderGoalZombieAttack {
+
+        private final EntityDrowned b;
+
+        public a(EntityDrowned entitydrowned, double d0, boolean flag) {
+            super((EntityZombie) entitydrowned, d0, flag);
+            this.b = entitydrowned;
+        }
+
+        @Override
+        public boolean a() {
+            return super.a() && this.b.i(this.b.getGoalTarget());
+        }
+
+        @Override
+        public boolean b() {
+            return super.b() && this.b.i(this.b.getGoalTarget());
+        }
+    }
+
+    static class c extends PathfinderGoal {
+
+        private final EntityCreature a;
+        private double b;
+        private double c;
+        private double d;
+        private final double e;
+        private final World f;
+
+        public c(EntityCreature entitycreature, double d0) {
+            this.a = entitycreature;
+            this.e = d0;
+            this.f = entitycreature.world;
+            this.a(EnumSet.of(PathfinderGoal.Type.MOVE));
+        }
+
+        @Override
+        public boolean a() {
+            if (!this.f.isDay()) {
+                return false;
+            } else if (this.a.isInWater()) {
+                return false;
+            } else {
+                Vec3D vec3d = this.g();
+
+                if (vec3d == null) {
+                    return false;
+                } else {
+                    this.b = vec3d.x;
+                    this.c = vec3d.y;
+                    this.d = vec3d.z;
+                    return true;
+                }
+            }
+        }
+
+        @Override
+        public boolean b() {
+            return !this.a.getNavigation().m();
+        }
+
+        @Override
+        public void c() {
+            this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+        }
+
+        @Nullable
+        private Vec3D g() {
+            Random random = this.a.getRandom();
+            BlockPosition blockposition = this.a.getChunkCoordinates();
+
+            for (int i = 0; i < 10; ++i) {
+                BlockPosition blockposition1 = blockposition.b(random.nextInt(20) - 10, 2 - random.nextInt(8), random.nextInt(20) - 10);
+
+                if (this.f.getType(blockposition1).a(Blocks.WATER)) {
+                    return Vec3D.c((BaseBlockPosition) blockposition1);
+                }
+            }
+
+            return null;
+        }
+    }
+
+    static class b extends PathfinderGoalGotoTarget {
+
+        private final EntityDrowned g;
+
+        public b(EntityDrowned entitydrowned, double d0) {
+            super(entitydrowned, d0, 8, 2);
+            this.g = entitydrowned;
+        }
+
+        @Override
+        public boolean a() {
+            return super.a() && !this.g.world.isDay() && this.g.isInWater() && this.g.locY() >= (double) (this.g.world.getSeaLevel() - 3);
+        }
+
+        @Override
+        public boolean b() {
+            return super.b();
+        }
+
+        @Override
+        protected boolean a(IWorldReader iworldreader, BlockPosition blockposition) {
+            BlockPosition blockposition1 = blockposition.up();
+
+            return iworldreader.isEmpty(blockposition1) && iworldreader.isEmpty(blockposition1.up()) ? iworldreader.getType(blockposition).a((IBlockAccess) iworldreader, blockposition, (Entity) this.g) : false;
+        }
+
+        @Override
+        public void c() {
+            this.g.t(false);
+            this.g.navigation = this.g.navigationLand;
+            super.c();
+        }
+
+        @Override
+        public void d() {
+            super.d();
+        }
+    }
+
+    static class e extends PathfinderGoal {
+
+        private final EntityDrowned a;
+        private final double b;
+        private final int c;
+        private boolean d;
+
+        public e(EntityDrowned entitydrowned, double d0, int i) {
+            this.a = entitydrowned;
+            this.b = d0;
+            this.c = i;
+        }
+
+        @Override
+        public boolean a() {
+            return !this.a.world.isDay() && this.a.isInWater() && this.a.locY() < (double) (this.c - 2);
+        }
+
+        @Override
+        public boolean b() {
+            return this.a() && !this.d;
+        }
+
+        @Override
+        public void e() {
+            if (this.a.locY() < (double) (this.c - 1) && (this.a.getNavigation().m() || this.a.eO())) {
+                Vec3D vec3d = RandomPositionGenerator.b(this.a, 4, 8, new Vec3D(this.a.locX(), (double) (this.c - 1), this.a.locZ()));
+
+                if (vec3d == null) {
+                    this.d = true;
+                    return;
+                }
+
+                this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, this.b);
+            }
+
+        }
+
+        @Override
+        public void c() {
+            this.a.t(true);
+            this.d = false;
+        }
+
+        @Override
+        public void d() {
+            this.a.t(false);
+        }
+    }
+
+    static class f extends PathfinderGoalArrowAttack {
+
+        private final EntityDrowned a;
+
+        public f(IRangedEntity irangedentity, double d0, int i, float f) {
+            super(irangedentity, d0, i, f);
+            this.a = (EntityDrowned) irangedentity;
+        }
+
+        @Override
+        public boolean a() {
+            return super.a() && this.a.getItemInMainHand().getItem() == Items.TRIDENT;
+        }
+
+        @Override
+        public void c() {
+            super.c();
+            this.a.setAggressive(true);
+            this.a.c(EnumHand.MAIN_HAND);
+        }
+
+        @Override
+        public void d() {
+            super.d();
+            this.a.clearActiveItem();
+            this.a.setAggressive(false);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/monster/EntityEvoker.java b/src/main/java/net/minecraft/world/entity/monster/EntityEvoker.java
new file mode 100644
index 0000000000000000000000000000000000000000..64bfd84e8a5a0c2b1fec7044b688c7cc1083f18a
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/monster/EntityEvoker.java
@@ -0,0 +1,378 @@
+package net.minecraft.world.entity.monster;
+
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.EnumMobSpawn;
+import net.minecraft.world.entity.EnumMonsterType;
+import net.minecraft.world.entity.GroupDataEntity;
+import net.minecraft.world.entity.ai.attributes.AttributeProvider;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalAvoidTarget;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalFloat;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalLookAtPlayer;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalRandomStroll;
+import net.minecraft.world.entity.ai.goal.target.PathfinderGoalHurtByTarget;
+import net.minecraft.world.entity.ai.goal.target.PathfinderGoalNearestAttackableTarget;
+import net.minecraft.world.entity.ai.targeting.PathfinderTargetCondition;
+import net.minecraft.world.entity.animal.EntityIronGolem;
+import net.minecraft.world.entity.animal.EntitySheep;
+import net.minecraft.world.entity.npc.EntityVillagerAbstract;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.EntityEvokerFangs;
+import net.minecraft.world.entity.raid.EntityRaider;
+import net.minecraft.world.item.EnumColor;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.phys.shapes.VoxelShape;
+
+public class EntityEvoker extends EntityIllagerWizard {
+
+    private EntitySheep bo;
+
+    public EntityEvoker(EntityTypes<? extends EntityEvoker> entitytypes, World world) {
+        super(entitytypes, world);
+        this.f = 10;
+    }
+
+    @Override
+    protected void initPathfinder() {
+        super.initPathfinder();
+        this.goalSelector.a(0, new PathfinderGoalFloat(this));
+        this.goalSelector.a(1, new EntityEvoker.b());
+        this.goalSelector.a(2, new PathfinderGoalAvoidTarget<>(this, EntityHuman.class, 8.0F, 0.6D, 1.0D));
+        this.goalSelector.a(4, new EntityEvoker.c());
+        this.goalSelector.a(5, new EntityEvoker.a());
+        this.goalSelector.a(6, new EntityEvoker.d());
+        this.goalSelector.a(8, new PathfinderGoalRandomStroll(this, 0.6D));
+        this.goalSelector.a(9, new PathfinderGoalLookAtPlayer(this, EntityHuman.class, 3.0F, 1.0F));
+        this.goalSelector.a(10, new PathfinderGoalLookAtPlayer(this, EntityInsentient.class, 8.0F));
+        this.targetSelector.a(1, (new PathfinderGoalHurtByTarget(this, new Class[]{EntityRaider.class})).a());
+        this.targetSelector.a(2, (new PathfinderGoalNearestAttackableTarget<>(this, EntityHuman.class, true)).a(300));
+        this.targetSelector.a(3, (new PathfinderGoalNearestAttackableTarget<>(this, EntityVillagerAbstract.class, false)).a(300));
+        this.targetSelector.a(3, new PathfinderGoalNearestAttackableTarget<>(this, EntityIronGolem.class, false));
+    }
+
+    public static AttributeProvider.Builder eK() {
+        return EntityMonster.eR().a(GenericAttributes.MOVEMENT_SPEED, 0.5D).a(GenericAttributes.FOLLOW_RANGE, 12.0D).a(GenericAttributes.MAX_HEALTH, 24.0D);
+    }
+
+    @Override
+    protected void initDatawatcher() {
+        super.initDatawatcher();
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+    }
+
+    @Override
+    public SoundEffect eL() {
+        return SoundEffects.ENTITY_EVOKER_CELEBRATE;
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+    }
+
+    @Override
+    protected void mobTick() {
+        super.mobTick();
+    }
+
+    @Override
+    public boolean r(Entity entity) {
+        return entity == null ? false : (entity == this ? true : (super.r(entity) ? true : (entity instanceof EntityVex ? this.r(((EntityVex) entity).eK()) : (entity instanceof EntityLiving && ((EntityLiving) entity).getMonsterType() == EnumMonsterType.ILLAGER ? this.getScoreboardTeam() == null && entity.getScoreboardTeam() == null : false))));
+    }
+
+    @Override
+    protected SoundEffect getSoundAmbient() {
+        return SoundEffects.ENTITY_EVOKER_AMBIENT;
+    }
+
+    @Override
+    protected SoundEffect getSoundDeath() {
+        return SoundEffects.ENTITY_EVOKER_DEATH;
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return SoundEffects.ENTITY_EVOKER_HURT;
+    }
+
+    private void a(@Nullable EntitySheep entitysheep) {
+        this.bo = entitysheep;
+    }
+
+    @Nullable
+    private EntitySheep fg() {
+        return this.bo;
+    }
+
+    @Override
+    protected SoundEffect getSoundCastSpell() {
+        return SoundEffects.ENTITY_EVOKER_CAST_SPELL;
+    }
+
+    @Override
+    public void a(int i, boolean flag) {}
+
+    public class d extends EntityIllagerWizard.PathfinderGoalCastSpell {
+
+        private final PathfinderTargetCondition e = (new PathfinderTargetCondition()).a(16.0D).a().a((entityliving) -> {
+            return ((EntitySheep) entityliving).getColor() == EnumColor.BLUE;
+        });
+
+        public d() {
+            super();
+        }
+
+        @Override
+        public boolean a() {
+            if (EntityEvoker.this.getGoalTarget() != null) {
+                return false;
+            } else if (EntityEvoker.this.eW()) {
+                return false;
+            } else if (EntityEvoker.this.ticksLived < this.c) {
+                return false;
+            } else if (!EntityEvoker.this.world.getGameRules().getBoolean(GameRules.MOB_GRIEFING)) {
+                return false;
+            } else {
+                List<EntitySheep> list = EntityEvoker.this.world.a(EntitySheep.class, this.e, EntityEvoker.this, EntityEvoker.this.getBoundingBox().grow(16.0D, 4.0D, 16.0D));
+
+                if (list.isEmpty()) {
+                    return false;
+                } else {
+                    EntityEvoker.this.a((EntitySheep) list.get(EntityEvoker.this.random.nextInt(list.size())));
+                    return true;
+                }
+            }
+        }
+
+        @Override
+        public boolean b() {
+            return EntityEvoker.this.fg() != null && this.b > 0;
+        }
+
+        @Override
+        public void d() {
+            super.d();
+            EntityEvoker.this.a((EntitySheep) null);
+        }
+
+        @Override
+        protected void j() {
+            EntitySheep entitysheep = EntityEvoker.this.fg();
+
+            if (entitysheep != null && entitysheep.isAlive()) {
+                entitysheep.setColor(EnumColor.RED);
+            }
+
+        }
+
+        @Override
+        protected int m() {
+            return 40;
+        }
+
+        @Override
+        protected int g() {
+            return 60;
+        }
+
+        @Override
+        protected int h() {
+            return 140;
+        }
+
+        @Override
+        protected SoundEffect k() {
+            return SoundEffects.ENTITY_EVOKER_PREPARE_WOLOLO;
+        }
+
+        @Override
+        protected EntityIllagerWizard.Spell getCastSpell() {
+            return EntityIllagerWizard.Spell.WOLOLO;
+        }
+    }
+
+    class c extends EntityIllagerWizard.PathfinderGoalCastSpell {
+
+        private final PathfinderTargetCondition e;
+
+        private c() {
+            super();
+            this.e = (new PathfinderTargetCondition()).a(16.0D).c().e().a().b();
+        }
+
+        @Override
+        public boolean a() {
+            if (!super.a()) {
+                return false;
+            } else {
+                int i = EntityEvoker.this.world.a(EntityVex.class, this.e, EntityEvoker.this, EntityEvoker.this.getBoundingBox().g(16.0D)).size();
+
+                return EntityEvoker.this.random.nextInt(8) + 1 > i;
+            }
+        }
+
+        @Override
+        protected int g() {
+            return 100;
+        }
+
+        @Override
+        protected int h() {
+            return 340;
+        }
+
+        @Override
+        protected void j() {
+            WorldServer worldserver = (WorldServer) EntityEvoker.this.world;
+
+            for (int i = 0; i < 3; ++i) {
+                BlockPosition blockposition = EntityEvoker.this.getChunkCoordinates().b(-2 + EntityEvoker.this.random.nextInt(5), 1, -2 + EntityEvoker.this.random.nextInt(5));
+                EntityVex entityvex = (EntityVex) EntityTypes.VEX.a(EntityEvoker.this.world);
+
+                entityvex.setPositionRotation(blockposition, 0.0F, 0.0F);
+                entityvex.prepare(worldserver, EntityEvoker.this.world.getDamageScaler(blockposition), EnumMobSpawn.MOB_SUMMONED, (GroupDataEntity) null, (NBTTagCompound) null);
+                entityvex.a((EntityInsentient) EntityEvoker.this);
+                entityvex.g(blockposition);
+                entityvex.a(20 * (30 + EntityEvoker.this.random.nextInt(90)));
+                worldserver.addAllEntities(entityvex);
+            }
+
+        }
+
+        @Override
+        protected SoundEffect k() {
+            return SoundEffects.ENTITY_EVOKER_PREPARE_SUMMON;
+        }
+
+        @Override
+        protected EntityIllagerWizard.Spell getCastSpell() {
+            return EntityIllagerWizard.Spell.SUMMON_VEX;
+        }
+    }
+
+    class a extends EntityIllagerWizard.PathfinderGoalCastSpell {
+
+        private a() {
+            super();
+        }
+
+        @Override
+        protected int g() {
+            return 40;
+        }
+
+        @Override
+        protected int h() {
+            return 100;
+        }
+
+        @Override
+        protected void j() {
+            EntityLiving entityliving = EntityEvoker.this.getGoalTarget();
+            double d0 = Math.min(entityliving.locY(), EntityEvoker.this.locY());
+            double d1 = Math.max(entityliving.locY(), EntityEvoker.this.locY()) + 1.0D;
+            float f = (float) MathHelper.d(entityliving.locZ() - EntityEvoker.this.locZ(), entityliving.locX() - EntityEvoker.this.locX());
+            int i;
+
+            if (EntityEvoker.this.h((Entity) entityliving) < 9.0D) {
+                float f1;
+
+                for (i = 0; i < 5; ++i) {
+                    f1 = f + (float) i * 3.1415927F * 0.4F;
+                    this.a(EntityEvoker.this.locX() + (double) MathHelper.cos(f1) * 1.5D, EntityEvoker.this.locZ() + (double) MathHelper.sin(f1) * 1.5D, d0, d1, f1, 0);
+                }
+
+                for (i = 0; i < 8; ++i) {
+                    f1 = f + (float) i * 3.1415927F * 2.0F / 8.0F + 1.2566371F;
+                    this.a(EntityEvoker.this.locX() + (double) MathHelper.cos(f1) * 2.5D, EntityEvoker.this.locZ() + (double) MathHelper.sin(f1) * 2.5D, d0, d1, f1, 3);
+                }
+            } else {
+                for (i = 0; i < 16; ++i) {
+                    double d2 = 1.25D * (double) (i + 1);
+                    int j = 1 * i;
+
+                    this.a(EntityEvoker.this.locX() + (double) MathHelper.cos(f) * d2, EntityEvoker.this.locZ() + (double) MathHelper.sin(f) * d2, d0, d1, f, j);
+                }
+            }
+
+        }
+
+        private void a(double d0, double d1, double d2, double d3, float f, int i) {
+            BlockPosition blockposition = new BlockPosition(d0, d3, d1);
+            boolean flag = false;
+            double d4 = 0.0D;
+
+            do {
+                BlockPosition blockposition1 = blockposition.down();
+                IBlockData iblockdata = EntityEvoker.this.world.getType(blockposition1);
+
+                if (iblockdata.d(EntityEvoker.this.world, blockposition1, EnumDirection.UP)) {
+                    if (!EntityEvoker.this.world.isEmpty(blockposition)) {
+                        IBlockData iblockdata1 = EntityEvoker.this.world.getType(blockposition);
+                        VoxelShape voxelshape = iblockdata1.getCollisionShape(EntityEvoker.this.world, blockposition);
+
+                        if (!voxelshape.isEmpty()) {
+                            d4 = voxelshape.c(EnumDirection.EnumAxis.Y);
+                        }
+                    }
+
+                    flag = true;
+                    break;
+                }
+
+                blockposition = blockposition.down();
+            } while (blockposition.getY() >= MathHelper.floor(d2) - 1);
+
+            if (flag) {
+                EntityEvoker.this.world.addEntity(new EntityEvokerFangs(EntityEvoker.this.world, d0, (double) blockposition.getY() + d4, d1, f, i, EntityEvoker.this));
+            }
+
+        }
+
+        @Override
+        protected SoundEffect k() {
+            return SoundEffects.ENTITY_EVOKER_PREPARE_ATTACK;
+        }
+
+        @Override
+        protected EntityIllagerWizard.Spell getCastSpell() {
+            return EntityIllagerWizard.Spell.FANGS;
+        }
+    }
+
+    class b extends EntityIllagerWizard.b {
+
+        private b() {
+            super();
+        }
+
+        @Override
+        public void e() {
+            if (EntityEvoker.this.getGoalTarget() != null) {
+                EntityEvoker.this.getControllerLook().a(EntityEvoker.this.getGoalTarget(), (float) EntityEvoker.this.Q(), (float) EntityEvoker.this.O());
+            } else if (EntityEvoker.this.fg() != null) {
+                EntityEvoker.this.getControllerLook().a(EntityEvoker.this.fg(), (float) EntityEvoker.this.Q(), (float) EntityEvoker.this.O());
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/monster/EntityMonster.java b/src/main/java/net/minecraft/world/entity/monster/EntityMonster.java
new file mode 100644
index 0000000000000000000000000000000000000000..acebee991eca1e19fc1094718dc40822b66756e1
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/monster/EntityMonster.java
@@ -0,0 +1,143 @@
+package net.minecraft.world.entity.monster;
+
+import java.util.Random;
+import java.util.function.Predicate;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.EntityCreature;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.EnumMobSpawn;
+import net.minecraft.world.entity.ai.attributes.AttributeProvider;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.item.ItemProjectileWeapon;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.GeneratorAccess;
+import net.minecraft.world.level.IWorldReader;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.WorldAccess;
+
+public abstract class EntityMonster extends EntityCreature implements IMonster {
+
+    protected EntityMonster(EntityTypes<? extends EntityMonster> entitytypes, World world) {
+        super(entitytypes, world);
+        this.f = 5;
+    }
+
+    @Override
+    public SoundCategory getSoundCategory() {
+        return SoundCategory.HOSTILE;
+    }
+
+    @Override
+    public void movementTick() {
+        this.dA();
+        this.eQ();
+        super.movementTick();
+    }
+
+    protected void eQ() {
+        float f = this.aR();
+
+        if (f > 0.5F) {
+            this.ticksFarFromPlayer += 2;
+        }
+
+    }
+
+    @Override
+    protected boolean L() {
+        return true;
+    }
+
+    @Override
+    protected SoundEffect getSoundSwim() {
+        return SoundEffects.ENTITY_HOSTILE_SWIM;
+    }
+
+    @Override
+    protected SoundEffect getSoundSplash() {
+        return SoundEffects.ENTITY_HOSTILE_SPLASH;
+    }
+
+    @Override
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        return this.isInvulnerable(damagesource) ? false : super.damageEntity(damagesource, f);
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return SoundEffects.ENTITY_HOSTILE_HURT;
+    }
+
+    @Override
+    protected SoundEffect getSoundDeath() {
+        return SoundEffects.ENTITY_HOSTILE_DEATH;
+    }
+
+    @Override
+    protected SoundEffect getSoundFall(int i) {
+        return i > 4 ? SoundEffects.ENTITY_HOSTILE_BIG_FALL : SoundEffects.ENTITY_HOSTILE_SMALL_FALL;
+    }
+
+    @Override
+    public float a(BlockPosition blockposition, IWorldReader iworldreader) {
+        return 0.5F - iworldreader.y(blockposition);
+    }
+
+    public static boolean a(WorldAccess worldaccess, BlockPosition blockposition, Random random) {
+        if (worldaccess.getBrightness(EnumSkyBlock.SKY, blockposition) > random.nextInt(32)) {
+            return false;
+        } else {
+            int i = worldaccess.getMinecraftWorld().W() ? worldaccess.c(blockposition, 10) : worldaccess.getLightLevel(blockposition);
+
+            return i <= random.nextInt(8);
+        }
+    }
+
+    public static boolean b(EntityTypes<? extends EntityMonster> entitytypes, WorldAccess worldaccess, EnumMobSpawn enummobspawn, BlockPosition blockposition, Random random) {
+        return worldaccess.getDifficulty() != EnumDifficulty.PEACEFUL && a(worldaccess, blockposition, random) && a(entitytypes, (GeneratorAccess) worldaccess, enummobspawn, blockposition, random);
+    }
+
+    public static boolean c(EntityTypes<? extends EntityMonster> entitytypes, GeneratorAccess generatoraccess, EnumMobSpawn enummobspawn, BlockPosition blockposition, Random random) {
+        return generatoraccess.getDifficulty() != EnumDifficulty.PEACEFUL && a(entitytypes, generatoraccess, enummobspawn, blockposition, random);
+    }
+
+    public static AttributeProvider.Builder eR() {
+        return EntityInsentient.p().a(GenericAttributes.ATTACK_DAMAGE);
+    }
+
+    @Override
+    protected boolean isDropExperience() {
+        return true;
+    }
+
+    @Override
+    protected boolean cW() {
+        return true;
+    }
+
+    public boolean f(EntityHuman entityhuman) {
+        return true;
+    }
+
+    @Override
+    public ItemStack f(ItemStack itemstack) {
+        if (itemstack.getItem() instanceof ItemProjectileWeapon) {
+            Predicate<ItemStack> predicate = ((ItemProjectileWeapon) itemstack.getItem()).e();
+            ItemStack itemstack1 = ItemProjectileWeapon.a((EntityLiving) this, predicate);
+
+            return itemstack1.isEmpty() ? new ItemStack(Items.ARROW) : itemstack1;
+        } else {
+            return ItemStack.b;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/monster/EntityVindicator.java b/src/main/java/net/minecraft/world/entity/monster/EntityVindicator.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc1f0cd4b70cdd0dda538d8867fab4cb8443120e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/monster/EntityVindicator.java
@@ -0,0 +1,249 @@
+package net.minecraft.world.entity.monster;
+
+import com.google.common.collect.Maps;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.world.DifficultyDamageScaler;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.EnumItemSlot;
+import net.minecraft.world.entity.EnumMobSpawn;
+import net.minecraft.world.entity.EnumMonsterType;
+import net.minecraft.world.entity.GroupDataEntity;
+import net.minecraft.world.entity.ai.attributes.AttributeProvider;
+import net.minecraft.world.entity.ai.attributes.GenericAttributes;
+import net.minecraft.world.entity.ai.goal.PathfinderGoal;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalBreakDoor;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalFloat;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalLookAtPlayer;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalMeleeAttack;
+import net.minecraft.world.entity.ai.goal.PathfinderGoalRandomStroll;
+import net.minecraft.world.entity.ai.goal.target.PathfinderGoalHurtByTarget;
+import net.minecraft.world.entity.ai.goal.target.PathfinderGoalNearestAttackableTarget;
+import net.minecraft.world.entity.ai.navigation.Navigation;
+import net.minecraft.world.entity.ai.util.PathfinderGoalUtil;
+import net.minecraft.world.entity.animal.EntityIronGolem;
+import net.minecraft.world.entity.npc.EntityVillagerAbstract;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.raid.EntityRaider;
+import net.minecraft.world.entity.raid.Raid;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentManager;
+import net.minecraft.world.item.enchantment.Enchantments;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.WorldAccess;
+
+public class EntityVindicator extends EntityIllagerAbstract {
+
+    private static final Predicate<EnumDifficulty> b = (enumdifficulty) -> {
+        return enumdifficulty == EnumDifficulty.NORMAL || enumdifficulty == EnumDifficulty.HARD;
+    };
+    private boolean bo;
+
+    public EntityVindicator(EntityTypes<? extends EntityVindicator> entitytypes, World world) {
+        super(entitytypes, world);
+    }
+
+    @Override
+    protected void initPathfinder() {
+        super.initPathfinder();
+        this.goalSelector.a(0, new PathfinderGoalFloat(this));
+        this.goalSelector.a(1, new EntityVindicator.a(this));
+        this.goalSelector.a(2, new EntityIllagerAbstract.b(this));
+        this.goalSelector.a(3, new EntityRaider.a(this, 10.0F));
+        this.goalSelector.a(4, new EntityVindicator.c(this));
+        this.targetSelector.a(1, (new PathfinderGoalHurtByTarget(this, new Class[]{EntityRaider.class})).a());
+        this.targetSelector.a(2, new PathfinderGoalNearestAttackableTarget<>(this, EntityHuman.class, true));
+        this.targetSelector.a(3, new PathfinderGoalNearestAttackableTarget<>(this, EntityVillagerAbstract.class, true));
+        this.targetSelector.a(3, new PathfinderGoalNearestAttackableTarget<>(this, EntityIronGolem.class, true));
+        this.targetSelector.a(4, new EntityVindicator.b(this));
+        this.goalSelector.a(8, new PathfinderGoalRandomStroll(this, 0.6D));
+        this.goalSelector.a(9, new PathfinderGoalLookAtPlayer(this, EntityHuman.class, 3.0F, 1.0F));
+        this.goalSelector.a(10, new PathfinderGoalLookAtPlayer(this, EntityInsentient.class, 8.0F));
+    }
+
+    @Override
+    protected void mobTick() {
+        if (!this.isNoAI() && PathfinderGoalUtil.a(this)) {
+            boolean flag = ((WorldServer) this.world).c_(this.getChunkCoordinates());
+
+            ((Navigation) this.getNavigation()).a(flag);
+        }
+
+        super.mobTick();
+    }
+
+    public static AttributeProvider.Builder eK() {
+        return EntityMonster.eR().a(GenericAttributes.MOVEMENT_SPEED, 0.3499999940395355D).a(GenericAttributes.FOLLOW_RANGE, 12.0D).a(GenericAttributes.MAX_HEALTH, 24.0D).a(GenericAttributes.ATTACK_DAMAGE, 5.0D);
+    }
+
+    @Override
+    public void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        if (this.bo) {
+            nbttagcompound.setBoolean("Johnny", true);
+        }
+
+    }
+
+    @Override
+    public void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        if (nbttagcompound.hasKeyOfType("Johnny", 99)) {
+            this.bo = nbttagcompound.getBoolean("Johnny");
+        }
+
+    }
+
+    @Override
+    public SoundEffect eL() {
+        return SoundEffects.ENTITY_VINDICATOR_CELEBRATE;
+    }
+
+    @Nullable
+    @Override
+    public GroupDataEntity prepare(WorldAccess worldaccess, DifficultyDamageScaler difficultydamagescaler, EnumMobSpawn enummobspawn, @Nullable GroupDataEntity groupdataentity, @Nullable NBTTagCompound nbttagcompound) {
+        GroupDataEntity groupdataentity1 = super.prepare(worldaccess, difficultydamagescaler, enummobspawn, groupdataentity, nbttagcompound);
+
+        ((Navigation) this.getNavigation()).a(true);
+        this.a(difficultydamagescaler);
+        this.b(difficultydamagescaler);
+        return groupdataentity1;
+    }
+
+    @Override
+    protected void a(DifficultyDamageScaler difficultydamagescaler) {
+        if (this.fa() == null) {
+            this.setSlot(EnumItemSlot.MAINHAND, new ItemStack(Items.IRON_AXE));
+        }
+
+    }
+
+    @Override
+    public boolean r(Entity entity) {
+        return super.r(entity) ? true : (entity instanceof EntityLiving && ((EntityLiving) entity).getMonsterType() == EnumMonsterType.ILLAGER ? this.getScoreboardTeam() == null && entity.getScoreboardTeam() == null : false);
+    }
+
+    @Override
+    public void setCustomName(@Nullable IChatBaseComponent ichatbasecomponent) {
+        super.setCustomName(ichatbasecomponent);
+        if (!this.bo && ichatbasecomponent != null && ichatbasecomponent.getString().equals("Johnny")) {
+            this.bo = true;
+        }
+
+    }
+
+    @Override
+    protected SoundEffect getSoundAmbient() {
+        return SoundEffects.ENTITY_VINDICATOR_AMBIENT;
+    }
+
+    @Override
+    protected SoundEffect getSoundDeath() {
+        return SoundEffects.ENTITY_VINDICATOR_DEATH;
+    }
+
+    @Override
+    protected SoundEffect getSoundHurt(DamageSource damagesource) {
+        return SoundEffects.ENTITY_VINDICATOR_HURT;
+    }
+
+    @Override
+    public void a(int i, boolean flag) {
+        ItemStack itemstack = new ItemStack(Items.IRON_AXE);
+        Raid raid = this.fa();
+        byte b0 = 1;
+
+        if (i > raid.a(EnumDifficulty.NORMAL)) {
+            b0 = 2;
+        }
+
+        boolean flag1 = this.random.nextFloat() <= raid.w();
+
+        if (flag1) {
+            Map<Enchantment, Integer> map = Maps.newHashMap();
+
+            map.put(Enchantments.DAMAGE_ALL, Integer.valueOf(b0));
+            EnchantmentManager.a((Map) map, itemstack);
+        }
+
+        this.setSlot(EnumItemSlot.MAINHAND, itemstack);
+    }
+
+    static class b extends PathfinderGoalNearestAttackableTarget<EntityLiving> {
+
+        public b(EntityVindicator entityvindicator) {
+            super(entityvindicator, EntityLiving.class, 0, true, true, EntityLiving::ei);
+        }
+
+        @Override
+        public boolean a() {
+            return ((EntityVindicator) this.e).bo && super.a();
+        }
+
+        @Override
+        public void c() {
+            super.c();
+            this.e.n(0);
+        }
+    }
+
+    static class a extends PathfinderGoalBreakDoor {
+
+        public a(EntityInsentient entityinsentient) {
+            super(entityinsentient, 6, EntityVindicator.b);
+            this.a(EnumSet.of(PathfinderGoal.Type.MOVE));
+        }
+
+        @Override
+        public boolean b() {
+            EntityVindicator entityvindicator = (EntityVindicator) this.entity;
+
+            return entityvindicator.fb() && super.b();
+        }
+
+        @Override
+        public boolean a() {
+            EntityVindicator entityvindicator = (EntityVindicator) this.entity;
+
+            return entityvindicator.fb() && entityvindicator.random.nextInt(10) == 0 && super.a();
+        }
+
+        @Override
+        public void c() {
+            super.c();
+            this.entity.n(0);
+        }
+    }
+
+    class c extends PathfinderGoalMeleeAttack {
+
+        public c(EntityVindicator entityvindicator) {
+            super(entityvindicator, 1.0D, false);
+        }
+
+        @Override
+        protected double a(EntityLiving entityliving) {
+            if (this.a.getVehicle() instanceof EntityRavager) {
+                float f = this.a.getVehicle().getWidth() - 0.1F;
+
+                return (double) (f * 2.0F * f * 2.0F + entityliving.getWidth());
+            } else {
+                return super.a(entityliving);
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/monster/IRangedEntity.java b/src/main/java/net/minecraft/world/entity/monster/IRangedEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..d79e6b28c77edc468c6471d909306c2135b496c7
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/monster/IRangedEntity.java
@@ -0,0 +1,8 @@
+package net.minecraft.world.entity.monster;
+
+import net.minecraft.world.entity.EntityLiving;
+
+public interface IRangedEntity {
+
+    void a(EntityLiving entityliving, float f);
+}
diff --git a/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java b/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe1dde99f758daa730acacc78237d92aa443ab6d
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
@@ -0,0 +1,408 @@
+package net.minecraft.world.entity.npc;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Random;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IRegistry;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.effect.MobEffectList;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.item.EnumColor;
+import net.minecraft.world.item.IDyeable;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemArmorColorable;
+import net.minecraft.world.item.ItemDye;
+import net.minecraft.world.item.ItemEnchantedBook;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.ItemSuspiciousStew;
+import net.minecraft.world.item.ItemWorldMap;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.alchemy.PotionBrewer;
+import net.minecraft.world.item.alchemy.PotionRegistry;
+import net.minecraft.world.item.alchemy.PotionUtil;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentManager;
+import net.minecraft.world.item.enchantment.WeightedRandomEnchant;
+import net.minecraft.world.item.trading.MerchantRecipe;
+import net.minecraft.world.level.IMaterial;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.levelgen.feature.StructureGenerator;
+import net.minecraft.world.level.saveddata.maps.MapIcon;
+import net.minecraft.world.level.saveddata.maps.WorldMap;
+
+public class VillagerTrades {
+
+    public static final Map<VillagerProfession, Int2ObjectMap<VillagerTrades.IMerchantRecipeOption[]>> a = (Map) SystemUtils.a((Object) Maps.newHashMap(), (hashmap) -> {
+        hashmap.put(VillagerProfession.FARMER, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.WHEAT, 20, 16, 2), new VillagerTrades.b(Items.POTATO, 26, 16, 2), new VillagerTrades.b(Items.CARROT, 22, 16, 2), new VillagerTrades.b(Items.BEETROOT, 15, 16, 2), new VillagerTrades.h(Items.BREAD, 1, 6, 16, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Blocks.PUMPKIN, 6, 12, 10), new VillagerTrades.h(Items.PUMPKIN_PIE, 1, 4, 5), new VillagerTrades.h(Items.APPLE, 1, 4, 16, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Items.COOKIE, 3, 18, 10), new VillagerTrades.b(Blocks.MELON, 4, 12, 20)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Blocks.CAKE, 1, 1, 12, 15), new VillagerTrades.i(MobEffects.NIGHT_VISION, 100, 15), new VillagerTrades.i(MobEffects.JUMP, 160, 15), new VillagerTrades.i(MobEffects.WEAKNESS, 140, 15), new VillagerTrades.i(MobEffects.BLINDNESS, 120, 15), new VillagerTrades.i(MobEffects.POISON, 280, 15), new VillagerTrades.i(MobEffects.SATURATION, 7, 15)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Items.GOLDEN_CARROT, 3, 3, 30), new VillagerTrades.h(Items.GLISTERING_MELON_SLICE, 4, 3, 30)})));
+        hashmap.put(VillagerProfession.FISHERMAN, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.STRING, 20, 16, 2), new VillagerTrades.b(Items.COAL, 10, 16, 2), new VillagerTrades.g(Items.COD, 6, Items.COOKED_COD, 6, 16, 1), new VillagerTrades.h(Items.COD_BUCKET, 3, 1, 16, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.COD, 15, 16, 10), new VillagerTrades.g(Items.SALMON, 6, Items.COOKED_SALMON, 6, 16, 5), new VillagerTrades.h(Items.rn, 2, 1, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.SALMON, 13, 16, 20), new VillagerTrades.e(Items.FISHING_ROD, 3, 3, 10, 0.2F)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.TROPICAL_FISH, 6, 12, 30)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.PUFFERFISH, 4, 12, 30), new VillagerTrades.c(1, 12, 30, ImmutableMap.builder().put(VillagerType.PLAINS, Items.OAK_BOAT).put(VillagerType.TAIGA, Items.SPRUCE_BOAT).put(VillagerType.SNOW, Items.SPRUCE_BOAT).put(VillagerType.DESERT, Items.JUNGLE_BOAT).put(VillagerType.JUNGLE, Items.JUNGLE_BOAT).put(VillagerType.SAVANNA, Items.ACACIA_BOAT).put(VillagerType.SWAMP, Items.DARK_OAK_BOAT).build())})));
+        hashmap.put(VillagerProfession.SHEPHERD, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Blocks.WHITE_WOOL, 18, 16, 2), new VillagerTrades.b(Blocks.BROWN_WOOL, 18, 16, 2), new VillagerTrades.b(Blocks.BLACK_WOOL, 18, 16, 2), new VillagerTrades.b(Blocks.GRAY_WOOL, 18, 16, 2), new VillagerTrades.h(Items.SHEARS, 2, 1, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.WHITE_DYE, 12, 16, 10), new VillagerTrades.b(Items.GRAY_DYE, 12, 16, 10), new VillagerTrades.b(Items.BLACK_DYE, 12, 16, 10), new VillagerTrades.b(Items.LIGHT_BLUE_DYE, 12, 16, 10), new VillagerTrades.b(Items.LIME_DYE, 12, 16, 10), new VillagerTrades.h(Blocks.WHITE_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.ORANGE_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.MAGENTA_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.LIGHT_BLUE_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.YELLOW_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.LIME_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.PINK_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.GRAY_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.LIGHT_GRAY_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.CYAN_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.PURPLE_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.BLUE_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.BROWN_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.GREEN_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.RED_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.BLACK_WOOL, 1, 1, 16, 5), new VillagerTrades.h(Blocks.WHITE_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.ORANGE_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.MAGENTA_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.LIGHT_BLUE_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.YELLOW_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.LIME_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.PINK_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.GRAY_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.LIGHT_GRAY_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.CYAN_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.PURPLE_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.BLUE_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.BROWN_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.GREEN_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.RED_CARPET, 1, 4, 16, 5), new VillagerTrades.h(Blocks.BLACK_CARPET, 1, 4, 16, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.YELLOW_DYE, 12, 16, 20), new VillagerTrades.b(Items.LIGHT_GRAY_DYE, 12, 16, 20), new VillagerTrades.b(Items.ORANGE_DYE, 12, 16, 20), new VillagerTrades.b(Items.RED_DYE, 12, 16, 20), new VillagerTrades.b(Items.PINK_DYE, 12, 16, 20), new VillagerTrades.h(Blocks.WHITE_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.YELLOW_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.RED_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.BLACK_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.BLUE_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.BROWN_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.CYAN_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.GRAY_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.GREEN_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.LIGHT_BLUE_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.LIGHT_GRAY_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.LIME_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.MAGENTA_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.ORANGE_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.PINK_BED, 3, 1, 12, 10), new VillagerTrades.h(Blocks.PURPLE_BED, 3, 1, 12, 10)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.BROWN_DYE, 12, 16, 30), new VillagerTrades.b(Items.PURPLE_DYE, 12, 16, 30), new VillagerTrades.b(Items.BLUE_DYE, 12, 16, 30), new VillagerTrades.b(Items.GREEN_DYE, 12, 16, 30), new VillagerTrades.b(Items.MAGENTA_DYE, 12, 16, 30), new VillagerTrades.b(Items.CYAN_DYE, 12, 16, 30), new VillagerTrades.h(Items.WHITE_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.BLUE_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.LIGHT_BLUE_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.RED_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.PINK_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.GREEN_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.LIME_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.GRAY_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.BLACK_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.PURPLE_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.MAGENTA_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.CYAN_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.BROWN_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.YELLOW_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.ORANGE_BANNER, 3, 1, 12, 15), new VillagerTrades.h(Items.LIGHT_GRAY_BANNER, 3, 1, 12, 15)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Items.PAINTING, 2, 3, 30)})));
+        hashmap.put(VillagerProfession.FLETCHER, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.STICK, 32, 16, 2), new VillagerTrades.h(Items.ARROW, 1, 16, 1), new VillagerTrades.g(Blocks.GRAVEL, 10, Items.FLINT, 10, 12, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.FLINT, 26, 12, 10), new VillagerTrades.h(Items.BOW, 2, 1, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.STRING, 14, 16, 20), new VillagerTrades.h(Items.CROSSBOW, 3, 1, 10)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.FEATHER, 24, 16, 30), new VillagerTrades.e(Items.BOW, 2, 3, 15)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.es, 8, 12, 30), new VillagerTrades.e(Items.CROSSBOW, 3, 3, 15), new VillagerTrades.j(Items.ARROW, 5, Items.TIPPED_ARROW, 5, 2, 12, 30)})));
+        hashmap.put(VillagerProfession.LIBRARIAN, a(ImmutableMap.builder().put(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.PAPER, 24, 16, 2), new VillagerTrades.d(1), new VillagerTrades.h(Blocks.BOOKSHELF, 9, 1, 12, 1)}).put(2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.BOOK, 4, 12, 10), new VillagerTrades.d(5), new VillagerTrades.h(Items.rk, 1, 1, 5)}).put(3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.INK_SAC, 5, 12, 20), new VillagerTrades.d(10), new VillagerTrades.h(Items.az, 1, 4, 10)}).put(4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.WRITABLE_BOOK, 2, 12, 30), new VillagerTrades.d(15), new VillagerTrades.h(Items.CLOCK, 5, 1, 15), new VillagerTrades.h(Items.COMPASS, 4, 1, 15)}).put(5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Items.NAME_TAG, 20, 1, 30)}).build()));
+        hashmap.put(VillagerProfession.CARTOGRAPHER, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.PAPER, 24, 16, 2), new VillagerTrades.h(Items.MAP, 7, 1, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.dP, 11, 16, 10), new VillagerTrades.k(13, StructureGenerator.MONUMENT, MapIcon.Type.MONUMENT, 12, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.COMPASS, 1, 12, 20), new VillagerTrades.k(14, StructureGenerator.MANSION, MapIcon.Type.MANSION, 12, 10)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Items.ITEM_FRAME, 7, 1, 15), new VillagerTrades.h(Items.WHITE_BANNER, 3, 1, 15), new VillagerTrades.h(Items.BLUE_BANNER, 3, 1, 15), new VillagerTrades.h(Items.LIGHT_BLUE_BANNER, 3, 1, 15), new VillagerTrades.h(Items.RED_BANNER, 3, 1, 15), new VillagerTrades.h(Items.PINK_BANNER, 3, 1, 15), new VillagerTrades.h(Items.GREEN_BANNER, 3, 1, 15), new VillagerTrades.h(Items.LIME_BANNER, 3, 1, 15), new VillagerTrades.h(Items.GRAY_BANNER, 3, 1, 15), new VillagerTrades.h(Items.BLACK_BANNER, 3, 1, 15), new VillagerTrades.h(Items.PURPLE_BANNER, 3, 1, 15), new VillagerTrades.h(Items.MAGENTA_BANNER, 3, 1, 15), new VillagerTrades.h(Items.CYAN_BANNER, 3, 1, 15), new VillagerTrades.h(Items.BROWN_BANNER, 3, 1, 15), new VillagerTrades.h(Items.YELLOW_BANNER, 3, 1, 15), new VillagerTrades.h(Items.ORANGE_BANNER, 3, 1, 15), new VillagerTrades.h(Items.LIGHT_GRAY_BANNER, 3, 1, 15)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Items.GLOBE_BANNER_PATTERN, 8, 1, 30)})));
+        hashmap.put(VillagerProfession.CLERIC, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.ROTTEN_FLESH, 32, 16, 2), new VillagerTrades.h(Items.REDSTONE, 1, 2, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.GOLD_INGOT, 3, 12, 10), new VillagerTrades.h(Items.LAPIS_LAZULI, 1, 1, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.RABBIT_FOOT, 2, 12, 20), new VillagerTrades.h(Blocks.GLOWSTONE, 4, 1, 12, 10)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.SCUTE, 4, 12, 30), new VillagerTrades.b(Items.GLASS_BOTTLE, 9, 12, 30), new VillagerTrades.h(Items.ENDER_PEARL, 5, 1, 15)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.NETHER_WART, 22, 12, 30), new VillagerTrades.h(Items.EXPERIENCE_BOTTLE, 3, 1, 30)})));
+        hashmap.put(VillagerProfession.ARMORER, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.COAL, 15, 16, 2), new VillagerTrades.h(new ItemStack(Items.IRON_LEGGINGS), 7, 1, 12, 1, 0.2F), new VillagerTrades.h(new ItemStack(Items.IRON_BOOTS), 4, 1, 12, 1, 0.2F), new VillagerTrades.h(new ItemStack(Items.IRON_HELMET), 5, 1, 12, 1, 0.2F), new VillagerTrades.h(new ItemStack(Items.IRON_CHESTPLATE), 9, 1, 12, 1, 0.2F)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.IRON_INGOT, 4, 12, 10), new VillagerTrades.h(new ItemStack(Items.rj), 36, 1, 12, 5, 0.2F), new VillagerTrades.h(new ItemStack(Items.CHAINMAIL_BOOTS), 1, 1, 12, 5, 0.2F), new VillagerTrades.h(new ItemStack(Items.CHAINMAIL_LEGGINGS), 3, 1, 12, 5, 0.2F)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.LAVA_BUCKET, 1, 12, 20), new VillagerTrades.b(Items.DIAMOND, 1, 12, 20), new VillagerTrades.h(new ItemStack(Items.CHAINMAIL_HELMET), 1, 1, 12, 10, 0.2F), new VillagerTrades.h(new ItemStack(Items.CHAINMAIL_CHESTPLATE), 4, 1, 12, 10, 0.2F), new VillagerTrades.h(new ItemStack(Items.SHIELD), 5, 1, 12, 10, 0.2F)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.e(Items.DIAMOND_LEGGINGS, 14, 3, 15, 0.2F), new VillagerTrades.e(Items.DIAMOND_BOOTS, 8, 3, 15, 0.2F)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.e(Items.DIAMOND_HELMET, 8, 3, 30, 0.2F), new VillagerTrades.e(Items.DIAMOND_CHESTPLATE, 16, 3, 30, 0.2F)})));
+        hashmap.put(VillagerProfession.WEAPONSMITH, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.COAL, 15, 16, 2), new VillagerTrades.h(new ItemStack(Items.IRON_AXE), 3, 1, 12, 1, 0.2F), new VillagerTrades.e(Items.IRON_SWORD, 2, 3, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.IRON_INGOT, 4, 12, 10), new VillagerTrades.h(new ItemStack(Items.rj), 36, 1, 12, 5, 0.2F)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.FLINT, 24, 12, 20)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.DIAMOND, 1, 12, 30), new VillagerTrades.e(Items.DIAMOND_AXE, 12, 3, 15, 0.2F)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.e(Items.DIAMOND_SWORD, 8, 3, 30, 0.2F)})));
+        hashmap.put(VillagerProfession.TOOLSMITH, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.COAL, 15, 16, 2), new VillagerTrades.h(new ItemStack(Items.STONE_AXE), 1, 1, 12, 1, 0.2F), new VillagerTrades.h(new ItemStack(Items.STONE_SHOVEL), 1, 1, 12, 1, 0.2F), new VillagerTrades.h(new ItemStack(Items.STONE_PICKAXE), 1, 1, 12, 1, 0.2F), new VillagerTrades.h(new ItemStack(Items.STONE_HOE), 1, 1, 12, 1, 0.2F)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.IRON_INGOT, 4, 12, 10), new VillagerTrades.h(new ItemStack(Items.rj), 36, 1, 12, 5, 0.2F)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.FLINT, 30, 12, 20), new VillagerTrades.e(Items.IRON_AXE, 1, 3, 10, 0.2F), new VillagerTrades.e(Items.IRON_SHOVEL, 2, 3, 10, 0.2F), new VillagerTrades.e(Items.IRON_PICKAXE, 3, 3, 10, 0.2F), new VillagerTrades.h(new ItemStack(Items.DIAMOND_HOE), 4, 1, 3, 10, 0.2F)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.DIAMOND, 1, 12, 30), new VillagerTrades.e(Items.DIAMOND_AXE, 12, 3, 15, 0.2F), new VillagerTrades.e(Items.DIAMOND_SHOVEL, 5, 3, 15, 0.2F)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.e(Items.DIAMOND_PICKAXE, 13, 3, 30, 0.2F)})));
+        hashmap.put(VillagerProfession.BUTCHER, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.CHICKEN, 14, 16, 2), new VillagerTrades.b(Items.PORKCHOP, 7, 16, 2), new VillagerTrades.b(Items.RABBIT, 4, 16, 2), new VillagerTrades.h(Items.RABBIT_STEW, 1, 1, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.COAL, 15, 16, 2), new VillagerTrades.h(Items.COOKED_PORKCHOP, 1, 5, 16, 5), new VillagerTrades.h(Items.COOKED_CHICKEN, 1, 8, 16, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.MUTTON, 7, 16, 20), new VillagerTrades.b(Items.BEEF, 10, 16, 20)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.ma, 10, 12, 30)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.SWEET_BERRIES, 10, 12, 30)})));
+        hashmap.put(VillagerProfession.LEATHERWORKER, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.LEATHER, 6, 16, 2), new VillagerTrades.a(Items.LEATHER_LEGGINGS, 3), new VillagerTrades.a(Items.LEATHER_CHESTPLATE, 7)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.FLINT, 26, 12, 10), new VillagerTrades.a(Items.LEATHER_HELMET, 5, 12, 5), new VillagerTrades.a(Items.LEATHER_BOOTS, 4, 12, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.RABBIT_HIDE, 9, 12, 20), new VillagerTrades.a(Items.LEATHER_CHESTPLATE, 7)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.SCUTE, 4, 12, 30), new VillagerTrades.a(Items.LEATHER_HORSE_ARMOR, 6, 12, 15)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(new ItemStack(Items.SADDLE), 6, 1, 12, 30, 0.2F), new VillagerTrades.a(Items.LEATHER_HELMET, 5, 12, 30)})));
+        hashmap.put(VillagerProfession.MASON, a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.CLAY_BALL, 10, 16, 2), new VillagerTrades.h(Items.BRICK, 1, 10, 16, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Blocks.STONE, 20, 16, 10), new VillagerTrades.h(Blocks.CHISELED_STONE_BRICKS, 1, 4, 16, 5)}, 3, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Blocks.GRANITE, 16, 16, 20), new VillagerTrades.b(Blocks.ANDESITE, 16, 16, 20), new VillagerTrades.b(Blocks.DIORITE, 16, 16, 20), new VillagerTrades.h(Blocks.POLISHED_ANDESITE, 1, 4, 16, 10), new VillagerTrades.h(Blocks.POLISHED_DIORITE, 1, 4, 16, 10), new VillagerTrades.h(Blocks.POLISHED_GRANITE, 1, 4, 16, 10)}, 4, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.b(Items.QUARTZ, 12, 12, 30), new VillagerTrades.h(Blocks.ORANGE_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.WHITE_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.BLUE_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.LIGHT_BLUE_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.GRAY_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.LIGHT_GRAY_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.BLACK_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.RED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.PINK_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.MAGENTA_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.LIME_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.GREEN_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.CYAN_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.PURPLE_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.YELLOW_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.BROWN_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.ORANGE_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.WHITE_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.BLUE_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.LIGHT_BLUE_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.GRAY_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.LIGHT_GRAY_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.BLACK_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.RED_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.PINK_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.MAGENTA_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.LIME_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.GREEN_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.CYAN_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.PURPLE_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.YELLOW_GLAZED_TERRACOTTA, 1, 1, 12, 15), new VillagerTrades.h(Blocks.BROWN_GLAZED_TERRACOTTA, 1, 1, 12, 15)}, 5, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Blocks.QUARTZ_PILLAR, 1, 1, 12, 30), new VillagerTrades.h(Blocks.QUARTZ_BLOCK, 1, 1, 12, 30)})));
+    });
+    public static final Int2ObjectMap<VillagerTrades.IMerchantRecipeOption[]> b = a(ImmutableMap.of(1, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Items.aP, 2, 1, 5, 1), new VillagerTrades.h(Items.SLIME_BALL, 4, 1, 5, 1), new VillagerTrades.h(Items.dq, 2, 1, 5, 1), new VillagerTrades.h(Items.NAUTILUS_SHELL, 5, 1, 5, 1), new VillagerTrades.h(Items.aM, 1, 1, 12, 1), new VillagerTrades.h(Items.bD, 1, 1, 8, 1), new VillagerTrades.h(Items.di, 1, 1, 4, 1), new VillagerTrades.h(Items.bE, 3, 1, 12, 1), new VillagerTrades.h(Items.cX, 3, 1, 8, 1), new VillagerTrades.h(Items.bh, 1, 1, 12, 1), new VillagerTrades.h(Items.bi, 1, 1, 12, 1), new VillagerTrades.h(Items.bj, 1, 1, 8, 1), new VillagerTrades.h(Items.bk, 1, 1, 12, 1), new VillagerTrades.h(Items.bl, 1, 1, 12, 1), new VillagerTrades.h(Items.bm, 1, 1, 12, 1), new VillagerTrades.h(Items.bn, 1, 1, 12, 1), new VillagerTrades.h(Items.bo, 1, 1, 12, 1), new VillagerTrades.h(Items.bp, 1, 1, 12, 1), new VillagerTrades.h(Items.bq, 1, 1, 12, 1), new VillagerTrades.h(Items.br, 1, 1, 12, 1), new VillagerTrades.h(Items.bs, 1, 1, 7, 1), new VillagerTrades.h(Items.WHEAT_SEEDS, 1, 1, 12, 1), new VillagerTrades.h(Items.BEETROOT_SEEDS, 1, 1, 12, 1), new VillagerTrades.h(Items.PUMPKIN_SEEDS, 1, 1, 12, 1), new VillagerTrades.h(Items.MELON_SEEDS, 1, 1, 12, 1), new VillagerTrades.h(Items.B, 5, 1, 8, 1), new VillagerTrades.h(Items.z, 5, 1, 8, 1), new VillagerTrades.h(Items.C, 5, 1, 8, 1), new VillagerTrades.h(Items.A, 5, 1, 8, 1), new VillagerTrades.h(Items.x, 5, 1, 8, 1), new VillagerTrades.h(Items.y, 5, 1, 8, 1), new VillagerTrades.h(Items.RED_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.WHITE_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.BLUE_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.PINK_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.BLACK_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.GREEN_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.LIGHT_GRAY_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.MAGENTA_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.YELLOW_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.GRAY_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.PURPLE_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.LIGHT_BLUE_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.LIME_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.ORANGE_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.BROWN_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.CYAN_DYE, 1, 3, 12, 1), new VillagerTrades.h(Items.iJ, 3, 1, 8, 1), new VillagerTrades.h(Items.iK, 3, 1, 8, 1), new VillagerTrades.h(Items.iL, 3, 1, 8, 1), new VillagerTrades.h(Items.iM, 3, 1, 8, 1), new VillagerTrades.h(Items.iI, 3, 1, 8, 1), new VillagerTrades.h(Items.dR, 1, 1, 12, 1), new VillagerTrades.h(Items.bu, 1, 1, 12, 1), new VillagerTrades.h(Items.bv, 1, 1, 12, 1), new VillagerTrades.h(Items.ed, 1, 2, 5, 1), new VillagerTrades.h(Items.E, 1, 8, 8, 1), new VillagerTrades.h(Items.F, 1, 4, 6, 1)}, 2, new VillagerTrades.IMerchantRecipeOption[]{new VillagerTrades.h(Items.TROPICAL_FISH_BUCKET, 5, 1, 4, 1), new VillagerTrades.h(Items.PUFFERFISH_BUCKET, 5, 1, 4, 1), new VillagerTrades.h(Items.ge, 3, 1, 6, 1), new VillagerTrades.h(Items.jh, 6, 1, 6, 1), new VillagerTrades.h(Items.GUNPOWDER, 1, 1, 8, 1), new VillagerTrades.h(Items.l, 3, 3, 6, 1)}));
+
+    private static Int2ObjectMap<VillagerTrades.IMerchantRecipeOption[]> a(ImmutableMap<Integer, VillagerTrades.IMerchantRecipeOption[]> immutablemap) {
+        return new Int2ObjectOpenHashMap(immutablemap);
+    }
+
+    static class g implements VillagerTrades.IMerchantRecipeOption {
+
+        private final ItemStack a;
+        private final int b;
+        private final int c;
+        private final ItemStack d;
+        private final int e;
+        private final int f;
+        private final int g;
+        private final float h;
+
+        public g(IMaterial imaterial, int i, Item item, int j, int k, int l) {
+            this(imaterial, i, 1, item, j, k, l);
+        }
+
+        public g(IMaterial imaterial, int i, int j, Item item, int k, int l, int i1) {
+            this.a = new ItemStack(imaterial);
+            this.b = i;
+            this.c = j;
+            this.d = new ItemStack(item);
+            this.e = k;
+            this.f = l;
+            this.g = i1;
+            this.h = 0.05F;
+        }
+
+        @Nullable
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            return new MerchantRecipe(new ItemStack(Items.EMERALD, this.c), new ItemStack(this.a.getItem(), this.b), new ItemStack(this.d.getItem(), this.e), this.f, this.g, this.h);
+        }
+    }
+
+    static class k implements VillagerTrades.IMerchantRecipeOption {
+
+        private final int a;
+        private final StructureGenerator<?> b;
+        private final MapIcon.Type c;
+        private final int d;
+        private final int e;
+
+        public k(int i, StructureGenerator<?> structuregenerator, MapIcon.Type mapicon_type, int j, int k) {
+            this.a = i;
+            this.b = structuregenerator;
+            this.c = mapicon_type;
+            this.d = j;
+            this.e = k;
+        }
+
+        @Nullable
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            if (!(entity.world instanceof WorldServer)) {
+                return null;
+            } else {
+                WorldServer worldserver = (WorldServer) entity.world;
+                BlockPosition blockposition = worldserver.a(this.b, entity.getChunkCoordinates(), 100, true);
+
+                if (blockposition != null) {
+                    ItemStack itemstack = ItemWorldMap.createFilledMapView(worldserver, blockposition.getX(), blockposition.getZ(), (byte) 2, true, true);
+
+                    ItemWorldMap.applySepiaFilter(worldserver, itemstack);
+                    WorldMap.decorateMap(itemstack, blockposition, "+", this.c);
+                    itemstack.a((IChatBaseComponent) (new ChatMessage("filled_map." + this.b.i().toLowerCase(Locale.ROOT))));
+                    return new MerchantRecipe(new ItemStack(Items.EMERALD, this.a), new ItemStack(Items.COMPASS), itemstack, this.d, this.e, 0.2F);
+                } else {
+                    return null;
+                }
+            }
+        }
+    }
+
+    static class d implements VillagerTrades.IMerchantRecipeOption {
+
+        private final int a;
+
+        public d(int i) {
+            this.a = i;
+        }
+
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            List<Enchantment> list = (List) IRegistry.ENCHANTMENT.g().filter(Enchantment::h).collect(Collectors.toList());
+            Enchantment enchantment = (Enchantment) list.get(random.nextInt(list.size()));
+            int i = MathHelper.nextInt(random, enchantment.getStartLevel(), enchantment.getMaxLevel());
+            ItemStack itemstack = ItemEnchantedBook.a(new WeightedRandomEnchant(enchantment, i));
+            int j = 2 + random.nextInt(5 + i * 10) + 3 * i;
+
+            if (enchantment.isTreasure()) {
+                j *= 2;
+            }
+
+            if (j > 64) {
+                j = 64;
+            }
+
+            return new MerchantRecipe(new ItemStack(Items.EMERALD, j), new ItemStack(Items.BOOK), itemstack, 12, this.a, 0.2F);
+        }
+    }
+
+    static class a implements VillagerTrades.IMerchantRecipeOption {
+
+        private final Item a;
+        private final int b;
+        private final int c;
+        private final int d;
+
+        public a(Item item, int i) {
+            this(item, i, 12, 1);
+        }
+
+        public a(Item item, int i, int j, int k) {
+            this.a = item;
+            this.b = i;
+            this.c = j;
+            this.d = k;
+        }
+
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            ItemStack itemstack = new ItemStack(Items.EMERALD, this.b);
+            ItemStack itemstack1 = new ItemStack(this.a);
+
+            if (this.a instanceof ItemArmorColorable) {
+                List<ItemDye> list = Lists.newArrayList();
+
+                list.add(a(random));
+                if (random.nextFloat() > 0.7F) {
+                    list.add(a(random));
+                }
+
+                if (random.nextFloat() > 0.8F) {
+                    list.add(a(random));
+                }
+
+                itemstack1 = IDyeable.a(itemstack1, list);
+            }
+
+            return new MerchantRecipe(itemstack, itemstack1, this.c, this.d, 0.2F);
+        }
+
+        private static ItemDye a(Random random) {
+            return ItemDye.a(EnumColor.fromColorIndex(random.nextInt(16)));
+        }
+    }
+
+    static class j implements VillagerTrades.IMerchantRecipeOption {
+
+        private final ItemStack a;
+        private final int b;
+        private final int c;
+        private final int d;
+        private final int e;
+        private final Item f;
+        private final int g;
+        private final float h;
+
+        public j(Item item, int i, Item item1, int j, int k, int l, int i1) {
+            this.a = new ItemStack(item1);
+            this.c = k;
+            this.d = l;
+            this.e = i1;
+            this.f = item;
+            this.g = i;
+            this.b = j;
+            this.h = 0.05F;
+        }
+
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            ItemStack itemstack = new ItemStack(Items.EMERALD, this.c);
+            List<PotionRegistry> list = (List) IRegistry.POTION.g().filter((potionregistry) -> {
+                return !potionregistry.a().isEmpty() && PotionBrewer.a(potionregistry);
+            }).collect(Collectors.toList());
+            PotionRegistry potionregistry = (PotionRegistry) list.get(random.nextInt(list.size()));
+            ItemStack itemstack1 = PotionUtil.a(new ItemStack(this.a.getItem(), this.b), potionregistry);
+
+            return new MerchantRecipe(itemstack, new ItemStack(this.f, this.g), itemstack1, this.d, this.e, this.h);
+        }
+    }
+
+    static class e implements VillagerTrades.IMerchantRecipeOption {
+
+        private final ItemStack a;
+        private final int b;
+        private final int c;
+        private final int d;
+        private final float e;
+
+        public e(Item item, int i, int j, int k) {
+            this(item, i, j, k, 0.05F);
+        }
+
+        public e(Item item, int i, int j, int k, float f) {
+            this.a = new ItemStack(item);
+            this.b = i;
+            this.c = j;
+            this.d = k;
+            this.e = f;
+        }
+
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            int i = 5 + random.nextInt(15);
+            ItemStack itemstack = EnchantmentManager.a(random, new ItemStack(this.a.getItem()), i, false);
+            int j = Math.min(this.b + i, 64);
+            ItemStack itemstack1 = new ItemStack(Items.EMERALD, j);
+
+            return new MerchantRecipe(itemstack1, itemstack, this.c, this.d, this.e);
+        }
+    }
+
+    static class i implements VillagerTrades.IMerchantRecipeOption {
+
+        final MobEffectList a;
+        final int b;
+        final int c;
+        private final float d;
+
+        public i(MobEffectList mobeffectlist, int i, int j) {
+            this.a = mobeffectlist;
+            this.b = i;
+            this.c = j;
+            this.d = 0.05F;
+        }
+
+        @Nullable
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            ItemStack itemstack = new ItemStack(Items.SUSPICIOUS_STEW, 1);
+
+            ItemSuspiciousStew.a(itemstack, this.a, this.b);
+            return new MerchantRecipe(new ItemStack(Items.EMERALD, 1), itemstack, 12, this.c, this.d);
+        }
+    }
+
+    static class h implements VillagerTrades.IMerchantRecipeOption {
+
+        private final ItemStack a;
+        private final int b;
+        private final int c;
+        private final int d;
+        private final int e;
+        private final float f;
+
+        public h(Block block, int i, int j, int k, int l) {
+            this(new ItemStack(block), i, j, k, l);
+        }
+
+        public h(Item item, int i, int j, int k) {
+            this(new ItemStack(item), i, j, 12, k);
+        }
+
+        public h(Item item, int i, int j, int k, int l) {
+            this(new ItemStack(item), i, j, k, l);
+        }
+
+        public h(ItemStack itemstack, int i, int j, int k, int l) {
+            this(itemstack, i, j, k, l, 0.05F);
+        }
+
+        public h(ItemStack itemstack, int i, int j, int k, int l, float f) {
+            this.a = itemstack;
+            this.b = i;
+            this.c = j;
+            this.d = k;
+            this.e = l;
+            this.f = f;
+        }
+
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            return new MerchantRecipe(new ItemStack(Items.EMERALD, this.b), new ItemStack(this.a.getItem(), this.c), this.d, this.e, this.f);
+        }
+    }
+
+    static class c implements VillagerTrades.IMerchantRecipeOption {
+
+        private final Map<VillagerType, Item> a;
+        private final int b;
+        private final int c;
+        private final int d;
+
+        public c(int i, int j, int k, Map<VillagerType, Item> map) {
+            IRegistry.VILLAGER_TYPE.g().filter((villagertype) -> {
+                return !map.containsKey(villagertype);
+            }).findAny().ifPresent((villagertype) -> {
+                throw new IllegalStateException("Missing trade for villager type: " + IRegistry.VILLAGER_TYPE.getKey(villagertype));
+            });
+            this.a = map;
+            this.b = i;
+            this.c = j;
+            this.d = k;
+        }
+
+        @Nullable
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            if (entity instanceof VillagerDataHolder) {
+                ItemStack itemstack = new ItemStack((IMaterial) this.a.get(((VillagerDataHolder) entity).getVillagerData().getType()), this.b);
+
+                return new MerchantRecipe(itemstack, new ItemStack(Items.EMERALD), this.c, this.d, 0.05F);
+            } else {
+                return null;
+            }
+        }
+    }
+
+    static class b implements VillagerTrades.IMerchantRecipeOption {
+
+        private final Item a;
+        private final int b;
+        private final int c;
+        private final int d;
+        private final float e;
+
+        public b(IMaterial imaterial, int i, int j, int k) {
+            this.a = imaterial.getItem();
+            this.b = i;
+            this.c = j;
+            this.d = k;
+            this.e = 0.05F;
+        }
+
+        @Override
+        public MerchantRecipe a(Entity entity, Random random) {
+            ItemStack itemstack = new ItemStack(this.a, this.b);
+
+            return new MerchantRecipe(itemstack, new ItemStack(Items.EMERALD), this.c, this.d, this.e);
+        }
+    }
+
+    public interface IMerchantRecipeOption {
+
+        @Nullable
+        MerchantRecipe a(Entity entity, Random random);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/projectile/EntityDragonFireball.java b/src/main/java/net/minecraft/world/entity/projectile/EntityDragonFireball.java
new file mode 100644
index 0000000000000000000000000000000000000000..59b5484731a5f71005c3efa56cbe40012d9641b5
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/projectile/EntityDragonFireball.java
@@ -0,0 +1,88 @@
+package net.minecraft.world.entity.projectile;
+
+import java.util.Iterator;
+import java.util.List;
+import net.minecraft.core.particles.ParticleParam;
+import net.minecraft.core.particles.Particles;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityAreaEffectCloud;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.level.World;
+import net.minecraft.world.phys.MovingObjectPosition;
+import net.minecraft.world.phys.MovingObjectPositionEntity;
+
+public class EntityDragonFireball extends EntityFireball {
+
+    public EntityDragonFireball(EntityTypes<? extends EntityDragonFireball> entitytypes, World world) {
+        super(entitytypes, world);
+    }
+
+    public EntityDragonFireball(World world, EntityLiving entityliving, double d0, double d1, double d2) {
+        super(EntityTypes.DRAGON_FIREBALL, entityliving, d0, d1, d2, world);
+    }
+
+    @Override
+    protected void a(MovingObjectPosition movingobjectposition) {
+        super.a(movingobjectposition);
+        Entity entity = this.getShooter();
+
+        if (movingobjectposition.getType() != MovingObjectPosition.EnumMovingObjectType.ENTITY || !((MovingObjectPositionEntity) movingobjectposition).getEntity().s(entity)) {
+            if (!this.world.isClientSide) {
+                List<EntityLiving> list = this.world.a(EntityLiving.class, this.getBoundingBox().grow(4.0D, 2.0D, 4.0D));
+                EntityAreaEffectCloud entityareaeffectcloud = new EntityAreaEffectCloud(this.world, this.locX(), this.locY(), this.locZ());
+
+                if (entity instanceof EntityLiving) {
+                    entityareaeffectcloud.setSource((EntityLiving) entity);
+                }
+
+                entityareaeffectcloud.setParticle(Particles.DRAGON_BREATH);
+                entityareaeffectcloud.setRadius(3.0F);
+                entityareaeffectcloud.setDuration(600);
+                entityareaeffectcloud.setRadiusPerTick((7.0F - entityareaeffectcloud.getRadius()) / (float) entityareaeffectcloud.getDuration());
+                entityareaeffectcloud.addEffect(new MobEffect(MobEffects.HARM, 1, 1));
+                if (!list.isEmpty()) {
+                    Iterator iterator = list.iterator();
+
+                    while (iterator.hasNext()) {
+                        EntityLiving entityliving = (EntityLiving) iterator.next();
+                        double d0 = this.h(entityliving);
+
+                        if (d0 < 16.0D) {
+                            entityareaeffectcloud.setPosition(entityliving.locX(), entityliving.locY(), entityliving.locZ());
+                            break;
+                        }
+                    }
+                }
+
+                this.world.triggerEffect(2006, this.getChunkCoordinates(), this.isSilent() ? -1 : 1);
+                this.world.addEntity(entityareaeffectcloud);
+                this.die();
+            }
+
+        }
+    }
+
+    @Override
+    public boolean isInteractable() {
+        return false;
+    }
+
+    @Override
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        return false;
+    }
+
+    @Override
+    protected ParticleParam h() {
+        return Particles.DRAGON_BREATH;
+    }
+
+    @Override
+    protected boolean W_() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/projectile/EntityProjectile.java b/src/main/java/net/minecraft/world/entity/projectile/EntityProjectile.java
new file mode 100644
index 0000000000000000000000000000000000000000..829b4f28896bcb0eb6e48242bd00585eeaae62c2
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/projectile/EntityProjectile.java
@@ -0,0 +1,102 @@
+package net.minecraft.world.entity.projectile;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.particles.Particles;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.PacketPlayOutSpawnEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.entity.TileEntityEndGateway;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.phys.MovingObjectPosition;
+import net.minecraft.world.phys.MovingObjectPositionBlock;
+import net.minecraft.world.phys.Vec3D;
+
+public abstract class EntityProjectile extends IProjectile {
+
+    protected EntityProjectile(EntityTypes<? extends EntityProjectile> entitytypes, World world) {
+        super(entitytypes, world);
+    }
+
+    protected EntityProjectile(EntityTypes<? extends EntityProjectile> entitytypes, double d0, double d1, double d2, World world) {
+        this(entitytypes, world);
+        this.setPosition(d0, d1, d2);
+    }
+
+    protected EntityProjectile(EntityTypes<? extends EntityProjectile> entitytypes, EntityLiving entityliving, World world) {
+        this(entitytypes, entityliving.locX(), entityliving.getHeadY() - 0.10000000149011612D, entityliving.locZ(), world);
+        this.setShooter(entityliving);
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        MovingObjectPosition movingobjectposition = ProjectileHelper.a((Entity) this, this::a);
+        boolean flag = false;
+
+        if (movingobjectposition.getType() == MovingObjectPosition.EnumMovingObjectType.BLOCK) {
+            BlockPosition blockposition = ((MovingObjectPositionBlock) movingobjectposition).getBlockPosition();
+            IBlockData iblockdata = this.world.getType(blockposition);
+
+            if (iblockdata.a(Blocks.NETHER_PORTAL)) {
+                this.d(blockposition);
+                flag = true;
+            } else if (iblockdata.a(Blocks.END_GATEWAY)) {
+                TileEntity tileentity = this.world.getTileEntity(blockposition);
+
+                if (tileentity instanceof TileEntityEndGateway && TileEntityEndGateway.a((Entity) this)) {
+                    ((TileEntityEndGateway) tileentity).b((Entity) this);
+                }
+
+                flag = true;
+            }
+        }
+
+        if (movingobjectposition.getType() != MovingObjectPosition.EnumMovingObjectType.MISS && !flag) {
+            this.a(movingobjectposition);
+        }
+
+        this.checkBlockCollisions();
+        Vec3D vec3d = this.getMot();
+        double d0 = this.locX() + vec3d.x;
+        double d1 = this.locY() + vec3d.y;
+        double d2 = this.locZ() + vec3d.z;
+
+        this.x();
+        float f;
+
+        if (this.isInWater()) {
+            for (int i = 0; i < 4; ++i) {
+                float f1 = 0.25F;
+
+                this.world.addParticle(Particles.BUBBLE, d0 - vec3d.x * 0.25D, d1 - vec3d.y * 0.25D, d2 - vec3d.z * 0.25D, vec3d.x, vec3d.y, vec3d.z);
+            }
+
+            f = 0.8F;
+        } else {
+            f = 0.99F;
+        }
+
+        this.setMot(vec3d.a((double) f));
+        if (!this.isNoGravity()) {
+            Vec3D vec3d1 = this.getMot();
+
+            this.setMot(vec3d1.x, vec3d1.y - (double) this.k(), vec3d1.z);
+        }
+
+        this.setPosition(d0, d1, d2);
+    }
+
+    protected float k() {
+        return 0.03F;
+    }
+
+    @Override
+    public Packet<?> P() {
+        return new PacketPlayOutSpawnEntity(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/EntityMinecartTNT.java b/src/main/java/net/minecraft/world/entity/vehicle/EntityMinecartTNT.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee31704ffb88ab68702657554d386e8ebfa05d03
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/vehicle/EntityMinecartTNT.java
@@ -0,0 +1,172 @@
+package net.minecraft.world.entity.vehicle;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.particles.Particles;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsBlock;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.EntityArrow;
+import net.minecraft.world.level.Explosion;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.IMaterial;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.material.Fluid;
+
+public class EntityMinecartTNT extends EntityMinecartAbstract {
+
+    private int b = -1;
+
+    public EntityMinecartTNT(EntityTypes<? extends EntityMinecartTNT> entitytypes, World world) {
+        super(entitytypes, world);
+    }
+
+    public EntityMinecartTNT(World world, double d0, double d1, double d2) {
+        super(EntityTypes.TNT_MINECART, world, d0, d1, d2);
+    }
+
+    @Override
+    public EntityMinecartAbstract.EnumMinecartType getMinecartType() {
+        return EntityMinecartAbstract.EnumMinecartType.TNT;
+    }
+
+    @Override
+    public IBlockData q() {
+        return Blocks.TNT.getBlockData();
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        if (this.b > 0) {
+            --this.b;
+            this.world.addParticle(Particles.SMOKE, this.locX(), this.locY() + 0.5D, this.locZ(), 0.0D, 0.0D, 0.0D);
+        } else if (this.b == 0) {
+            this.h(c(this.getMot()));
+        }
+
+        if (this.positionChanged) {
+            double d0 = c(this.getMot());
+
+            if (d0 >= 0.009999999776482582D) {
+                this.h(d0);
+            }
+        }
+
+    }
+
+    @Override
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        Entity entity = damagesource.j();
+
+        if (entity instanceof EntityArrow) {
+            EntityArrow entityarrow = (EntityArrow) entity;
+
+            if (entityarrow.isBurning()) {
+                this.h(entityarrow.getMot().g());
+            }
+        }
+
+        return super.damageEntity(damagesource, f);
+    }
+
+    @Override
+    public void a(DamageSource damagesource) {
+        double d0 = c(this.getMot());
+
+        if (!damagesource.isFire() && !damagesource.isExplosion() && d0 < 0.009999999776482582D) {
+            super.a(damagesource);
+            if (!damagesource.isExplosion() && this.world.getGameRules().getBoolean(GameRules.DO_ENTITY_DROPS)) {
+                this.a((IMaterial) Blocks.TNT);
+            }
+
+        } else {
+            if (this.b < 0) {
+                this.u();
+                this.b = this.random.nextInt(20) + this.random.nextInt(20);
+            }
+
+        }
+    }
+
+    protected void h(double d0) {
+        if (!this.world.isClientSide) {
+            double d1 = Math.sqrt(d0);
+
+            if (d1 > 5.0D) {
+                d1 = 5.0D;
+            }
+
+            this.world.explode(this, this.locX(), this.locY(), this.locZ(), (float) (4.0D + this.random.nextDouble() * 1.5D * d1), Explosion.Effect.BREAK);
+            this.die();
+        }
+
+    }
+
+    @Override
+    public boolean b(float f, float f1) {
+        if (f >= 3.0F) {
+            float f2 = f / 10.0F;
+
+            this.h((double) (f2 * f2));
+        }
+
+        return super.b(f, f1);
+    }
+
+    @Override
+    public void a(int i, int j, int k, boolean flag) {
+        if (flag && this.b < 0) {
+            this.u();
+        }
+
+    }
+
+    public void u() {
+        this.b = 80;
+        if (!this.world.isClientSide) {
+            this.world.broadcastEntityEffect(this, (byte) 10);
+            if (!this.isSilent()) {
+                this.world.playSound((EntityHuman) null, this.locX(), this.locY(), this.locZ(), SoundEffects.ENTITY_TNT_PRIMED, SoundCategory.BLOCKS, 1.0F, 1.0F);
+            }
+        }
+
+    }
+
+    public boolean x() {
+        return this.b > -1;
+    }
+
+    @Override
+    public float a(Explosion explosion, IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata, Fluid fluid, float f) {
+        return this.x() && (iblockdata.a((Tag) TagsBlock.RAILS) || iblockaccess.getType(blockposition.up()).a((Tag) TagsBlock.RAILS)) ? 0.0F : super.a(explosion, iblockaccess, blockposition, iblockdata, fluid, f);
+    }
+
+    @Override
+    public boolean a(Explosion explosion, IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata, float f) {
+        return this.x() && (iblockdata.a((Tag) TagsBlock.RAILS) || iblockaccess.getType(blockposition.up()).a((Tag) TagsBlock.RAILS)) ? false : super.a(explosion, iblockaccess, blockposition, iblockdata, f);
+    }
+
+    @Override
+    protected void loadData(NBTTagCompound nbttagcompound) {
+        super.loadData(nbttagcompound);
+        if (nbttagcompound.hasKeyOfType("TNTFuse", 99)) {
+            this.b = nbttagcompound.getInt("TNTFuse");
+        }
+
+    }
+
+    @Override
+    protected void saveData(NBTTagCompound nbttagcompound) {
+        super.saveData(nbttagcompound);
+        nbttagcompound.setInt("TNTFuse", this.b);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/inventory/ContainerProperty.java b/src/main/java/net/minecraft/world/inventory/ContainerProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..67c3b7ddb0b0f10c82577cbea7506c9d80d41368
--- /dev/null
+++ b/src/main/java/net/minecraft/world/inventory/ContainerProperty.java
@@ -0,0 +1,64 @@
+package net.minecraft.world.inventory;
+
+public abstract class ContainerProperty {
+
+    private int a;
+
+    public ContainerProperty() {}
+
+    public static ContainerProperty a(final IContainerProperties icontainerproperties, final int i) {
+        return new ContainerProperty() {
+            @Override
+            public int get() {
+                return icontainerproperties.getProperty(i);
+            }
+
+            @Override
+            public void set(int j) {
+                icontainerproperties.setProperty(i, j);
+            }
+        };
+    }
+
+    public static ContainerProperty a(final int[] aint, final int i) {
+        return new ContainerProperty() {
+            @Override
+            public int get() {
+                return aint[i];
+            }
+
+            @Override
+            public void set(int j) {
+                aint[i] = j;
+            }
+        };
+    }
+
+    public static ContainerProperty a() {
+        return new ContainerProperty() {
+            private int a;
+
+            @Override
+            public int get() {
+                return this.a;
+            }
+
+            @Override
+            public void set(int i) {
+                this.a = i;
+            }
+        };
+    }
+
+    public abstract int get();
+
+    public abstract void set(int i);
+
+    public boolean c() {
+        int i = this.get();
+        boolean flag = i != this.a;
+
+        this.a = i;
+        return flag;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/Item.java b/src/main/java/net/minecraft/world/item/Item.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca513e7b0a416860aba89e41de6a7c5ff42baa69
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/Item.java
@@ -0,0 +1,372 @@
+package net.minecraft.world.item;
+
+import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
+import java.util.Map;
+import java.util.Random;
+import java.util.UUID;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IRegistry;
+import net.minecraft.core.NonNullList;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.tags.Tag;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.EnumInteractionResult;
+import net.minecraft.world.InteractionResultWrapper;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EnumItemSlot;
+import net.minecraft.world.entity.ai.attributes.AttributeBase;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.food.FoodInfo;
+import net.minecraft.world.item.context.ItemActionContext;
+import net.minecraft.world.level.IMaterial;
+import net.minecraft.world.level.RayTrace;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.phys.MovingObjectPositionBlock;
+import net.minecraft.world.phys.Vec3D;
+
+public class Item implements IMaterial {
+
+    public static final Map<Block, Item> e = Maps.newHashMap();
+    protected static final UUID f = UUID.fromString("CB3F55D3-645C-4F38-A497-9C13A33DB5CF");
+    protected static final UUID g = UUID.fromString("FA233E1C-4180-4865-B01B-BCCE9785ACA3");
+    protected static final Random RANDOM = new Random();
+    protected final CreativeModeTab i;
+    private final EnumItemRarity a;
+    private final int maxStackSize;
+    private final int durability;
+    private final boolean d;
+    private final Item craftingResult;
+    @Nullable
+    private String name;
+    @Nullable
+    private final FoodInfo foodInfo;
+
+    public static int getId(Item item) {
+        return item == null ? 0 : IRegistry.ITEM.a((Object) item);
+    }
+
+    public static Item getById(int i) {
+        return (Item) IRegistry.ITEM.fromId(i);
+    }
+
+    @Deprecated
+    public static Item getItemOf(Block block) {
+        return (Item) Item.e.getOrDefault(block, Items.AIR);
+    }
+
+    public Item(Item.Info item_info) {
+        this.i = item_info.d;
+        this.a = item_info.e;
+        this.craftingResult = item_info.c;
+        this.durability = item_info.b;
+        this.maxStackSize = item_info.a;
+        this.foodInfo = item_info.f;
+        this.d = item_info.g;
+    }
+
+    public void a(World world, EntityLiving entityliving, ItemStack itemstack, int i) {}
+
+    public boolean b(NBTTagCompound nbttagcompound) {
+        return false;
+    }
+
+    public boolean a(IBlockData iblockdata, World world, BlockPosition blockposition, EntityHuman entityhuman) {
+        return true;
+    }
+
+    @Override
+    public Item getItem() {
+        return this;
+    }
+
+    public EnumInteractionResult a(ItemActionContext itemactioncontext) {
+        return EnumInteractionResult.PASS;
+    }
+
+    public float getDestroySpeed(ItemStack itemstack, IBlockData iblockdata) {
+        return 1.0F;
+    }
+
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        if (this.isFood()) {
+            ItemStack itemstack = entityhuman.b(enumhand);
+
+            if (entityhuman.q(this.getFoodInfo().d())) {
+                entityhuman.c(enumhand);
+                return InteractionResultWrapper.consume(itemstack);
+            } else {
+                return InteractionResultWrapper.fail(itemstack);
+            }
+        } else {
+            return InteractionResultWrapper.pass(entityhuman.b(enumhand));
+        }
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityLiving entityliving) {
+        return this.isFood() ? entityliving.a(world, itemstack) : itemstack;
+    }
+
+    public final int getMaxStackSize() {
+        return this.maxStackSize;
+    }
+
+    public final int getMaxDurability() {
+        return this.durability;
+    }
+
+    public boolean usesDurability() {
+        return this.durability > 0;
+    }
+
+    public boolean a(ItemStack itemstack, EntityLiving entityliving, EntityLiving entityliving1) {
+        return false;
+    }
+
+    public boolean a(ItemStack itemstack, World world, IBlockData iblockdata, BlockPosition blockposition, EntityLiving entityliving) {
+        return false;
+    }
+
+    public boolean canDestroySpecialBlock(IBlockData iblockdata) {
+        return false;
+    }
+
+    public EnumInteractionResult a(ItemStack itemstack, EntityHuman entityhuman, EntityLiving entityliving, EnumHand enumhand) {
+        return EnumInteractionResult.PASS;
+    }
+
+    public String toString() {
+        return IRegistry.ITEM.getKey(this).getKey();
+    }
+
+    protected String m() {
+        if (this.name == null) {
+            this.name = SystemUtils.a("item", IRegistry.ITEM.getKey(this));
+        }
+
+        return this.name;
+    }
+
+    public String getName() {
+        return this.m();
+    }
+
+    public String f(ItemStack itemstack) {
+        return this.getName();
+    }
+
+    public boolean n() {
+        return true;
+    }
+
+    @Nullable
+    public final Item getCraftingRemainingItem() {
+        return this.craftingResult;
+    }
+
+    public boolean p() {
+        return this.craftingResult != null;
+    }
+
+    public void a(ItemStack itemstack, World world, Entity entity, int i, boolean flag) {}
+
+    public void b(ItemStack itemstack, World world, EntityHuman entityhuman) {}
+
+    public boolean ac_() {
+        return false;
+    }
+
+    public EnumAnimation d_(ItemStack itemstack) {
+        return itemstack.getItem().isFood() ? EnumAnimation.EAT : EnumAnimation.NONE;
+    }
+
+    public int e_(ItemStack itemstack) {
+        return itemstack.getItem().isFood() ? (this.getFoodInfo().e() ? 16 : 32) : 0;
+    }
+
+    public void a(ItemStack itemstack, World world, EntityLiving entityliving, int i) {}
+
+    public IChatBaseComponent h(ItemStack itemstack) {
+        return new ChatMessage(this.f(itemstack));
+    }
+
+    public boolean e(ItemStack itemstack) {
+        return itemstack.hasEnchantments();
+    }
+
+    public EnumItemRarity i(ItemStack itemstack) {
+        if (!itemstack.hasEnchantments()) {
+            return this.a;
+        } else {
+            switch (this.a) {
+                case COMMON:
+                case UNCOMMON:
+                    return EnumItemRarity.RARE;
+                case RARE:
+                    return EnumItemRarity.EPIC;
+                case EPIC:
+                default:
+                    return this.a;
+            }
+        }
+    }
+
+    public boolean f_(ItemStack itemstack) {
+        return this.getMaxStackSize() == 1 && this.usesDurability();
+    }
+
+    protected static MovingObjectPositionBlock a(World world, EntityHuman entityhuman, RayTrace.FluidCollisionOption raytrace_fluidcollisionoption) {
+        float f = entityhuman.pitch;
+        float f1 = entityhuman.yaw;
+        Vec3D vec3d = entityhuman.j(1.0F);
+        float f2 = MathHelper.cos(-f1 * 0.017453292F - 3.1415927F);
+        float f3 = MathHelper.sin(-f1 * 0.017453292F - 3.1415927F);
+        float f4 = -MathHelper.cos(-f * 0.017453292F);
+        float f5 = MathHelper.sin(-f * 0.017453292F);
+        float f6 = f3 * f4;
+        float f7 = f2 * f4;
+        double d0 = 5.0D;
+        Vec3D vec3d1 = vec3d.add((double) f6 * 5.0D, (double) f5 * 5.0D, (double) f7 * 5.0D);
+
+        return world.rayTrace(new RayTrace(vec3d, vec3d1, RayTrace.BlockCollisionOption.OUTLINE, raytrace_fluidcollisionoption, entityhuman));
+    }
+
+    public int c() {
+        return 0;
+    }
+
+    public void a(CreativeModeTab creativemodetab, NonNullList<ItemStack> nonnulllist) {
+        if (this.a(creativemodetab)) {
+            nonnulllist.add(new ItemStack(this));
+        }
+
+    }
+
+    protected boolean a(CreativeModeTab creativemodetab) {
+        CreativeModeTab creativemodetab1 = this.q();
+
+        return creativemodetab1 != null && (creativemodetab == CreativeModeTab.g || creativemodetab == creativemodetab1);
+    }
+
+    @Nullable
+    public final CreativeModeTab q() {
+        return this.i;
+    }
+
+    public boolean a(ItemStack itemstack, ItemStack itemstack1) {
+        return false;
+    }
+
+    public Multimap<AttributeBase, AttributeModifier> a(EnumItemSlot enumitemslot) {
+        return ImmutableMultimap.of();
+    }
+
+    public boolean j(ItemStack itemstack) {
+        return itemstack.getItem() == Items.CROSSBOW;
+    }
+
+    public ItemStack createItemStack() {
+        return new ItemStack(this);
+    }
+
+    public boolean a(Tag<Item> tag) {
+        return tag.isTagged(this);
+    }
+
+    public boolean isFood() {
+        return this.foodInfo != null;
+    }
+
+    @Nullable
+    public FoodInfo getFoodInfo() {
+        return this.foodInfo;
+    }
+
+    public SoundEffect ae_() {
+        return SoundEffects.ENTITY_GENERIC_DRINK;
+    }
+
+    public SoundEffect ad_() {
+        return SoundEffects.ENTITY_GENERIC_EAT;
+    }
+
+    public boolean u() {
+        return this.d;
+    }
+
+    public boolean a(DamageSource damagesource) {
+        return !this.d || !damagesource.isFire();
+    }
+
+    public static class Info {
+
+        private int a = 64;
+        private int b;
+        private Item c;
+        private CreativeModeTab d;
+        private EnumItemRarity e;
+        private FoodInfo f;
+        private boolean g;
+
+        public Info() {
+            this.e = EnumItemRarity.COMMON;
+        }
+
+        public Item.Info a(FoodInfo foodinfo) {
+            this.f = foodinfo;
+            return this;
+        }
+
+        public Item.Info a(int i) {
+            if (this.b > 0) {
+                throw new RuntimeException("Unable to have damage AND stack.");
+            } else {
+                this.a = i;
+                return this;
+            }
+        }
+
+        public Item.Info b(int i) {
+            return this.b == 0 ? this.c(i) : this;
+        }
+
+        public Item.Info c(int i) {
+            this.b = i;
+            this.a = 1;
+            return this;
+        }
+
+        public Item.Info a(Item item) {
+            this.c = item;
+            return this;
+        }
+
+        public Item.Info a(CreativeModeTab creativemodetab) {
+            this.d = creativemodetab;
+            return this;
+        }
+
+        public Item.Info a(EnumItemRarity enumitemrarity) {
+            this.e = enumitemrarity;
+            return this;
+        }
+
+        public Item.Info a() {
+            this.g = true;
+            return this;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/ItemCooldownPlayer.java b/src/main/java/net/minecraft/world/item/ItemCooldownPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f70e39f4da2880a6f734a225be83061b00847c8
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/ItemCooldownPlayer.java
@@ -0,0 +1,25 @@
+package net.minecraft.world.item;
+
+import net.minecraft.network.protocol.game.PacketPlayOutSetCooldown;
+import net.minecraft.server.level.EntityPlayer;
+
+public class ItemCooldownPlayer extends ItemCooldown {
+
+    private final EntityPlayer a;
+
+    public ItemCooldownPlayer(EntityPlayer entityplayer) {
+        this.a = entityplayer;
+    }
+
+    @Override
+    protected void b(Item item, int i) {
+        super.b(item, i);
+        this.a.playerConnection.sendPacket(new PacketPlayOutSetCooldown(item, i));
+    }
+
+    @Override
+    protected void c(Item item) {
+        super.c(item);
+        this.a.playerConnection.sendPacket(new PacketPlayOutSetCooldown(item, 0));
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/ItemExpBottle.java b/src/main/java/net/minecraft/world/item/ItemExpBottle.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f41fe5bf1a0cc283d6a72824779026fdad75708
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/ItemExpBottle.java
@@ -0,0 +1,43 @@
+package net.minecraft.world.item;
+
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.stats.StatisticList;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.InteractionResultWrapper;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.EntityThrownExpBottle;
+import net.minecraft.world.level.World;
+
+public class ItemExpBottle extends Item {
+
+    public ItemExpBottle(Item.Info item_info) {
+        super(item_info);
+    }
+
+    @Override
+    public boolean e(ItemStack itemstack) {
+        return true;
+    }
+
+    @Override
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+
+        world.playSound((EntityHuman) null, entityhuman.locX(), entityhuman.locY(), entityhuman.locZ(), SoundEffects.ENTITY_EXPERIENCE_BOTTLE_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (ItemExpBottle.RANDOM.nextFloat() * 0.4F + 0.8F));
+        if (!world.isClientSide) {
+            EntityThrownExpBottle entitythrownexpbottle = new EntityThrownExpBottle(world, entityhuman);
+
+            entitythrownexpbottle.setItem(itemstack);
+            entitythrownexpbottle.a(entityhuman, entityhuman.pitch, entityhuman.yaw, -20.0F, 0.7F, 1.0F);
+            world.addEntity(entitythrownexpbottle);
+        }
+
+        entityhuman.b(StatisticList.ITEM_USED.b(this));
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            itemstack.subtract(1);
+        }
+
+        return InteractionResultWrapper.a(itemstack, world.s_());
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/ItemFireworks.java b/src/main/java/net/minecraft/world/item/ItemFireworks.java
new file mode 100644
index 0000000000000000000000000000000000000000..9153945c2e245b9a2a098bdf58b0dcab052084ff
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/ItemFireworks.java
@@ -0,0 +1,77 @@
+package net.minecraft.world.item;
+
+import java.util.Arrays;
+import java.util.Comparator;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.EnumInteractionResult;
+import net.minecraft.world.InteractionResultWrapper;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.EntityFireworks;
+import net.minecraft.world.item.context.ItemActionContext;
+import net.minecraft.world.level.World;
+import net.minecraft.world.phys.Vec3D;
+
+public class ItemFireworks extends Item {
+
+    public ItemFireworks(Item.Info item_info) {
+        super(item_info);
+    }
+
+    @Override
+    public EnumInteractionResult a(ItemActionContext itemactioncontext) {
+        World world = itemactioncontext.getWorld();
+
+        if (!world.isClientSide) {
+            ItemStack itemstack = itemactioncontext.getItemStack();
+            Vec3D vec3d = itemactioncontext.getPos();
+            EnumDirection enumdirection = itemactioncontext.getClickedFace();
+            EntityFireworks entityfireworks = new EntityFireworks(world, itemactioncontext.getEntity(), vec3d.x + (double) enumdirection.getAdjacentX() * 0.15D, vec3d.y + (double) enumdirection.getAdjacentY() * 0.15D, vec3d.z + (double) enumdirection.getAdjacentZ() * 0.15D, itemstack);
+
+            world.addEntity(entityfireworks);
+            itemstack.subtract(1);
+        }
+
+        return EnumInteractionResult.a(world.isClientSide);
+    }
+
+    @Override
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        if (entityhuman.isGliding()) {
+            ItemStack itemstack = entityhuman.b(enumhand);
+
+            if (!world.isClientSide) {
+                world.addEntity(new EntityFireworks(world, itemstack, entityhuman));
+                if (!entityhuman.abilities.canInstantlyBuild) {
+                    itemstack.subtract(1);
+                }
+            }
+
+            return InteractionResultWrapper.a(entityhuman.b(enumhand), world.s_());
+        } else {
+            return InteractionResultWrapper.pass(entityhuman.b(enumhand));
+        }
+    }
+
+    public static enum EffectType {
+
+        SMALL_BALL(0, "small_ball"), LARGE_BALL(1, "large_ball"), STAR(2, "star"), CREEPER(3, "creeper"), BURST(4, "burst");
+
+        private static final ItemFireworks.EffectType[] f = (ItemFireworks.EffectType[]) Arrays.stream(values()).sorted(Comparator.comparingInt((itemfireworks_effecttype) -> {
+            return itemfireworks_effecttype.g;
+        })).toArray((i) -> {
+            return new ItemFireworks.EffectType[i];
+        });
+        private final int g;
+        private final String h;
+
+        private EffectType(int i, String s) {
+            this.g = i;
+            this.h = s;
+        }
+
+        public int a() {
+            return this.g;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/ItemLingeringPotion.java b/src/main/java/net/minecraft/world/item/ItemLingeringPotion.java
new file mode 100644
index 0000000000000000000000000000000000000000..a75f374f0639e8143772aa863666afe25d2020cf
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/ItemLingeringPotion.java
@@ -0,0 +1,21 @@
+package net.minecraft.world.item;
+
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.InteractionResultWrapper;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.level.World;
+
+public class ItemLingeringPotion extends ItemPotionThrowable {
+
+    public ItemLingeringPotion(Item.Info item_info) {
+        super(item_info);
+    }
+
+    @Override
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        world.playSound((EntityHuman) null, entityhuman.locX(), entityhuman.locY(), entityhuman.locZ(), SoundEffects.ENTITY_LINGERING_POTION_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (ItemLingeringPotion.RANDOM.nextFloat() * 0.4F + 0.8F));
+        return super.a(world, entityhuman, enumhand);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/ItemNameTag.java b/src/main/java/net/minecraft/world/item/ItemNameTag.java
new file mode 100644
index 0000000000000000000000000000000000000000..140a865f4f8fb3e4f787cf8d334d20fac6cb5eef
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/ItemNameTag.java
@@ -0,0 +1,32 @@
+package net.minecraft.world.item;
+
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.EnumInteractionResult;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.player.EntityHuman;
+
+public class ItemNameTag extends Item {
+
+    public ItemNameTag(Item.Info item_info) {
+        super(item_info);
+    }
+
+    @Override
+    public EnumInteractionResult a(ItemStack itemstack, EntityHuman entityhuman, EntityLiving entityliving, EnumHand enumhand) {
+        if (itemstack.hasName() && !(entityliving instanceof EntityHuman)) {
+            if (!entityhuman.world.isClientSide && entityliving.isAlive()) {
+                entityliving.setCustomName(itemstack.getName());
+                if (entityliving instanceof EntityInsentient) {
+                    ((EntityInsentient) entityliving).setPersistent();
+                }
+
+                itemstack.subtract(1);
+            }
+
+            return EnumInteractionResult.a(entityhuman.world.isClientSide);
+        } else {
+            return EnumInteractionResult.PASS;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/ItemPotionThrowable.java b/src/main/java/net/minecraft/world/item/ItemPotionThrowable.java
new file mode 100644
index 0000000000000000000000000000000000000000..d050243946ad7023d5dd3958d7056cddcaf185a4
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/ItemPotionThrowable.java
@@ -0,0 +1,35 @@
+package net.minecraft.world.item;
+
+import net.minecraft.stats.StatisticList;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.InteractionResultWrapper;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.EntityPotion;
+import net.minecraft.world.level.World;
+
+public class ItemPotionThrowable extends ItemPotion {
+
+    public ItemPotionThrowable(Item.Info item_info) {
+        super(item_info);
+    }
+
+    @Override
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+
+        if (!world.isClientSide) {
+            EntityPotion entitypotion = new EntityPotion(world, entityhuman);
+
+            entitypotion.setItem(itemstack);
+            entitypotion.a(entityhuman, entityhuman.pitch, entityhuman.yaw, -20.0F, 0.5F, 1.0F);
+            world.addEntity(entitypotion);
+        }
+
+        entityhuman.b(StatisticList.ITEM_USED.b(this));
+        if (!entityhuman.abilities.canInstantlyBuild) {
+            itemstack.subtract(1);
+        }
+
+        return InteractionResultWrapper.a(itemstack, world.s_());
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/ItemSplashPotion.java b/src/main/java/net/minecraft/world/item/ItemSplashPotion.java
new file mode 100644
index 0000000000000000000000000000000000000000..98f29fac4bf087ad15f1cc7e85b408e22ec07efd
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/ItemSplashPotion.java
@@ -0,0 +1,21 @@
+package net.minecraft.world.item;
+
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.InteractionResultWrapper;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.level.World;
+
+public class ItemSplashPotion extends ItemPotionThrowable {
+
+    public ItemSplashPotion(Item.Info item_info) {
+        super(item_info);
+    }
+
+    @Override
+    public InteractionResultWrapper<ItemStack> a(World world, EntityHuman entityhuman, EnumHand enumhand) {
+        world.playSound((EntityHuman) null, entityhuman.locX(), entityhuman.locY(), entityhuman.locZ(), SoundEffects.ENTITY_SPLASH_POTION_THROW, SoundCategory.PLAYERS, 0.5F, 0.4F / (ItemSplashPotion.RANDOM.nextFloat() * 0.4F + 0.8F));
+        return super.a(world, entityhuman, enumhand);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/alchemy/PotionUtil.java b/src/main/java/net/minecraft/world/item/alchemy/PotionUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..daad63e731008eddccd3f51418a2a9b2d587f77b
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/alchemy/PotionUtil.java
@@ -0,0 +1,154 @@
+package net.minecraft.world.item.alchemy;
+
+import com.google.common.collect.Lists;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.EnumChatFormat;
+import net.minecraft.core.IRegistry;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.network.chat.IChatMutableComponent;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.item.ItemStack;
+
+public class PotionUtil {
+
+    private static final IChatMutableComponent a = (new ChatMessage("effect.none")).a(EnumChatFormat.GRAY);
+
+    public static List<MobEffect> getEffects(ItemStack itemstack) {
+        return a(itemstack.getTag());
+    }
+
+    public static List<MobEffect> a(PotionRegistry potionregistry, Collection<MobEffect> collection) {
+        List<MobEffect> list = Lists.newArrayList();
+
+        list.addAll(potionregistry.a());
+        list.addAll(collection);
+        return list;
+    }
+
+    public static List<MobEffect> a(@Nullable NBTTagCompound nbttagcompound) {
+        List<MobEffect> list = Lists.newArrayList();
+
+        list.addAll(c(nbttagcompound).a());
+        a(nbttagcompound, (List) list);
+        return list;
+    }
+
+    public static List<MobEffect> b(ItemStack itemstack) {
+        return b(itemstack.getTag());
+    }
+
+    public static List<MobEffect> b(@Nullable NBTTagCompound nbttagcompound) {
+        List<MobEffect> list = Lists.newArrayList();
+
+        a(nbttagcompound, (List) list);
+        return list;
+    }
+
+    public static void a(@Nullable NBTTagCompound nbttagcompound, List<MobEffect> list) {
+        if (nbttagcompound != null && nbttagcompound.hasKeyOfType("CustomPotionEffects", 9)) {
+            NBTTagList nbttaglist = nbttagcompound.getList("CustomPotionEffects", 10);
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                NBTTagCompound nbttagcompound1 = nbttaglist.getCompound(i);
+                MobEffect mobeffect = MobEffect.b(nbttagcompound1);
+
+                if (mobeffect != null) {
+                    list.add(mobeffect);
+                }
+            }
+        }
+
+    }
+
+    public static int c(ItemStack itemstack) {
+        NBTTagCompound nbttagcompound = itemstack.getTag();
+
+        return nbttagcompound != null && nbttagcompound.hasKeyOfType("CustomPotionColor", 99) ? nbttagcompound.getInt("CustomPotionColor") : (d(itemstack) == Potions.EMPTY ? 16253176 : a((Collection) getEffects(itemstack)));
+    }
+
+    public static int a(PotionRegistry potionregistry) {
+        return potionregistry == Potions.EMPTY ? 16253176 : a((Collection) potionregistry.a());
+    }
+
+    public static int a(Collection<MobEffect> collection) {
+        int i = 3694022;
+
+        if (collection.isEmpty()) {
+            return 3694022;
+        } else {
+            float f = 0.0F;
+            float f1 = 0.0F;
+            float f2 = 0.0F;
+            int j = 0;
+            Iterator iterator = collection.iterator();
+
+            while (iterator.hasNext()) {
+                MobEffect mobeffect = (MobEffect) iterator.next();
+
+                if (mobeffect.isShowParticles()) {
+                    int k = mobeffect.getMobEffect().getColor();
+                    int l = mobeffect.getAmplifier() + 1;
+
+                    f += (float) (l * (k >> 16 & 255)) / 255.0F;
+                    f1 += (float) (l * (k >> 8 & 255)) / 255.0F;
+                    f2 += (float) (l * (k >> 0 & 255)) / 255.0F;
+                    j += l;
+                }
+            }
+
+            if (j == 0) {
+                return 0;
+            } else {
+                f = f / (float) j * 255.0F;
+                f1 = f1 / (float) j * 255.0F;
+                f2 = f2 / (float) j * 255.0F;
+                return (int) f << 16 | (int) f1 << 8 | (int) f2;
+            }
+        }
+    }
+
+    public static PotionRegistry d(ItemStack itemstack) {
+        return c(itemstack.getTag());
+    }
+
+    public static PotionRegistry c(@Nullable NBTTagCompound nbttagcompound) {
+        return nbttagcompound == null ? Potions.EMPTY : PotionRegistry.a(nbttagcompound.getString("Potion"));
+    }
+
+    public static ItemStack a(ItemStack itemstack, PotionRegistry potionregistry) {
+        MinecraftKey minecraftkey = IRegistry.POTION.getKey(potionregistry);
+
+        if (potionregistry == Potions.EMPTY) {
+            itemstack.removeTag("Potion");
+        } else {
+            itemstack.getOrCreateTag().setString("Potion", minecraftkey.toString());
+        }
+
+        return itemstack;
+    }
+
+    public static ItemStack a(ItemStack itemstack, Collection<MobEffect> collection) {
+        if (collection.isEmpty()) {
+            return itemstack;
+        } else {
+            NBTTagCompound nbttagcompound = itemstack.getOrCreateTag();
+            NBTTagList nbttaglist = nbttagcompound.getList("CustomPotionEffects", 9);
+            Iterator iterator = collection.iterator();
+
+            while (iterator.hasNext()) {
+                MobEffect mobeffect = (MobEffect) iterator.next();
+
+                nbttaglist.add(mobeffect.a(new NBTTagCompound()));
+            }
+
+            nbttagcompound.set("CustomPotionEffects", nbttaglist);
+            return itemstack;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java b/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..0134bbda9e6fc900b7eefa05442e25539bab3431
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java
@@ -0,0 +1,151 @@
+package net.minecraft.world.item.enchantment;
+
+import com.google.common.collect.Maps;
+import java.util.Map;
+import javax.annotation.Nullable;
+import net.minecraft.EnumChatFormat;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.IRegistry;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EnumItemSlot;
+import net.minecraft.world.entity.EnumMonsterType;
+import net.minecraft.world.item.ItemStack;
+
+public abstract class Enchantment {
+
+    private final EnumItemSlot[] a;
+    private final Enchantment.Rarity d;
+    public final EnchantmentSlotType itemTarget;
+    @Nullable
+    protected String c;
+
+    protected Enchantment(Enchantment.Rarity enchantment_rarity, EnchantmentSlotType enchantmentslottype, EnumItemSlot[] aenumitemslot) {
+        this.d = enchantment_rarity;
+        this.itemTarget = enchantmentslottype;
+        this.a = aenumitemslot;
+    }
+
+    public Map<EnumItemSlot, ItemStack> a(EntityLiving entityliving) {
+        Map<EnumItemSlot, ItemStack> map = Maps.newEnumMap(EnumItemSlot.class);
+        EnumItemSlot[] aenumitemslot = this.a;
+        int i = aenumitemslot.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumItemSlot enumitemslot = aenumitemslot[j];
+            ItemStack itemstack = entityliving.getEquipment(enumitemslot);
+
+            if (!itemstack.isEmpty()) {
+                map.put(enumitemslot, itemstack);
+            }
+        }
+
+        return map;
+    }
+
+    public Enchantment.Rarity d() {
+        return this.d;
+    }
+
+    public int getStartLevel() {
+        return 1;
+    }
+
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    public int a(int i) {
+        return 1 + i * 10;
+    }
+
+    public int b(int i) {
+        return this.a(i) + 5;
+    }
+
+    public int a(int i, DamageSource damagesource) {
+        return 0;
+    }
+
+    public float a(int i, EnumMonsterType enummonstertype) {
+        return 0.0F;
+    }
+
+    public final boolean isCompatible(Enchantment enchantment) {
+        return this.a(enchantment) && enchantment.a(this);
+    }
+
+    protected boolean a(Enchantment enchantment) {
+        return this != enchantment;
+    }
+
+    protected String f() {
+        if (this.c == null) {
+            this.c = SystemUtils.a("enchantment", IRegistry.ENCHANTMENT.getKey(this));
+        }
+
+        return this.c;
+    }
+
+    public String g() {
+        return this.f();
+    }
+
+    public IChatBaseComponent d(int i) {
+        ChatMessage chatmessage = new ChatMessage(this.g());
+
+        if (this.c()) {
+            chatmessage.a(EnumChatFormat.RED);
+        } else {
+            chatmessage.a(EnumChatFormat.GRAY);
+        }
+
+        if (i != 1 || this.getMaxLevel() != 1) {
+            chatmessage.c(" ").addSibling(new ChatMessage("enchantment.level." + i));
+        }
+
+        return chatmessage;
+    }
+
+    public boolean canEnchant(ItemStack itemstack) {
+        return this.itemTarget.canEnchant(itemstack.getItem());
+    }
+
+    public void a(EntityLiving entityliving, Entity entity, int i) {}
+
+    public void b(EntityLiving entityliving, Entity entity, int i) {}
+
+    public boolean isTreasure() {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean h() {
+        return true;
+    }
+
+    public boolean i() {
+        return true;
+    }
+
+    public static enum Rarity {
+
+        COMMON(10), UNCOMMON(5), RARE(2), VERY_RARE(1);
+
+        private final int e;
+
+        private Rarity(int i) {
+            this.e = i;
+        }
+
+        public int a() {
+            return this.e;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentManager.java b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..d313b02f41e4f4a90676cbb37afce4e92dd4d664
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentManager.java
@@ -0,0 +1,428 @@
+package net.minecraft.world.item.enchantment;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Random;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.IRegistry;
+import net.minecraft.nbt.NBTBase;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.util.MathHelper;
+import net.minecraft.util.WeightedRandom;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.EnumItemSlot;
+import net.minecraft.world.entity.EnumMonsterType;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemEnchantedBook;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import org.apache.commons.lang3.mutable.MutableFloat;
+import org.apache.commons.lang3.mutable.MutableInt;
+
+public class EnchantmentManager {
+
+    public static int getEnchantmentLevel(Enchantment enchantment, ItemStack itemstack) {
+        if (itemstack.isEmpty()) {
+            return 0;
+        } else {
+            MinecraftKey minecraftkey = IRegistry.ENCHANTMENT.getKey(enchantment);
+            NBTTagList nbttaglist = itemstack.getEnchantments();
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                NBTTagCompound nbttagcompound = nbttaglist.getCompound(i);
+                MinecraftKey minecraftkey1 = MinecraftKey.a(nbttagcompound.getString("id"));
+
+                if (minecraftkey1 != null && minecraftkey1.equals(minecraftkey)) {
+                    return MathHelper.clamp(nbttagcompound.getInt("lvl"), 0, 255);
+                }
+            }
+
+            return 0;
+        }
+    }
+
+    public static Map<Enchantment, Integer> a(ItemStack itemstack) {
+        NBTTagList nbttaglist = itemstack.getItem() == Items.ENCHANTED_BOOK ? ItemEnchantedBook.d(itemstack) : itemstack.getEnchantments();
+
+        return a(nbttaglist);
+    }
+
+    public static Map<Enchantment, Integer> a(NBTTagList nbttaglist) {
+        Map<Enchantment, Integer> map = Maps.newLinkedHashMap();
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound = nbttaglist.getCompound(i);
+
+            IRegistry.ENCHANTMENT.getOptional(MinecraftKey.a(nbttagcompound.getString("id"))).ifPresent((enchantment) -> {
+                Integer integer = (Integer) map.put(enchantment, nbttagcompound.getInt("lvl"));
+            });
+        }
+
+        return map;
+    }
+
+    public static void a(Map<Enchantment, Integer> map, ItemStack itemstack) {
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry<Enchantment, Integer> entry = (Entry) iterator.next();
+            Enchantment enchantment = (Enchantment) entry.getKey();
+
+            if (enchantment != null) {
+                int i = (Integer) entry.getValue();
+                NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+                nbttagcompound.setString("id", String.valueOf(IRegistry.ENCHANTMENT.getKey(enchantment)));
+                nbttagcompound.setShort("lvl", (short) i);
+                nbttaglist.add(nbttagcompound);
+                if (itemstack.getItem() == Items.ENCHANTED_BOOK) {
+                    ItemEnchantedBook.a(itemstack, new WeightedRandomEnchant(enchantment, i));
+                }
+            }
+        }
+
+        if (nbttaglist.isEmpty()) {
+            itemstack.removeTag("Enchantments");
+        } else if (itemstack.getItem() != Items.ENCHANTED_BOOK) {
+            itemstack.a("Enchantments", (NBTBase) nbttaglist);
+        }
+
+    }
+
+    private static void a(EnchantmentManager.a enchantmentmanager_a, ItemStack itemstack) {
+        if (!itemstack.isEmpty()) {
+            NBTTagList nbttaglist = itemstack.getEnchantments();
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                String s = nbttaglist.getCompound(i).getString("id");
+                int j = nbttaglist.getCompound(i).getInt("lvl");
+
+                IRegistry.ENCHANTMENT.getOptional(MinecraftKey.a(s)).ifPresent((enchantment) -> {
+                    enchantmentmanager_a.accept(enchantment, j);
+                });
+            }
+
+        }
+    }
+
+    private static void a(EnchantmentManager.a enchantmentmanager_a, Iterable<ItemStack> iterable) {
+        Iterator iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            ItemStack itemstack = (ItemStack) iterator.next();
+
+            a(enchantmentmanager_a, itemstack);
+        }
+
+    }
+
+    public static int a(Iterable<ItemStack> iterable, DamageSource damagesource) {
+        MutableInt mutableint = new MutableInt();
+
+        a((enchantment, i) -> {
+            mutableint.add(enchantment.a(i, damagesource));
+        }, iterable);
+        return mutableint.intValue();
+    }
+
+    public static float a(ItemStack itemstack, EnumMonsterType enummonstertype) {
+        MutableFloat mutablefloat = new MutableFloat();
+
+        a((enchantment, i) -> {
+            mutablefloat.add(enchantment.a(i, enummonstertype));
+        }, itemstack);
+        return mutablefloat.floatValue();
+    }
+
+    public static float a(EntityLiving entityliving) {
+        int i = a(Enchantments.SWEEPING, entityliving);
+
+        return i > 0 ? EnchantmentSweeping.e(i) : 0.0F;
+    }
+
+    public static void a(EntityLiving entityliving, Entity entity) {
+        EnchantmentManager.a enchantmentmanager_a = (enchantment, i) -> {
+            enchantment.b(entityliving, entity, i);
+        };
+
+        if (entityliving != null) {
+            a(enchantmentmanager_a, entityliving.bp());
+        }
+
+        if (entity instanceof EntityHuman) {
+            a(enchantmentmanager_a, entityliving.getItemInMainHand());
+        }
+
+    }
+
+    public static void b(EntityLiving entityliving, Entity entity) {
+        EnchantmentManager.a enchantmentmanager_a = (enchantment, i) -> {
+            enchantment.a(entityliving, entity, i);
+        };
+
+        if (entityliving != null) {
+            a(enchantmentmanager_a, entityliving.bp());
+        }
+
+        if (entityliving instanceof EntityHuman) {
+            a(enchantmentmanager_a, entityliving.getItemInMainHand());
+        }
+
+    }
+
+    public static int a(Enchantment enchantment, EntityLiving entityliving) {
+        Iterable<ItemStack> iterable = enchantment.a(entityliving).values();
+
+        if (iterable == null) {
+            return 0;
+        } else {
+            int i = 0;
+            Iterator iterator = iterable.iterator();
+
+            while (iterator.hasNext()) {
+                ItemStack itemstack = (ItemStack) iterator.next();
+                int j = getEnchantmentLevel(enchantment, itemstack);
+
+                if (j > i) {
+                    i = j;
+                }
+            }
+
+            return i;
+        }
+    }
+
+    public static int b(EntityLiving entityliving) {
+        return a(Enchantments.KNOCKBACK, entityliving);
+    }
+
+    public static int getFireAspectEnchantmentLevel(EntityLiving entityliving) {
+        return a(Enchantments.FIRE_ASPECT, entityliving);
+    }
+
+    public static int getOxygenEnchantmentLevel(EntityLiving entityliving) {
+        return a(Enchantments.OXYGEN, entityliving);
+    }
+
+    public static int e(EntityLiving entityliving) {
+        return a(Enchantments.DEPTH_STRIDER, entityliving);
+    }
+
+    public static int getDigSpeedEnchantmentLevel(EntityLiving entityliving) {
+        return a(Enchantments.DIG_SPEED, entityliving);
+    }
+
+    public static int b(ItemStack itemstack) {
+        return getEnchantmentLevel(Enchantments.LUCK, itemstack);
+    }
+
+    public static int c(ItemStack itemstack) {
+        return getEnchantmentLevel(Enchantments.LURE, itemstack);
+    }
+
+    public static int g(EntityLiving entityliving) {
+        return a(Enchantments.LOOT_BONUS_MOBS, entityliving);
+    }
+
+    public static boolean h(EntityLiving entityliving) {
+        return a(Enchantments.WATER_WORKER, entityliving) > 0;
+    }
+
+    public static boolean i(EntityLiving entityliving) {
+        return a(Enchantments.FROST_WALKER, entityliving) > 0;
+    }
+
+    public static boolean j(EntityLiving entityliving) {
+        return a(Enchantments.SOUL_SPEED, entityliving) > 0;
+    }
+
+    public static boolean d(ItemStack itemstack) {
+        return getEnchantmentLevel(Enchantments.BINDING_CURSE, itemstack) > 0;
+    }
+
+    public static boolean shouldNotDrop(ItemStack itemstack) {
+        return getEnchantmentLevel(Enchantments.VANISHING_CURSE, itemstack) > 0;
+    }
+
+    public static int f(ItemStack itemstack) {
+        return getEnchantmentLevel(Enchantments.LOYALTY, itemstack);
+    }
+
+    public static int g(ItemStack itemstack) {
+        return getEnchantmentLevel(Enchantments.RIPTIDE, itemstack);
+    }
+
+    public static boolean h(ItemStack itemstack) {
+        return getEnchantmentLevel(Enchantments.CHANNELING, itemstack) > 0;
+    }
+
+    @Nullable
+    public static Entry<EnumItemSlot, ItemStack> b(Enchantment enchantment, EntityLiving entityliving) {
+        return a(enchantment, entityliving, (itemstack) -> {
+            return true;
+        });
+    }
+
+    @Nullable
+    public static Entry<EnumItemSlot, ItemStack> a(Enchantment enchantment, EntityLiving entityliving, Predicate<ItemStack> predicate) {
+        Map<EnumItemSlot, ItemStack> map = enchantment.a(entityliving);
+
+        if (map.isEmpty()) {
+            return null;
+        } else {
+            List<Entry<EnumItemSlot, ItemStack>> list = Lists.newArrayList();
+            Iterator iterator = map.entrySet().iterator();
+
+            while (iterator.hasNext()) {
+                Entry<EnumItemSlot, ItemStack> entry = (Entry) iterator.next();
+                ItemStack itemstack = (ItemStack) entry.getValue();
+
+                if (!itemstack.isEmpty() && getEnchantmentLevel(enchantment, itemstack) > 0 && predicate.test(itemstack)) {
+                    list.add(entry);
+                }
+            }
+
+            return list.isEmpty() ? null : (Entry) list.get(entityliving.getRandom().nextInt(list.size()));
+        }
+    }
+
+    public static int a(Random random, int i, int j, ItemStack itemstack) {
+        Item item = itemstack.getItem();
+        int k = item.c();
+
+        if (k <= 0) {
+            return 0;
+        } else {
+            if (j > 15) {
+                j = 15;
+            }
+
+            int l = random.nextInt(8) + 1 + (j >> 1) + random.nextInt(j + 1);
+
+            return i == 0 ? Math.max(l / 3, 1) : (i == 1 ? l * 2 / 3 + 1 : Math.max(l, j * 2));
+        }
+    }
+
+    public static ItemStack a(Random random, ItemStack itemstack, int i, boolean flag) {
+        List<WeightedRandomEnchant> list = b(random, itemstack, i, flag);
+        boolean flag1 = itemstack.getItem() == Items.BOOK;
+
+        if (flag1) {
+            itemstack = new ItemStack(Items.ENCHANTED_BOOK);
+        }
+
+        Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            WeightedRandomEnchant weightedrandomenchant = (WeightedRandomEnchant) iterator.next();
+
+            if (flag1) {
+                ItemEnchantedBook.a(itemstack, weightedrandomenchant);
+            } else {
+                itemstack.addEnchantment(weightedrandomenchant.enchantment, weightedrandomenchant.level);
+            }
+        }
+
+        return itemstack;
+    }
+
+    public static List<WeightedRandomEnchant> b(Random random, ItemStack itemstack, int i, boolean flag) {
+        List<WeightedRandomEnchant> list = Lists.newArrayList();
+        Item item = itemstack.getItem();
+        int j = item.c();
+
+        if (j <= 0) {
+            return list;
+        } else {
+            i += 1 + random.nextInt(j / 4 + 1) + random.nextInt(j / 4 + 1);
+            float f = (random.nextFloat() + random.nextFloat() - 1.0F) * 0.15F;
+
+            i = MathHelper.clamp(Math.round((float) i + (float) i * f), 1, Integer.MAX_VALUE);
+            List<WeightedRandomEnchant> list1 = a(i, itemstack, flag);
+
+            if (!list1.isEmpty()) {
+                list.add(WeightedRandom.a(random, list1));
+
+                while (random.nextInt(50) <= i) {
+                    a(list1, (WeightedRandomEnchant) SystemUtils.a((List) list));
+                    if (list1.isEmpty()) {
+                        break;
+                    }
+
+                    list.add(WeightedRandom.a(random, list1));
+                    i /= 2;
+                }
+            }
+
+            return list;
+        }
+    }
+
+    public static void a(List<WeightedRandomEnchant> list, WeightedRandomEnchant weightedrandomenchant) {
+        Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            if (!weightedrandomenchant.enchantment.isCompatible(((WeightedRandomEnchant) iterator.next()).enchantment)) {
+                iterator.remove();
+            }
+        }
+
+    }
+
+    public static boolean a(Collection<Enchantment> collection, Enchantment enchantment) {
+        Iterator iterator = collection.iterator();
+
+        Enchantment enchantment1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
+            }
+
+            enchantment1 = (Enchantment) iterator.next();
+        } while (enchantment1.isCompatible(enchantment));
+
+        return false;
+    }
+
+    public static List<WeightedRandomEnchant> a(int i, ItemStack itemstack, boolean flag) {
+        List<WeightedRandomEnchant> list = Lists.newArrayList();
+        Item item = itemstack.getItem();
+        boolean flag1 = itemstack.getItem() == Items.BOOK;
+        Iterator iterator = IRegistry.ENCHANTMENT.iterator();
+
+        while (iterator.hasNext()) {
+            Enchantment enchantment = (Enchantment) iterator.next();
+
+            if ((!enchantment.isTreasure() || flag) && enchantment.i() && (enchantment.itemTarget.canEnchant(item) || flag1)) {
+                for (int j = enchantment.getMaxLevel(); j > enchantment.getStartLevel() - 1; --j) {
+                    if (i >= enchantment.a(j) && i <= enchantment.b(j)) {
+                        list.add(new WeightedRandomEnchant(enchantment, j));
+                        break;
+                    }
+                }
+            }
+        }
+
+        return list;
+    }
+
+    @FunctionalInterface
+    interface a {
+
+        void accept(Enchantment enchantment, int i);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/BlockAccessAir.java b/src/main/java/net/minecraft/world/level/BlockAccessAir.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f8022745f709b6d542182d2ac94147aefdd3f0f
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/BlockAccessAir.java
@@ -0,0 +1,32 @@
+package net.minecraft.world.level;
+
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.FluidTypes;
+
+public enum BlockAccessAir implements IBlockAccess {
+
+    INSTANCE;
+
+    private BlockAccessAir() {}
+
+    @Nullable
+    @Override
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        return null;
+    }
+
+    @Override
+    public IBlockData getType(BlockPosition blockposition) {
+        return Blocks.AIR.getBlockData();
+    }
+
+    @Override
+    public Fluid getFluid(BlockPosition blockposition) {
+        return FluidTypes.EMPTY.h();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/ChunkCache.java b/src/main/java/net/minecraft/world/level/ChunkCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..8541e87a34612e8bc86cf5c291164e091641d1af
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/ChunkCache.java
@@ -0,0 +1,128 @@
+package net.minecraft.world.level;
+
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.level.chunk.ChunkEmpty;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.chunk.IChunkProvider;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.FluidTypes;
+import net.minecraft.world.phys.AxisAlignedBB;
+import net.minecraft.world.phys.shapes.VoxelShape;
+
+public class ChunkCache implements IBlockAccess, ICollisionAccess {
+
+    protected final int a;
+    protected final int b;
+    protected final IChunkAccess[][] c;
+    protected boolean d;
+    protected final World e;
+
+    public ChunkCache(World world, BlockPosition blockposition, BlockPosition blockposition1) {
+        this.e = world;
+        this.a = blockposition.getX() >> 4;
+        this.b = blockposition.getZ() >> 4;
+        int i = blockposition1.getX() >> 4;
+        int j = blockposition1.getZ() >> 4;
+
+        this.c = new IChunkAccess[i - this.a + 1][j - this.b + 1];
+        IChunkProvider ichunkprovider = world.getChunkProvider();
+
+        this.d = true;
+
+        int k;
+        int l;
+
+        for (k = this.a; k <= i; ++k) {
+            for (l = this.b; l <= j; ++l) {
+                this.c[k - this.a][l - this.b] = ichunkprovider.a(k, l);
+            }
+        }
+
+        for (k = blockposition.getX() >> 4; k <= blockposition1.getX() >> 4; ++k) {
+            for (l = blockposition.getZ() >> 4; l <= blockposition1.getZ() >> 4; ++l) {
+                IChunkAccess ichunkaccess = this.c[k - this.a][l - this.b];
+
+                if (ichunkaccess != null && !ichunkaccess.a(blockposition.getY(), blockposition1.getY())) {
+                    this.d = false;
+                    return;
+                }
+            }
+        }
+
+    }
+
+    private IChunkAccess d(BlockPosition blockposition) {
+        return this.a(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+
+    private IChunkAccess a(int i, int j) {
+        int k = i - this.a;
+        int l = j - this.b;
+
+        if (k >= 0 && k < this.c.length && l >= 0 && l < this.c[k].length) {
+            IChunkAccess ichunkaccess = this.c[k][l];
+
+            return (IChunkAccess) (ichunkaccess != null ? ichunkaccess : new ChunkEmpty(this.e, new ChunkCoordIntPair(i, j)));
+        } else {
+            return new ChunkEmpty(this.e, new ChunkCoordIntPair(i, j));
+        }
+    }
+
+    @Override
+    public WorldBorder getWorldBorder() {
+        return this.e.getWorldBorder();
+    }
+
+    @Override
+    public IBlockAccess c(int i, int j) {
+        return this.a(i, j);
+    }
+
+    @Nullable
+    @Override
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        IChunkAccess ichunkaccess = this.d(blockposition);
+
+        return ichunkaccess.getTileEntity(blockposition);
+    }
+
+    @Override
+    public IBlockData getType(BlockPosition blockposition) {
+        if (World.isOutsideWorld(blockposition)) {
+            return Blocks.AIR.getBlockData();
+        } else {
+            IChunkAccess ichunkaccess = this.d(blockposition);
+
+            return ichunkaccess.getType(blockposition);
+        }
+    }
+
+    @Override
+    public Stream<VoxelShape> c(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
+        return Stream.empty();
+    }
+
+    @Override
+    public Stream<VoxelShape> d(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
+        return this.b(entity, axisalignedbb);
+    }
+
+    @Override
+    public Fluid getFluid(BlockPosition blockposition) {
+        if (World.isOutsideWorld(blockposition)) {
+            return FluidTypes.EMPTY.h();
+        } else {
+            IChunkAccess ichunkaccess = this.d(blockposition);
+
+            return ichunkaccess.getFluid(blockposition);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/ChunkCoordIntPair.java b/src/main/java/net/minecraft/world/level/ChunkCoordIntPair.java
new file mode 100644
index 0000000000000000000000000000000000000000..14e55bf842e928d1e8e2137f9efdef0f7c336362
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/ChunkCoordIntPair.java
@@ -0,0 +1,147 @@
+package net.minecraft.world.level;
+
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+
+public class ChunkCoordIntPair {
+
+    public static final long a = pair(1875016, 1875016);
+    public final int x;
+    public final int z;
+
+    public ChunkCoordIntPair(int i, int j) {
+        this.x = i;
+        this.z = j;
+    }
+
+    public ChunkCoordIntPair(BlockPosition blockposition) {
+        this.x = blockposition.getX() >> 4;
+        this.z = blockposition.getZ() >> 4;
+    }
+
+    public ChunkCoordIntPair(long i) {
+        this.x = (int) i;
+        this.z = (int) (i >> 32);
+    }
+
+    public long pair() {
+        return pair(this.x, this.z);
+    }
+
+    public static long pair(int i, int j) {
+        return (long) i & 4294967295L | ((long) j & 4294967295L) << 32;
+    }
+
+    public static int getX(long i) {
+        return (int) (i & 4294967295L);
+    }
+
+    public static int getZ(long i) {
+        return (int) (i >>> 32 & 4294967295L);
+    }
+
+    public int hashCode() {
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+
+        return i ^ j;
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof ChunkCoordIntPair)) {
+            return false;
+        } else {
+            ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) object;
+
+            return this.x == chunkcoordintpair.x && this.z == chunkcoordintpair.z;
+        }
+    }
+
+    public int d() {
+        return this.x << 4;
+    }
+
+    public int e() {
+        return this.z << 4;
+    }
+
+    public int f() {
+        return (this.x << 4) + 15;
+    }
+
+    public int g() {
+        return (this.z << 4) + 15;
+    }
+
+    public int getRegionX() {
+        return this.x >> 5;
+    }
+
+    public int getRegionZ() {
+        return this.z >> 5;
+    }
+
+    public int j() {
+        return this.x & 31;
+    }
+
+    public int k() {
+        return this.z & 31;
+    }
+
+    public String toString() {
+        return "[" + this.x + ", " + this.z + "]";
+    }
+
+    public BlockPosition l() {
+        return new BlockPosition(this.d(), 0, this.e());
+    }
+
+    public int a(ChunkCoordIntPair chunkcoordintpair) {
+        return Math.max(Math.abs(this.x - chunkcoordintpair.x), Math.abs(this.z - chunkcoordintpair.z));
+    }
+
+    public static Stream<ChunkCoordIntPair> a(ChunkCoordIntPair chunkcoordintpair, int i) {
+        return a(new ChunkCoordIntPair(chunkcoordintpair.x - i, chunkcoordintpair.z - i), new ChunkCoordIntPair(chunkcoordintpair.x + i, chunkcoordintpair.z + i));
+    }
+
+    public static Stream<ChunkCoordIntPair> a(final ChunkCoordIntPair chunkcoordintpair, final ChunkCoordIntPair chunkcoordintpair1) {
+        int i = Math.abs(chunkcoordintpair.x - chunkcoordintpair1.x) + 1;
+        int j = Math.abs(chunkcoordintpair.z - chunkcoordintpair1.z) + 1;
+        final int k = chunkcoordintpair.x < chunkcoordintpair1.x ? 1 : -1;
+        final int l = chunkcoordintpair.z < chunkcoordintpair1.z ? 1 : -1;
+
+        return StreamSupport.stream(new AbstractSpliterator<ChunkCoordIntPair>((long) (i * j), 64) {
+            @Nullable
+            private ChunkCoordIntPair e;
+
+            public boolean tryAdvance(Consumer<? super ChunkCoordIntPair> consumer) {
+                if (this.e == null) {
+                    this.e = chunkcoordintpair;
+                } else {
+                    int i1 = this.e.x;
+                    int j1 = this.e.z;
+
+                    if (i1 == chunkcoordintpair1.x) {
+                        if (j1 == chunkcoordintpair1.z) {
+                            return false;
+                        }
+
+                        this.e = new ChunkCoordIntPair(chunkcoordintpair.x, j1 + l);
+                    } else {
+                        this.e = new ChunkCoordIntPair(i1 + k, j1);
+                    }
+                }
+
+                consumer.accept(this.e);
+                return true;
+            }
+        }, false);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/ICollisionAccess.java b/src/main/java/net/minecraft/world/level/ICollisionAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..fcf6cc86e3b5d9afe3ab3b3fba2ec13846ed0b4c
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/ICollisionAccess.java
@@ -0,0 +1,73 @@
+package net.minecraft.world.level;
+
+import java.util.function.BiPredicate;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.phys.AxisAlignedBB;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapeCollision;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+
+public interface ICollisionAccess extends IBlockAccess {
+
+    WorldBorder getWorldBorder();
+
+    @Nullable
+    IBlockAccess c(int i, int j);
+
+    default boolean a(@Nullable Entity entity, VoxelShape voxelshape) {
+        return true;
+    }
+
+    default boolean a(IBlockData iblockdata, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
+        VoxelShape voxelshape = iblockdata.b((IBlockAccess) this, blockposition, voxelshapecollision);
+
+        return voxelshape.isEmpty() || this.a((Entity) null, voxelshape.a((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
+    }
+
+    default boolean j(Entity entity) {
+        return this.a(entity, VoxelShapes.a(entity.getBoundingBox()));
+    }
+
+    default boolean b(AxisAlignedBB axisalignedbb) {
+        return this.b((Entity) null, axisalignedbb, (entity) -> {
+            return true;
+        });
+    }
+
+    default boolean getCubes(Entity entity) {
+        return this.b(entity, entity.getBoundingBox(), (entity1) -> {
+            return true;
+        });
+    }
+
+    default boolean getCubes(Entity entity, AxisAlignedBB axisalignedbb) {
+        return this.b(entity, axisalignedbb, (entity1) -> {
+            return true;
+        });
+    }
+
+    default boolean b(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
+        return this.d(entity, axisalignedbb, predicate).allMatch(VoxelShape::isEmpty);
+    }
+
+    Stream<VoxelShape> c(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate);
+
+    default Stream<VoxelShape> d(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
+        return Stream.concat(this.b(entity, axisalignedbb), this.c(entity, axisalignedbb, predicate));
+    }
+
+    default Stream<VoxelShape> b(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+        return StreamSupport.stream(new VoxelShapeSpliterator(this, entity, axisalignedbb), false);
+    }
+
+    default Stream<VoxelShape> b(@Nullable Entity entity, AxisAlignedBB axisalignedbb, BiPredicate<IBlockData, BlockPosition> bipredicate) {
+        return StreamSupport.stream(new VoxelShapeSpliterator(this, entity, axisalignedbb, bipredicate), false);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/IEntityAccess.java b/src/main/java/net/minecraft/world/level/IEntityAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..d24f97593777d6929271520f7501a800f1aadaa6
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/IEntityAccess.java
@@ -0,0 +1,243 @@
+package net.minecraft.world.level;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import java.util.UUID;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.IEntitySelector;
+import net.minecraft.world.entity.ai.targeting.PathfinderTargetCondition;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.phys.AxisAlignedBB;
+import net.minecraft.world.phys.shapes.OperatorBoolean;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+
+public interface IEntityAccess {
+
+    List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate);
+
+    <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super T> predicate);
+
+    default <T extends Entity> List<T> b(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super T> predicate) {
+        return this.a(oclass, axisalignedbb, predicate);
+    }
+
+    List<? extends EntityHuman> getPlayers();
+
+    default List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+        return this.getEntities(entity, axisalignedbb, IEntitySelector.g);
+    }
+
+    default boolean a(@Nullable Entity entity, VoxelShape voxelshape) {
+        if (voxelshape.isEmpty()) {
+            return true;
+        } else {
+            Iterator iterator = this.getEntities(entity, voxelshape.getBoundingBox()).iterator();
+
+            Entity entity1;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return true;
+                }
+
+                entity1 = (Entity) iterator.next();
+            } while (entity1.dead || !entity1.i || entity != null && entity1.isSameVehicle(entity) || !VoxelShapes.c(voxelshape, VoxelShapes.a(entity1.getBoundingBox()), OperatorBoolean.AND));
+
+            return false;
+        }
+    }
+
+    default <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb) {
+        return this.a(oclass, axisalignedbb, IEntitySelector.g);
+    }
+
+    default <T extends Entity> List<T> b(Class<? extends T> oclass, AxisAlignedBB axisalignedbb) {
+        return this.b(oclass, axisalignedbb, IEntitySelector.g);
+    }
+
+    default Stream<VoxelShape> c(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
+        if (axisalignedbb.a() < 1.0E-7D) {
+            return Stream.empty();
+        } else {
+            AxisAlignedBB axisalignedbb1 = axisalignedbb.g(1.0E-7D);
+
+            return this.getEntities(entity, axisalignedbb1, predicate.and((entity1) -> {
+                boolean flag;
+
+                if (entity1.getBoundingBox().c(axisalignedbb1)) {
+                    label25:
+                    {
+                        if (entity == null) {
+                            if (!entity1.aZ()) {
+                                break label25;
+                            }
+                        } else if (!entity.j(entity1)) {
+                            break label25;
+                        }
+
+                        flag = true;
+                        return flag;
+                    }
+                }
+
+                flag = false;
+                return flag;
+            })).stream().map(Entity::getBoundingBox).map(VoxelShapes::a);
+        }
+    }
+
+    @Nullable
+    default EntityHuman a(double d0, double d1, double d2, double d3, @Nullable Predicate<Entity> predicate) {
+        double d4 = -1.0D;
+        EntityHuman entityhuman = null;
+        Iterator iterator = this.getPlayers().iterator();
+
+        while (iterator.hasNext()) {
+            EntityHuman entityhuman1 = (EntityHuman) iterator.next();
+
+            if (predicate == null || predicate.test(entityhuman1)) {
+                double d5 = entityhuman1.h(d0, d1, d2);
+
+                if ((d3 < 0.0D || d5 < d3 * d3) && (d4 == -1.0D || d5 < d4)) {
+                    d4 = d5;
+                    entityhuman = entityhuman1;
+                }
+            }
+        }
+
+        return entityhuman;
+    }
+
+    @Nullable
+    default EntityHuman findNearbyPlayer(Entity entity, double d0) {
+        return this.a(entity.locX(), entity.locY(), entity.locZ(), d0, false);
+    }
+
+    @Nullable
+    default EntityHuman a(double d0, double d1, double d2, double d3, boolean flag) {
+        Predicate<Entity> predicate = flag ? IEntitySelector.e : IEntitySelector.g;
+
+        return this.a(d0, d1, d2, d3, predicate);
+    }
+
+    default boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
+        Iterator iterator = this.getPlayers().iterator();
+
+        double d4;
+
+        do {
+            EntityHuman entityhuman;
+
+            do {
+                do {
+                    if (!iterator.hasNext()) {
+                        return false;
+                    }
+
+                    entityhuman = (EntityHuman) iterator.next();
+                } while (!IEntitySelector.g.test(entityhuman));
+            } while (!IEntitySelector.b.test(entityhuman));
+
+            d4 = entityhuman.h(d0, d1, d2);
+        } while (d3 >= 0.0D && d4 >= d3 * d3);
+
+        return true;
+    }
+
+    @Nullable
+    default EntityHuman a(PathfinderTargetCondition pathfindertargetcondition, EntityLiving entityliving) {
+        return (EntityHuman) this.a(this.getPlayers(), pathfindertargetcondition, entityliving, entityliving.locX(), entityliving.locY(), entityliving.locZ());
+    }
+
+    @Nullable
+    default EntityHuman a(PathfinderTargetCondition pathfindertargetcondition, EntityLiving entityliving, double d0, double d1, double d2) {
+        return (EntityHuman) this.a(this.getPlayers(), pathfindertargetcondition, entityliving, d0, d1, d2);
+    }
+
+    @Nullable
+    default EntityHuman a(PathfinderTargetCondition pathfindertargetcondition, double d0, double d1, double d2) {
+        return (EntityHuman) this.a(this.getPlayers(), pathfindertargetcondition, (EntityLiving) null, d0, d1, d2);
+    }
+
+    @Nullable
+    default <T extends EntityLiving> T a(Class<? extends T> oclass, PathfinderTargetCondition pathfindertargetcondition, @Nullable EntityLiving entityliving, double d0, double d1, double d2, AxisAlignedBB axisalignedbb) {
+        return this.a(this.a(oclass, axisalignedbb, (Predicate) null), pathfindertargetcondition, entityliving, d0, d1, d2);
+    }
+
+    @Nullable
+    default <T extends EntityLiving> T b(Class<? extends T> oclass, PathfinderTargetCondition pathfindertargetcondition, @Nullable EntityLiving entityliving, double d0, double d1, double d2, AxisAlignedBB axisalignedbb) {
+        return this.a(this.b(oclass, axisalignedbb, (Predicate) null), pathfindertargetcondition, entityliving, d0, d1, d2);
+    }
+
+    @Nullable
+    default <T extends EntityLiving> T a(List<? extends T> list, PathfinderTargetCondition pathfindertargetcondition, @Nullable EntityLiving entityliving, double d0, double d1, double d2) {
+        double d3 = -1.0D;
+        T t0 = null;
+        Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            T t1 = (EntityLiving) iterator.next();
+
+            if (pathfindertargetcondition.a(entityliving, t1)) {
+                double d4 = t1.h(d0, d1, d2);
+
+                if (d3 == -1.0D || d4 < d3) {
+                    d3 = d4;
+                    t0 = t1;
+                }
+            }
+        }
+
+        return t0;
+    }
+
+    default List<EntityHuman> a(PathfinderTargetCondition pathfindertargetcondition, EntityLiving entityliving, AxisAlignedBB axisalignedbb) {
+        List<EntityHuman> list = Lists.newArrayList();
+        Iterator iterator = this.getPlayers().iterator();
+
+        while (iterator.hasNext()) {
+            EntityHuman entityhuman = (EntityHuman) iterator.next();
+
+            if (axisalignedbb.e(entityhuman.locX(), entityhuman.locY(), entityhuman.locZ()) && pathfindertargetcondition.a(entityliving, entityhuman)) {
+                list.add(entityhuman);
+            }
+        }
+
+        return list;
+    }
+
+    default <T extends EntityLiving> List<T> a(Class<? extends T> oclass, PathfinderTargetCondition pathfindertargetcondition, EntityLiving entityliving, AxisAlignedBB axisalignedbb) {
+        List<T> list = this.a(oclass, axisalignedbb, (Predicate) null);
+        List<T> list1 = Lists.newArrayList();
+        Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            T t0 = (EntityLiving) iterator.next();
+
+            if (pathfindertargetcondition.a(entityliving, t0)) {
+                list1.add(t0);
+            }
+        }
+
+        return list1;
+    }
+
+    @Nullable
+    default EntityHuman b(UUID uuid) {
+        for (int i = 0; i < this.getPlayers().size(); ++i) {
+            EntityHuman entityhuman = (EntityHuman) this.getPlayers().get(i);
+
+            if (uuid.equals(entityhuman.getUniqueID())) {
+                return entityhuman;
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/IWorldReader.java b/src/main/java/net/minecraft/world/level/IWorldReader.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3d33e77ce09d485552076c5ab6faf08a16d90db
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/IWorldReader.java
@@ -0,0 +1,188 @@
+package net.minecraft.world.level;
+
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsFluid;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.biome.BiomeManager;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.dimension.DimensionManager;
+import net.minecraft.world.level.levelgen.HeightMap;
+import net.minecraft.world.phys.AxisAlignedBB;
+
+public interface IWorldReader extends IBlockLightAccess, ICollisionAccess, BiomeManager.Provider {
+
+    @Nullable
+    IChunkAccess getChunkAt(int i, int j, ChunkStatus chunkstatus, boolean flag);
+
+    @Deprecated
+    boolean isChunkLoaded(int i, int j);
+
+    int a(HeightMap.Type heightmap_type, int i, int j);
+
+    int c();
+
+    BiomeManager d();
+
+    default BiomeBase getBiome(BlockPosition blockposition) {
+        return this.d().a(blockposition);
+    }
+
+    default Stream<IBlockData> c(AxisAlignedBB axisalignedbb) {
+        int i = MathHelper.floor(axisalignedbb.minX);
+        int j = MathHelper.floor(axisalignedbb.maxX);
+        int k = MathHelper.floor(axisalignedbb.minY);
+        int l = MathHelper.floor(axisalignedbb.maxY);
+        int i1 = MathHelper.floor(axisalignedbb.minZ);
+        int j1 = MathHelper.floor(axisalignedbb.maxZ);
+
+        return this.isAreaLoaded(i, k, i1, j, l, j1) ? this.a(axisalignedbb) : Stream.empty();
+    }
+
+    @Override
+    default BiomeBase getBiome(int i, int j, int k) {
+        IChunkAccess ichunkaccess = this.getChunkAt(i >> 2, k >> 2, ChunkStatus.BIOMES, false);
+
+        return ichunkaccess != null && ichunkaccess.getBiomeIndex() != null ? ichunkaccess.getBiomeIndex().getBiome(i, j, k) : this.a(i, j, k);
+    }
+
+    BiomeBase a(int i, int j, int k);
+
+    boolean s_();
+
+    @Deprecated
+    int getSeaLevel();
+
+    DimensionManager getDimensionManager();
+
+    default BlockPosition getHighestBlockYAt(HeightMap.Type heightmap_type, BlockPosition blockposition) {
+        return new BlockPosition(blockposition.getX(), this.a(heightmap_type, blockposition.getX(), blockposition.getZ()), blockposition.getZ());
+    }
+
+    default boolean isEmpty(BlockPosition blockposition) {
+        return this.getType(blockposition).isAir();
+    }
+
+    default boolean x(BlockPosition blockposition) {
+        if (blockposition.getY() >= this.getSeaLevel()) {
+            return this.e(blockposition);
+        } else {
+            BlockPosition blockposition1 = new BlockPosition(blockposition.getX(), this.getSeaLevel(), blockposition.getZ());
+
+            if (!this.e(blockposition1)) {
+                return false;
+            } else {
+                for (blockposition1 = blockposition1.down(); blockposition1.getY() > blockposition.getY(); blockposition1 = blockposition1.down()) {
+                    IBlockData iblockdata = this.getType(blockposition1);
+
+                    if (iblockdata.b((IBlockAccess) this, blockposition1) > 0 && !iblockdata.getMaterial().isLiquid()) {
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+        }
+    }
+
+    @Deprecated
+    default float y(BlockPosition blockposition) {
+        return this.getDimensionManager().a(this.getLightLevel(blockposition));
+    }
+
+    default int c(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getType(blockposition).c(this, blockposition, enumdirection);
+    }
+
+    default IChunkAccess z(BlockPosition blockposition) {
+        return this.getChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+
+    default IChunkAccess getChunkAt(int i, int j) {
+        return this.getChunkAt(i, j, ChunkStatus.FULL, true);
+    }
+
+    default IChunkAccess getChunkAt(int i, int j, ChunkStatus chunkstatus) {
+        return this.getChunkAt(i, j, chunkstatus, true);
+    }
+
+    @Nullable
+    @Override
+    default IBlockAccess c(int i, int j) {
+        return this.getChunkAt(i, j, ChunkStatus.EMPTY, false);
+    }
+
+    default boolean A(BlockPosition blockposition) {
+        return this.getFluid(blockposition).a((Tag) TagsFluid.WATER);
+    }
+
+    default boolean containsLiquid(AxisAlignedBB axisalignedbb) {
+        int i = MathHelper.floor(axisalignedbb.minX);
+        int j = MathHelper.f(axisalignedbb.maxX);
+        int k = MathHelper.floor(axisalignedbb.minY);
+        int l = MathHelper.f(axisalignedbb.maxY);
+        int i1 = MathHelper.floor(axisalignedbb.minZ);
+        int j1 = MathHelper.f(axisalignedbb.maxZ);
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        for (int k1 = i; k1 < j; ++k1) {
+            for (int l1 = k; l1 < l; ++l1) {
+                for (int i2 = i1; i2 < j1; ++i2) {
+                    IBlockData iblockdata = this.getType(blockposition_mutableblockposition.d(k1, l1, i2));
+
+                    if (!iblockdata.getFluid().isEmpty()) {
+                        return true;
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    default int getLightLevel(BlockPosition blockposition) {
+        return this.c(blockposition, this.c());
+    }
+
+    default int c(BlockPosition blockposition, int i) {
+        return blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 ? this.getLightLevel(blockposition, i) : 15;
+    }
+
+    @Deprecated
+    default boolean isLoaded(BlockPosition blockposition) {
+        return this.isChunkLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+
+    @Deprecated
+    default boolean areChunksLoadedBetween(BlockPosition blockposition, BlockPosition blockposition1) {
+        return this.isAreaLoaded(blockposition.getX(), blockposition.getY(), blockposition.getZ(), blockposition1.getX(), blockposition1.getY(), blockposition1.getZ());
+    }
+
+    @Deprecated
+    default boolean isAreaLoaded(int i, int j, int k, int l, int i1, int j1) {
+        if (i1 >= 0 && j < 256) {
+            i >>= 4;
+            k >>= 4;
+            l >>= 4;
+            j1 >>= 4;
+
+            for (int k1 = i; k1 <= l; ++k1) {
+                for (int l1 = k; l1 <= j1; ++l1) {
+                    if (!this.isChunkLoaded(k1, l1)) {
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/NextTickListEntry.java b/src/main/java/net/minecraft/world/level/NextTickListEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..116a5e4ded3ccf935fd143f2512098c22ec2ad76
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/NextTickListEntry.java
@@ -0,0 +1,58 @@
+package net.minecraft.world.level;
+
+import java.util.Comparator;
+import net.minecraft.core.BlockPosition;
+
+public class NextTickListEntry<T> {
+
+    private static long d;
+    private final T e;
+    public final BlockPosition a;
+    public final long b;
+    public final TickListPriority c;
+    private final long f;
+
+    public NextTickListEntry(BlockPosition blockposition, T t0) {
+        this(blockposition, t0, 0L, TickListPriority.NORMAL);
+    }
+
+    public NextTickListEntry(BlockPosition blockposition, T t0, long i, TickListPriority ticklistpriority) {
+        this.f = (long) (NextTickListEntry.d++);
+        this.a = blockposition.immutableCopy();
+        this.e = t0;
+        this.b = i;
+        this.c = ticklistpriority;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NextTickListEntry)) {
+            return false;
+        } else {
+            NextTickListEntry<?> nextticklistentry = (NextTickListEntry) object;
+
+            return this.a.equals(nextticklistentry.a) && this.e == nextticklistentry.e;
+        }
+    }
+
+    public int hashCode() {
+        return this.a.hashCode();
+    }
+
+    public static <T> Comparator<NextTickListEntry<T>> a() {
+        return Comparator.comparingLong((nextticklistentry) -> {
+            return nextticklistentry.b;
+        }).thenComparing((nextticklistentry) -> {
+            return nextticklistentry.c;
+        }).thenComparingLong((nextticklistentry) -> {
+            return nextticklistentry.f;
+        });
+    }
+
+    public String toString() {
+        return this.e + ": " + this.a + ", " + this.b + ", " + this.c + ", " + this.f;
+    }
+
+    public T b() {
+        return this.e;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/TickListChunk.java b/src/main/java/net/minecraft/world/level/TickListChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..c3cb513d0d107ecb43e98960b25054626aa6a03f
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/TickListChunk.java
@@ -0,0 +1,105 @@
+package net.minecraft.world.level;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.resources.MinecraftKey;
+
+public class TickListChunk<T> implements TickList<T> {
+
+    private final List<TickListChunk.a<T>> a;
+    private final Function<T, MinecraftKey> b;
+
+    public TickListChunk(Function<T, MinecraftKey> function, List<NextTickListEntry<T>> list, long i) {
+        this(function, (List) list.stream().map((nextticklistentry) -> {
+            return new TickListChunk.a<>(nextticklistentry.b(), nextticklistentry.a, (int) (nextticklistentry.b - i), nextticklistentry.c);
+        }).collect(Collectors.toList()));
+    }
+
+    private TickListChunk(Function<T, MinecraftKey> function, List<TickListChunk.a<T>> list) {
+        this.a = list;
+        this.b = function;
+    }
+
+    @Override
+    public boolean a(BlockPosition blockposition, T t0) {
+        return false;
+    }
+
+    @Override
+    public void a(BlockPosition blockposition, T t0, int i, TickListPriority ticklistpriority) {
+        this.a.add(new TickListChunk.a<>(t0, blockposition, i, ticklistpriority));
+    }
+
+    @Override
+    public boolean b(BlockPosition blockposition, T t0) {
+        return false;
+    }
+
+    public NBTTagList b() {
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.a.iterator();
+
+        while (iterator.hasNext()) {
+            TickListChunk.a<T> ticklistchunk_a = (TickListChunk.a) iterator.next();
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+            nbttagcompound.setString("i", ((MinecraftKey) this.b.apply(ticklistchunk_a.d)).toString());
+            nbttagcompound.setInt("x", ticklistchunk_a.a.getX());
+            nbttagcompound.setInt("y", ticklistchunk_a.a.getY());
+            nbttagcompound.setInt("z", ticklistchunk_a.a.getZ());
+            nbttagcompound.setInt("t", ticklistchunk_a.b);
+            nbttagcompound.setInt("p", ticklistchunk_a.c.a());
+            nbttaglist.add(nbttagcompound);
+        }
+
+        return nbttaglist;
+    }
+
+    public static <T> TickListChunk<T> a(NBTTagList nbttaglist, Function<T, MinecraftKey> function, Function<MinecraftKey, T> function1) {
+        List<TickListChunk.a<T>> list = Lists.newArrayList();
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound = nbttaglist.getCompound(i);
+            T t0 = function1.apply(new MinecraftKey(nbttagcompound.getString("i")));
+
+            if (t0 != null) {
+                BlockPosition blockposition = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
+
+                list.add(new TickListChunk.a<>(t0, blockposition, nbttagcompound.getInt("t"), TickListPriority.a(nbttagcompound.getInt("p"))));
+            }
+        }
+
+        return new TickListChunk<>(function, list);
+    }
+
+    public void a(TickList<T> ticklist) {
+        this.a.forEach((ticklistchunk_a) -> {
+            ticklist.a(ticklistchunk_a.a, ticklistchunk_a.d, ticklistchunk_a.b, ticklistchunk_a.c);
+        });
+    }
+
+    static class a<T> {
+
+        private final T d;
+        public final BlockPosition a;
+        public final int b;
+        public final TickListPriority c;
+
+        private a(T t0, BlockPosition blockposition, int i, TickListPriority ticklistpriority) {
+            this.d = t0;
+            this.a = blockposition;
+            this.b = i;
+            this.c = ticklistpriority;
+        }
+
+        public String toString() {
+            return this.d + ": " + this.a + ", " + this.b + ", " + this.c;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/VoxelShapeSpliterator.java b/src/main/java/net/minecraft/world/level/VoxelShapeSpliterator.java
new file mode 100644
index 0000000000000000000000000000000000000000..fa3421c9cd8531618827627e9c524a8df77c4c58
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/VoxelShapeSpliterator.java
@@ -0,0 +1,156 @@
+package net.minecraft.world.level;
+
+import java.util.Objects;
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.function.BiPredicate;
+import java.util.function.Consumer;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.CursorPosition;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.phys.AxisAlignedBB;
+import net.minecraft.world.phys.shapes.OperatorBoolean;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapeCollision;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+
+public class VoxelShapeSpliterator extends AbstractSpliterator<VoxelShape> {
+
+    @Nullable
+    private final Entity a;
+    private final AxisAlignedBB b;
+    private final VoxelShapeCollision c;
+    private final CursorPosition d;
+    private final BlockPosition.MutableBlockPosition e;
+    private final VoxelShape f;
+    private final ICollisionAccess g;
+    private boolean h;
+    private final BiPredicate<IBlockData, BlockPosition> i;
+
+    public VoxelShapeSpliterator(ICollisionAccess icollisionaccess, @Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+        this(icollisionaccess, entity, axisalignedbb, (iblockdata, blockposition) -> {
+            return true;
+        });
+    }
+
+    public VoxelShapeSpliterator(ICollisionAccess icollisionaccess, @Nullable Entity entity, AxisAlignedBB axisalignedbb, BiPredicate<IBlockData, BlockPosition> bipredicate) {
+        super(Long.MAX_VALUE, 1280);
+        this.c = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity);
+        this.e = new BlockPosition.MutableBlockPosition();
+        this.f = VoxelShapes.a(axisalignedbb);
+        this.g = icollisionaccess;
+        this.h = entity != null;
+        this.a = entity;
+        this.b = axisalignedbb;
+        this.i = bipredicate;
+        int i = MathHelper.floor(axisalignedbb.minX - 1.0E-7D) - 1;
+        int j = MathHelper.floor(axisalignedbb.maxX + 1.0E-7D) + 1;
+        int k = MathHelper.floor(axisalignedbb.minY - 1.0E-7D) - 1;
+        int l = MathHelper.floor(axisalignedbb.maxY + 1.0E-7D) + 1;
+        int i1 = MathHelper.floor(axisalignedbb.minZ - 1.0E-7D) - 1;
+        int j1 = MathHelper.floor(axisalignedbb.maxZ + 1.0E-7D) + 1;
+
+        this.d = new CursorPosition(i, k, i1, j, l, j1);
+    }
+
+    public boolean tryAdvance(Consumer<? super VoxelShape> consumer) {
+        return this.h && this.b(consumer) || this.a(consumer);
+    }
+
+    boolean a(Consumer<? super VoxelShape> consumer) {
+        while (true) {
+            if (this.d.a()) {
+                int i = this.d.b();
+                int j = this.d.c();
+                int k = this.d.d();
+                int l = this.d.e();
+
+                if (l == 3) {
+                    continue;
+                }
+
+                IBlockAccess iblockaccess = this.a(i, k);
+
+                if (iblockaccess == null) {
+                    continue;
+                }
+
+                this.e.d(i, j, k);
+                IBlockData iblockdata = iblockaccess.getType(this.e);
+
+                if (!this.i.test(iblockdata, this.e) || l == 1 && !iblockdata.d() || l == 2 && !iblockdata.a(Blocks.MOVING_PISTON)) {
+                    continue;
+                }
+
+                VoxelShape voxelshape = iblockdata.b((IBlockAccess) this.g, this.e, this.c);
+
+                if (voxelshape == VoxelShapes.b()) {
+                    if (!this.b.a((double) i, (double) j, (double) k, (double) i + 1.0D, (double) j + 1.0D, (double) k + 1.0D)) {
+                        continue;
+                    }
+
+                    consumer.accept(voxelshape.a((double) i, (double) j, (double) k));
+                    return true;
+                }
+
+                VoxelShape voxelshape1 = voxelshape.a((double) i, (double) j, (double) k);
+
+                if (!VoxelShapes.c(voxelshape1, this.f, OperatorBoolean.AND)) {
+                    continue;
+                }
+
+                consumer.accept(voxelshape1);
+                return true;
+            }
+
+            return false;
+        }
+    }
+
+    @Nullable
+    private IBlockAccess a(int i, int j) {
+        int k = i >> 4;
+        int l = j >> 4;
+
+        return this.g.c(k, l);
+    }
+
+    boolean b(Consumer<? super VoxelShape> consumer) {
+        Objects.requireNonNull(this.a);
+        this.h = false;
+        WorldBorder worldborder = this.g.getWorldBorder();
+        AxisAlignedBB axisalignedbb = this.a.getBoundingBox();
+
+        if (!a(worldborder, axisalignedbb)) {
+            VoxelShape voxelshape = worldborder.c();
+
+            if (!b(voxelshape, axisalignedbb) && a(voxelshape, axisalignedbb)) {
+                consumer.accept(voxelshape);
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private static boolean a(VoxelShape voxelshape, AxisAlignedBB axisalignedbb) {
+        return VoxelShapes.c(voxelshape, VoxelShapes.a(axisalignedbb.g(1.0E-7D)), OperatorBoolean.AND);
+    }
+
+    private static boolean b(VoxelShape voxelshape, AxisAlignedBB axisalignedbb) {
+        return VoxelShapes.c(voxelshape, VoxelShapes.a(axisalignedbb.shrink(1.0E-7D)), OperatorBoolean.AND);
+    }
+
+    public static boolean a(WorldBorder worldborder, AxisAlignedBB axisalignedbb) {
+        double d0 = (double) MathHelper.floor(worldborder.e());
+        double d1 = (double) MathHelper.floor(worldborder.f());
+        double d2 = (double) MathHelper.f(worldborder.g());
+        double d3 = (double) MathHelper.f(worldborder.h());
+
+        return axisalignedbb.minX > d0 && axisalignedbb.minX < d2 && axisalignedbb.minZ > d1 && axisalignedbb.minZ < d3 && axisalignedbb.maxX > d0 && axisalignedbb.maxX < d2 && axisalignedbb.maxZ > d1 && axisalignedbb.maxZ < d3;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/biome/BiomeBase.java b/src/main/java/net/minecraft/world/level/biome/BiomeBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..6672d74426d6a334d52f641c48d3a352c2bb6605
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/biome/BiomeBase.java
@@ -0,0 +1,586 @@
+package net.minecraft.world.level.biome;
+
+import com.google.common.collect.ImmutableList;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.MapCodec;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import it.unimi.dsi.fastutil.longs.Long2FloatLinkedOpenHashMap;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportedException;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IRegistry;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.data.RegistryGeneration;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.resources.RegistryFileCodec;
+import net.minecraft.server.level.RegionLimitedWorldAccess;
+import net.minecraft.util.INamable;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.IWorldReader;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.block.BlockFluids;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.levelgen.SeededRandom;
+import net.minecraft.world.level.levelgen.WorldGenStage;
+import net.minecraft.world.level.levelgen.feature.StructureGenerator;
+import net.minecraft.world.level.levelgen.feature.WorldGenFeatureConfigured;
+import net.minecraft.world.level.levelgen.structure.StructureBoundingBox;
+import net.minecraft.world.level.levelgen.surfacebuilders.WorldGenSurfaceComposite;
+import net.minecraft.world.level.levelgen.synth.NoiseGenerator3;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.FluidTypes;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public final class BiomeBase {
+
+    public static final Logger LOGGER = LogManager.getLogger();
+    public static final Codec<BiomeBase> b = RecordCodecBuilder.create((instance) -> {
+        return instance.group(BiomeBase.d.a.forGetter((biomebase) -> {
+            return biomebase.j;
+        }), BiomeBase.Geography.r.fieldOf("category").forGetter((biomebase) -> {
+            return biomebase.o;
+        }), Codec.FLOAT.fieldOf("depth").forGetter((biomebase) -> {
+            return biomebase.m;
+        }), Codec.FLOAT.fieldOf("scale").forGetter((biomebase) -> {
+            return biomebase.n;
+        }), BiomeFog.a.fieldOf("effects").forGetter((biomebase) -> {
+            return biomebase.p;
+        }), BiomeSettingsGeneration.c.forGetter((biomebase) -> {
+            return biomebase.k;
+        }), BiomeSettingsMobs.c.forGetter((biomebase) -> {
+            return biomebase.l;
+        })).apply(instance, BiomeBase::new);
+    });
+    public static final Codec<BiomeBase> c = RecordCodecBuilder.create((instance) -> {
+        return instance.group(BiomeBase.d.a.forGetter((biomebase) -> {
+            return biomebase.j;
+        }), BiomeBase.Geography.r.fieldOf("category").forGetter((biomebase) -> {
+            return biomebase.o;
+        }), Codec.FLOAT.fieldOf("depth").forGetter((biomebase) -> {
+            return biomebase.m;
+        }), Codec.FLOAT.fieldOf("scale").forGetter((biomebase) -> {
+            return biomebase.n;
+        }), BiomeFog.a.fieldOf("effects").forGetter((biomebase) -> {
+            return biomebase.p;
+        })).apply(instance, (biomebase_d, biomebase_geography, ofloat, ofloat1, biomefog) -> {
+            return new BiomeBase(biomebase_d, biomebase_geography, ofloat, ofloat1, biomefog, BiomeSettingsGeneration.b, BiomeSettingsMobs.b);
+        });
+    });
+    public static final Codec<Supplier<BiomeBase>> d = RegistryFileCodec.a(IRegistry.ay, BiomeBase.b);
+    public static final Codec<List<Supplier<BiomeBase>>> e = RegistryFileCodec.b(IRegistry.ay, BiomeBase.b);
+    private final Map<Integer, List<StructureGenerator<?>>> g;
+    private static final NoiseGenerator3 h = new NoiseGenerator3(new SeededRandom(1234L), ImmutableList.of(0));
+    private static final NoiseGenerator3 i = new NoiseGenerator3(new SeededRandom(3456L), ImmutableList.of(-2, -1, 0));
+    public static final NoiseGenerator3 f = new NoiseGenerator3(new SeededRandom(2345L), ImmutableList.of(0));
+    private final BiomeBase.d j;
+    private final BiomeSettingsGeneration k;
+    private final BiomeSettingsMobs l;
+    private final float m;
+    private final float n;
+    private final BiomeBase.Geography o;
+    private final BiomeFog p;
+    private final ThreadLocal<Long2FloatLinkedOpenHashMap> q;
+
+    private BiomeBase(BiomeBase.d biomebase_d, BiomeBase.Geography biomebase_geography, float f, float f1, BiomeFog biomefog, BiomeSettingsGeneration biomesettingsgeneration, BiomeSettingsMobs biomesettingsmobs) {
+        this.g = (Map) IRegistry.STRUCTURE_FEATURE.g().collect(Collectors.groupingBy((structuregenerator) -> {
+            return structuregenerator.f().ordinal();
+        }));
+        this.q = ThreadLocal.withInitial(() -> {
+            return (Long2FloatLinkedOpenHashMap) SystemUtils.a(() -> {
+                Long2FloatLinkedOpenHashMap long2floatlinkedopenhashmap = new Long2FloatLinkedOpenHashMap(1024, 0.25F) {
+                    protected void rehash(int i) {}
+                };
+
+                long2floatlinkedopenhashmap.defaultReturnValue(Float.NaN);
+                return long2floatlinkedopenhashmap;
+            });
+        });
+        this.j = biomebase_d;
+        this.k = biomesettingsgeneration;
+        this.l = biomesettingsmobs;
+        this.o = biomebase_geography;
+        this.m = f;
+        this.n = f1;
+        this.p = biomefog;
+    }
+
+    public BiomeSettingsMobs b() {
+        return this.l;
+    }
+
+    public BiomeBase.Precipitation c() {
+        return this.j.b;
+    }
+
+    public boolean d() {
+        return this.getHumidity() > 0.85F;
+    }
+
+    private float b(BlockPosition blockposition) {
+        float f = this.j.d.a(blockposition, this.k());
+
+        if (blockposition.getY() > 64) {
+            float f1 = (float) (BiomeBase.h.a((double) ((float) blockposition.getX() / 8.0F), (double) ((float) blockposition.getZ() / 8.0F), false) * 4.0D);
+
+            return f - (f1 + (float) blockposition.getY() - 64.0F) * 0.05F / 30.0F;
+        } else {
+            return f;
+        }
+    }
+
+    public final float getAdjustedTemperature(BlockPosition blockposition) {
+        long i = blockposition.asLong();
+        Long2FloatLinkedOpenHashMap long2floatlinkedopenhashmap = (Long2FloatLinkedOpenHashMap) this.q.get();
+        float f = long2floatlinkedopenhashmap.get(i);
+
+        if (!Float.isNaN(f)) {
+            return f;
+        } else {
+            float f1 = this.b(blockposition);
+
+            if (long2floatlinkedopenhashmap.size() == 1024) {
+                long2floatlinkedopenhashmap.removeFirstFloat();
+            }
+
+            long2floatlinkedopenhashmap.put(i, f1);
+            return f1;
+        }
+    }
+
+    public boolean a(IWorldReader iworldreader, BlockPosition blockposition) {
+        return this.a(iworldreader, blockposition, true);
+    }
+
+    public boolean a(IWorldReader iworldreader, BlockPosition blockposition, boolean flag) {
+        if (this.getAdjustedTemperature(blockposition) >= 0.15F) {
+            return false;
+        } else {
+            if (blockposition.getY() >= 0 && blockposition.getY() < 256 && iworldreader.getBrightness(EnumSkyBlock.BLOCK, blockposition) < 10) {
+                IBlockData iblockdata = iworldreader.getType(blockposition);
+                Fluid fluid = iworldreader.getFluid(blockposition);
+
+                if (fluid.getType() == FluidTypes.WATER && iblockdata.getBlock() instanceof BlockFluids) {
+                    if (!flag) {
+                        return true;
+                    }
+
+                    boolean flag1 = iworldreader.A(blockposition.west()) && iworldreader.A(blockposition.east()) && iworldreader.A(blockposition.north()) && iworldreader.A(blockposition.south());
+
+                    if (!flag1) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    }
+
+    public boolean b(IWorldReader iworldreader, BlockPosition blockposition) {
+        if (this.getAdjustedTemperature(blockposition) >= 0.15F) {
+            return false;
+        } else {
+            if (blockposition.getY() >= 0 && blockposition.getY() < 256 && iworldreader.getBrightness(EnumSkyBlock.BLOCK, blockposition) < 10) {
+                IBlockData iblockdata = iworldreader.getType(blockposition);
+
+                if (iblockdata.isAir() && Blocks.SNOW.getBlockData().canPlace(iworldreader, blockposition)) {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+    }
+
+    public BiomeSettingsGeneration e() {
+        return this.k;
+    }
+
+    public void a(StructureManager structuremanager, ChunkGenerator chunkgenerator, RegionLimitedWorldAccess regionlimitedworldaccess, long i, SeededRandom seededrandom, BlockPosition blockposition) {
+        List<List<Supplier<WorldGenFeatureConfigured<?, ?>>>> list = this.k.c();
+        int j = WorldGenStage.Decoration.values().length;
+
+        for (int k = 0; k < j; ++k) {
+            int l = 0;
+
+            if (structuremanager.a()) {
+                List<StructureGenerator<?>> list1 = (List) this.g.getOrDefault(k, Collections.emptyList());
+
+                for (Iterator iterator = list1.iterator(); iterator.hasNext(); ++l) {
+                    StructureGenerator<?> structuregenerator = (StructureGenerator) iterator.next();
+
+                    seededrandom.b(i, l, k);
+                    int i1 = blockposition.getX() >> 4;
+                    int j1 = blockposition.getZ() >> 4;
+                    int k1 = i1 << 4;
+                    int l1 = j1 << 4;
+
+                    try {
+                        structuremanager.a(SectionPosition.a(blockposition), structuregenerator).forEach((structurestart) -> {
+                            structurestart.a(regionlimitedworldaccess, structuremanager, chunkgenerator, seededrandom, new StructureBoundingBox(k1, l1, k1 + 15, l1 + 15), new ChunkCoordIntPair(i1, j1));
+                        });
+                    } catch (Exception exception) {
+                        CrashReport crashreport = CrashReport.a(exception, "Feature placement");
+
+                        crashreport.a("Feature").a("Id", (Object) IRegistry.STRUCTURE_FEATURE.getKey(structuregenerator)).a("Description", () -> {
+                            return structuregenerator.toString();
+                        });
+                        throw new ReportedException(crashreport);
+                    }
+                }
+            }
+
+            if (list.size() > k) {
+                for (Iterator iterator1 = ((List) list.get(k)).iterator(); iterator1.hasNext(); ++l) {
+                    Supplier<WorldGenFeatureConfigured<?, ?>> supplier = (Supplier) iterator1.next();
+                    WorldGenFeatureConfigured<?, ?> worldgenfeatureconfigured = (WorldGenFeatureConfigured) supplier.get();
+
+                    seededrandom.b(i, l, k);
+
+                    try {
+                        worldgenfeatureconfigured.a(regionlimitedworldaccess, chunkgenerator, seededrandom, blockposition);
+                    } catch (Exception exception1) {
+                        CrashReport crashreport1 = CrashReport.a(exception1, "Feature placement");
+
+                        crashreport1.a("Feature").a("Id", (Object) IRegistry.FEATURE.getKey(worldgenfeatureconfigured.e)).a("Config", (Object) worldgenfeatureconfigured.f).a("Description", () -> {
+                            return worldgenfeatureconfigured.e.toString();
+                        });
+                        throw new ReportedException(crashreport1);
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(Random random, IChunkAccess ichunkaccess, int i, int j, int k, double d0, IBlockData iblockdata, IBlockData iblockdata1, int l, long i1) {
+        WorldGenSurfaceComposite<?> worldgensurfacecomposite = (WorldGenSurfaceComposite) this.k.d().get();
+
+        worldgensurfacecomposite.a(i1);
+        worldgensurfacecomposite.a(random, ichunkaccess, this, i, j, k, d0, iblockdata, iblockdata1, l, i1);
+    }
+
+    public final float h() {
+        return this.m;
+    }
+
+    public final float getHumidity() {
+        return this.j.e;
+    }
+
+    public final float j() {
+        return this.n;
+    }
+
+    public final float k() {
+        return this.j.c;
+    }
+
+    public BiomeFog l() {
+        return this.p;
+    }
+
+    public final BiomeBase.Geography t() {
+        return this.o;
+    }
+
+    public String toString() {
+        MinecraftKey minecraftkey = RegistryGeneration.WORLDGEN_BIOME.getKey(this);
+
+        return minecraftkey == null ? super.toString() : minecraftkey.toString();
+    }
+
+    static class d {
+
+        public static final MapCodec<BiomeBase.d> a = RecordCodecBuilder.mapCodec((instance) -> {
+            return instance.group(BiomeBase.Precipitation.d.fieldOf("precipitation").forGetter((biomebase_d) -> {
+                return biomebase_d.b;
+            }), Codec.FLOAT.fieldOf("temperature").forGetter((biomebase_d) -> {
+                return biomebase_d.c;
+            }), BiomeBase.TemperatureModifier.c.optionalFieldOf("temperature_modifier", BiomeBase.TemperatureModifier.NONE).forGetter((biomebase_d) -> {
+                return biomebase_d.d;
+            }), Codec.FLOAT.fieldOf("downfall").forGetter((biomebase_d) -> {
+                return biomebase_d.e;
+            })).apply(instance, BiomeBase.d::new);
+        });
+        private final BiomeBase.Precipitation b;
+        private final float c;
+        private final BiomeBase.TemperatureModifier d;
+        private final float e;
+
+        private d(BiomeBase.Precipitation biomebase_precipitation, float f, BiomeBase.TemperatureModifier biomebase_temperaturemodifier, float f1) {
+            this.b = biomebase_precipitation;
+            this.c = f;
+            this.d = biomebase_temperaturemodifier;
+            this.e = f1;
+        }
+    }
+
+    public static class c {
+
+        public static final Codec<BiomeBase.c> a = RecordCodecBuilder.create((instance) -> {
+            return instance.group(Codec.floatRange(-2.0F, 2.0F).fieldOf("temperature").forGetter((biomebase_c) -> {
+                return biomebase_c.b;
+            }), Codec.floatRange(-2.0F, 2.0F).fieldOf("humidity").forGetter((biomebase_c) -> {
+                return biomebase_c.c;
+            }), Codec.floatRange(-2.0F, 2.0F).fieldOf("altitude").forGetter((biomebase_c) -> {
+                return biomebase_c.d;
+            }), Codec.floatRange(-2.0F, 2.0F).fieldOf("weirdness").forGetter((biomebase_c) -> {
+                return biomebase_c.e;
+            }), Codec.floatRange(0.0F, 1.0F).fieldOf("offset").forGetter((biomebase_c) -> {
+                return biomebase_c.f;
+            })).apply(instance, BiomeBase.c::new);
+        });
+        private final float b;
+        private final float c;
+        private final float d;
+        private final float e;
+        private final float f;
+
+        public c(float f, float f1, float f2, float f3, float f4) {
+            this.b = f;
+            this.c = f1;
+            this.d = f2;
+            this.e = f3;
+            this.f = f4;
+        }
+
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            } else if (object != null && this.getClass() == object.getClass()) {
+                BiomeBase.c biomebase_c = (BiomeBase.c) object;
+
+                return Float.compare(biomebase_c.b, this.b) != 0 ? false : (Float.compare(biomebase_c.c, this.c) != 0 ? false : (Float.compare(biomebase_c.d, this.d) != 0 ? false : Float.compare(biomebase_c.e, this.e) == 0));
+            } else {
+                return false;
+            }
+        }
+
+        public int hashCode() {
+            int i = this.b != 0.0F ? Float.floatToIntBits(this.b) : 0;
+
+            i = 31 * i + (this.c != 0.0F ? Float.floatToIntBits(this.c) : 0);
+            i = 31 * i + (this.d != 0.0F ? Float.floatToIntBits(this.d) : 0);
+            i = 31 * i + (this.e != 0.0F ? Float.floatToIntBits(this.e) : 0);
+            return i;
+        }
+
+        public float a(BiomeBase.c biomebase_c) {
+            return (this.b - biomebase_c.b) * (this.b - biomebase_c.b) + (this.c - biomebase_c.c) * (this.c - biomebase_c.c) + (this.d - biomebase_c.d) * (this.d - biomebase_c.d) + (this.e - biomebase_c.e) * (this.e - biomebase_c.e) + (this.f - biomebase_c.f) * (this.f - biomebase_c.f);
+        }
+    }
+
+    public static class a {
+
+        @Nullable
+        private BiomeBase.Precipitation a;
+        @Nullable
+        private BiomeBase.Geography b;
+        @Nullable
+        private Float c;
+        @Nullable
+        private Float d;
+        @Nullable
+        private Float e;
+        private BiomeBase.TemperatureModifier f;
+        @Nullable
+        private Float g;
+        @Nullable
+        private BiomeFog h;
+        @Nullable
+        private BiomeSettingsMobs i;
+        @Nullable
+        private BiomeSettingsGeneration j;
+
+        public a() {
+            this.f = BiomeBase.TemperatureModifier.NONE;
+        }
+
+        public BiomeBase.a a(BiomeBase.Precipitation biomebase_precipitation) {
+            this.a = biomebase_precipitation;
+            return this;
+        }
+
+        public BiomeBase.a a(BiomeBase.Geography biomebase_geography) {
+            this.b = biomebase_geography;
+            return this;
+        }
+
+        public BiomeBase.a a(float f) {
+            this.c = f;
+            return this;
+        }
+
+        public BiomeBase.a b(float f) {
+            this.d = f;
+            return this;
+        }
+
+        public BiomeBase.a c(float f) {
+            this.e = f;
+            return this;
+        }
+
+        public BiomeBase.a d(float f) {
+            this.g = f;
+            return this;
+        }
+
+        public BiomeBase.a a(BiomeFog biomefog) {
+            this.h = biomefog;
+            return this;
+        }
+
+        public BiomeBase.a a(BiomeSettingsMobs biomesettingsmobs) {
+            this.i = biomesettingsmobs;
+            return this;
+        }
+
+        public BiomeBase.a a(BiomeSettingsGeneration biomesettingsgeneration) {
+            this.j = biomesettingsgeneration;
+            return this;
+        }
+
+        public BiomeBase.a a(BiomeBase.TemperatureModifier biomebase_temperaturemodifier) {
+            this.f = biomebase_temperaturemodifier;
+            return this;
+        }
+
+        public BiomeBase a() {
+            if (this.a != null && this.b != null && this.c != null && this.d != null && this.e != null && this.g != null && this.h != null && this.i != null && this.j != null) {
+                return new BiomeBase(new BiomeBase.d(this.a, this.e, this.f, this.g), this.b, this.c, this.d, this.h, this.j, this.i);
+            } else {
+                throw new IllegalStateException("You are missing parameters to build a proper biome\n" + this);
+            }
+        }
+
+        public String toString() {
+            return "BiomeBuilder{\nprecipitation=" + this.a + ",\nbiomeCategory=" + this.b + ",\ndepth=" + this.c + ",\nscale=" + this.d + ",\ntemperature=" + this.e + ",\ntemperatureModifier=" + this.f + ",\ndownfall=" + this.g + ",\nspecialEffects=" + this.h + ",\nmobSpawnSettings=" + this.i + ",\ngenerationSettings=" + this.j + ",\n" + '}';
+        }
+    }
+
+    public static enum TemperatureModifier implements INamable {
+
+        NONE("none") {
+            @Override
+            public float a(BlockPosition blockposition, float f) {
+                return f;
+            }
+        },
+        FROZEN("frozen") {
+            @Override
+            public float a(BlockPosition blockposition, float f) {
+                double d0 = BiomeBase.i.a((double) blockposition.getX() * 0.05D, (double) blockposition.getZ() * 0.05D, false) * 7.0D;
+                double d1 = BiomeBase.f.a((double) blockposition.getX() * 0.2D, (double) blockposition.getZ() * 0.2D, false);
+                double d2 = d0 + d1;
+
+                if (d2 < 0.3D) {
+                    double d3 = BiomeBase.f.a((double) blockposition.getX() * 0.09D, (double) blockposition.getZ() * 0.09D, false);
+
+                    if (d3 < 0.8D) {
+                        return 0.2F;
+                    }
+                }
+
+                return f;
+            }
+        };
+
+        private final String d;
+        public static final Codec<BiomeBase.TemperatureModifier> c = INamable.a(BiomeBase.TemperatureModifier::values, BiomeBase.TemperatureModifier::a);
+        private static final Map<String, BiomeBase.TemperatureModifier> e = (Map) Arrays.stream(values()).collect(Collectors.toMap(BiomeBase.TemperatureModifier::b, (biomebase_temperaturemodifier) -> {
+            return biomebase_temperaturemodifier;
+        }));
+
+        public abstract float a(BlockPosition blockposition, float f);
+
+        private TemperatureModifier(String s) {
+            this.d = s;
+        }
+
+        public String b() {
+            return this.d;
+        }
+
+        @Override
+        public String getName() {
+            return this.d;
+        }
+
+        public static BiomeBase.TemperatureModifier a(String s) {
+            return (BiomeBase.TemperatureModifier) BiomeBase.TemperatureModifier.e.get(s);
+        }
+    }
+
+    public static enum Precipitation implements INamable {
+
+        NONE("none"), RAIN("rain"), SNOW("snow");
+
+        public static final Codec<BiomeBase.Precipitation> d = INamable.a(BiomeBase.Precipitation::values, BiomeBase.Precipitation::a);
+        private static final Map<String, BiomeBase.Precipitation> e = (Map) Arrays.stream(values()).collect(Collectors.toMap(BiomeBase.Precipitation::b, (biomebase_precipitation) -> {
+            return biomebase_precipitation;
+        }));
+        private final String f;
+
+        private Precipitation(String s) {
+            this.f = s;
+        }
+
+        public String b() {
+            return this.f;
+        }
+
+        public static BiomeBase.Precipitation a(String s) {
+            return (BiomeBase.Precipitation) BiomeBase.Precipitation.e.get(s);
+        }
+
+        @Override
+        public String getName() {
+            return this.f;
+        }
+    }
+
+    public static enum Geography implements INamable {
+
+        NONE("none"), TAIGA("taiga"), EXTREME_HILLS("extreme_hills"), JUNGLE("jungle"), MESA("mesa"), PLAINS("plains"), SAVANNA("savanna"), ICY("icy"), THEEND("the_end"), BEACH("beach"), FOREST("forest"), OCEAN("ocean"), DESERT("desert"), RIVER("river"), SWAMP("swamp"), MUSHROOM("mushroom"), NETHER("nether");
+
+        public static final Codec<BiomeBase.Geography> r = INamable.a(BiomeBase.Geography::values, BiomeBase.Geography::a);
+        private static final Map<String, BiomeBase.Geography> s = (Map) Arrays.stream(values()).collect(Collectors.toMap(BiomeBase.Geography::b, (biomebase_geography) -> {
+            return biomebase_geography;
+        }));
+        private final String t;
+
+        private Geography(String s) {
+            this.t = s;
+        }
+
+        public String b() {
+            return this.t;
+        }
+
+        public static BiomeBase.Geography a(String s) {
+            return (BiomeBase.Geography) BiomeBase.Geography.s.get(s);
+        }
+
+        @Override
+        public String getName() {
+            return this.t;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/biome/BiomeManager.java b/src/main/java/net/minecraft/world/level/biome/BiomeManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..340508e0ba8b8883a3037ecaa2d4e09e61e709d3
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/biome/BiomeManager.java
@@ -0,0 +1,34 @@
+package net.minecraft.world.level.biome;
+
+import com.google.common.hash.Hashing;
+import net.minecraft.core.BlockPosition;
+
+public class BiomeManager {
+
+    private final BiomeManager.Provider a;
+    private final long b;
+    private final GenLayerZoomer c;
+
+    public BiomeManager(BiomeManager.Provider biomemanager_provider, long i, GenLayerZoomer genlayerzoomer) {
+        this.a = biomemanager_provider;
+        this.b = i;
+        this.c = genlayerzoomer;
+    }
+
+    public static long a(long i) {
+        return Hashing.sha256().hashLong(i).asLong();
+    }
+
+    public BiomeManager a(WorldChunkManager worldchunkmanager) {
+        return new BiomeManager(worldchunkmanager, this.b, this.c);
+    }
+
+    public BiomeBase a(BlockPosition blockposition) {
+        return this.c.a(this.b, blockposition.getX(), blockposition.getY(), blockposition.getZ(), this.a);
+    }
+
+    public interface Provider {
+
+        BiomeBase getBiome(int i, int j, int k);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/biome/BiomeSettingsMobs.java b/src/main/java/net/minecraft/world/level/biome/BiomeSettingsMobs.java
new file mode 100644
index 0000000000000000000000000000000000000000..5adaf5fdaaec25220878213df2c0839ccf025d63
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/biome/BiomeSettingsMobs.java
@@ -0,0 +1,171 @@
+package net.minecraft.world.level.biome;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.MapCodec;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.IRegistry;
+import net.minecraft.util.INamable;
+import net.minecraft.util.WeightedRandom;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.EnumCreatureType;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class BiomeSettingsMobs {
+
+    public static final Logger LOGGER = LogManager.getLogger();
+    public static final BiomeSettingsMobs b = new BiomeSettingsMobs(0.1F, (Map) Stream.of(EnumCreatureType.values()).collect(ImmutableMap.toImmutableMap((enumcreaturetype) -> {
+        return enumcreaturetype;
+    }, (enumcreaturetype) -> {
+        return ImmutableList.of();
+    })), ImmutableMap.of(), false);
+    public static final MapCodec<BiomeSettingsMobs> c = RecordCodecBuilder.mapCodec((instance) -> {
+        RecordCodecBuilder recordcodecbuilder = Codec.FLOAT.optionalFieldOf("creature_spawn_probability", 0.1F).forGetter((biomesettingsmobs) -> {
+            return biomesettingsmobs.d;
+        });
+        Codec codec = EnumCreatureType.g;
+        Codec codec1 = BiomeSettingsMobs.c.b.listOf();
+        Logger logger = BiomeSettingsMobs.LOGGER;
+
+        logger.getClass();
+        return instance.group(recordcodecbuilder, Codec.simpleMap(codec, codec1.promotePartial(SystemUtils.a("Spawn data: ", logger::error)), INamable.a(EnumCreatureType.values())).fieldOf("spawners").forGetter((biomesettingsmobs) -> {
+            return biomesettingsmobs.e;
+        }), Codec.simpleMap(IRegistry.ENTITY_TYPE, BiomeSettingsMobs.b.a, IRegistry.ENTITY_TYPE).fieldOf("spawn_costs").forGetter((biomesettingsmobs) -> {
+            return biomesettingsmobs.f;
+        }), Codec.BOOL.fieldOf("player_spawn_friendly").orElse(false).forGetter(BiomeSettingsMobs::b)).apply(instance, BiomeSettingsMobs::new);
+    });
+    private final float d;
+    private final Map<EnumCreatureType, List<BiomeSettingsMobs.c>> e;
+    private final Map<EntityTypes<?>, BiomeSettingsMobs.b> f;
+    private final boolean g;
+
+    private BiomeSettingsMobs(float f, Map<EnumCreatureType, List<BiomeSettingsMobs.c>> map, Map<EntityTypes<?>, BiomeSettingsMobs.b> map1, boolean flag) {
+        this.d = f;
+        this.e = map;
+        this.f = map1;
+        this.g = flag;
+    }
+
+    public List<BiomeSettingsMobs.c> a(EnumCreatureType enumcreaturetype) {
+        return (List) this.e.getOrDefault(enumcreaturetype, ImmutableList.of());
+    }
+
+    @Nullable
+    public BiomeSettingsMobs.b a(EntityTypes<?> entitytypes) {
+        return (BiomeSettingsMobs.b) this.f.get(entitytypes);
+    }
+
+    public float a() {
+        return this.d;
+    }
+
+    public boolean b() {
+        return this.g;
+    }
+
+    public static class a {
+
+        private final Map<EnumCreatureType, List<BiomeSettingsMobs.c>> a = (Map) Stream.of(EnumCreatureType.values()).collect(ImmutableMap.toImmutableMap((enumcreaturetype) -> {
+            return enumcreaturetype;
+        }, (enumcreaturetype) -> {
+            return Lists.newArrayList();
+        }));
+        private final Map<EntityTypes<?>, BiomeSettingsMobs.b> b = Maps.newLinkedHashMap();
+        private float c = 0.1F;
+        private boolean d;
+
+        public a() {}
+
+        public BiomeSettingsMobs.a a(EnumCreatureType enumcreaturetype, BiomeSettingsMobs.c biomesettingsmobs_c) {
+            ((List) this.a.get(enumcreaturetype)).add(biomesettingsmobs_c);
+            return this;
+        }
+
+        public BiomeSettingsMobs.a a(EntityTypes<?> entitytypes, double d0, double d1) {
+            this.b.put(entitytypes, new BiomeSettingsMobs.b(d1, d0));
+            return this;
+        }
+
+        public BiomeSettingsMobs.a a(float f) {
+            this.c = f;
+            return this;
+        }
+
+        public BiomeSettingsMobs.a a() {
+            this.d = true;
+            return this;
+        }
+
+        public BiomeSettingsMobs b() {
+            return new BiomeSettingsMobs(this.c, (Map) this.a.entrySet().stream().collect(ImmutableMap.toImmutableMap(Entry::getKey, (entry) -> {
+                return ImmutableList.copyOf((Collection) entry.getValue());
+            })), ImmutableMap.copyOf(this.b), this.d);
+        }
+    }
+
+    public static class b {
+
+        public static final Codec<BiomeSettingsMobs.b> a = RecordCodecBuilder.create((instance) -> {
+            return instance.group(Codec.DOUBLE.fieldOf("energy_budget").forGetter((biomesettingsmobs_b) -> {
+                return biomesettingsmobs_b.b;
+            }), Codec.DOUBLE.fieldOf("charge").forGetter((biomesettingsmobs_b) -> {
+                return biomesettingsmobs_b.c;
+            })).apply(instance, BiomeSettingsMobs.b::new);
+        });
+        private final double b;
+        private final double c;
+
+        private b(double d0, double d1) {
+            this.b = d0;
+            this.c = d1;
+        }
+
+        public double a() {
+            return this.b;
+        }
+
+        public double b() {
+            return this.c;
+        }
+    }
+
+    public static class c extends WeightedRandom.WeightedRandomChoice {
+
+        public static final Codec<BiomeSettingsMobs.c> b = RecordCodecBuilder.create((instance) -> {
+            return instance.group(IRegistry.ENTITY_TYPE.fieldOf("type").forGetter((biomesettingsmobs_c) -> {
+                return biomesettingsmobs_c.c;
+            }), Codec.INT.fieldOf("weight").forGetter((biomesettingsmobs_c) -> {
+                return biomesettingsmobs_c.a;
+            }), Codec.INT.fieldOf("minCount").forGetter((biomesettingsmobs_c) -> {
+                return biomesettingsmobs_c.d;
+            }), Codec.INT.fieldOf("maxCount").forGetter((biomesettingsmobs_c) -> {
+                return biomesettingsmobs_c.e;
+            })).apply(instance, BiomeSettingsMobs.c::new);
+        });
+        public final EntityTypes<?> c;
+        public final int d;
+        public final int e;
+
+        public c(EntityTypes<?> entitytypes, int i, int j, int k) {
+            super(i);
+            this.c = entitytypes.e() == EnumCreatureType.MISC ? EntityTypes.PIG : entitytypes;
+            this.d = j;
+            this.e = k;
+        }
+
+        public String toString() {
+            return EntityTypes.getName(this.c) + "*(" + this.d + "-" + this.e + "):" + this.a;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/biome/WorldChunkManagerTheEnd.java b/src/main/java/net/minecraft/world/level/biome/WorldChunkManagerTheEnd.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d46e2c4e06cfe32eac06223e1966ce39c41685e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/biome/WorldChunkManagerTheEnd.java
@@ -0,0 +1,101 @@
+package net.minecraft.world.level.biome;
+
+import com.google.common.collect.ImmutableList;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import java.util.List;
+import net.minecraft.core.IRegistry;
+import net.minecraft.resources.RegistryLookupCodec;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.level.levelgen.SeededRandom;
+import net.minecraft.world.level.levelgen.synth.NoiseGenerator3Handler;
+
+public class WorldChunkManagerTheEnd extends WorldChunkManager {
+
+    public static final Codec<WorldChunkManagerTheEnd> e = RecordCodecBuilder.create((instance) -> {
+        return instance.group(RegistryLookupCodec.a(IRegistry.ay).forGetter((worldchunkmanagertheend) -> {
+            return worldchunkmanagertheend.g;
+        }), Codec.LONG.fieldOf("seed").stable().forGetter((worldchunkmanagertheend) -> {
+            return worldchunkmanagertheend.h;
+        })).apply(instance, instance.stable(WorldChunkManagerTheEnd::new));
+    });
+    private final NoiseGenerator3Handler f;
+    private final IRegistry<BiomeBase> g;
+    private final long h;
+    private final BiomeBase i;
+    private final BiomeBase j;
+    private final BiomeBase k;
+    private final BiomeBase l;
+    private final BiomeBase m;
+
+    public WorldChunkManagerTheEnd(IRegistry<BiomeBase> iregistry, long i) {
+        this(iregistry, i, (BiomeBase) iregistry.d(Biomes.THE_END), (BiomeBase) iregistry.d(Biomes.END_HIGHLANDS), (BiomeBase) iregistry.d(Biomes.END_MIDLANDS), (BiomeBase) iregistry.d(Biomes.SMALL_END_ISLANDS), (BiomeBase) iregistry.d(Biomes.END_BARRENS));
+    }
+
+    private WorldChunkManagerTheEnd(IRegistry<BiomeBase> iregistry, long i, BiomeBase biomebase, BiomeBase biomebase1, BiomeBase biomebase2, BiomeBase biomebase3, BiomeBase biomebase4) {
+        super((List) ImmutableList.of(biomebase, biomebase1, biomebase2, biomebase3, biomebase4));
+        this.g = iregistry;
+        this.h = i;
+        this.i = biomebase;
+        this.j = biomebase1;
+        this.k = biomebase2;
+        this.l = biomebase3;
+        this.m = biomebase4;
+        SeededRandom seededrandom = new SeededRandom(i);
+
+        seededrandom.a(17292);
+        this.f = new NoiseGenerator3Handler(seededrandom);
+    }
+
+    @Override
+    protected Codec<? extends WorldChunkManager> a() {
+        return WorldChunkManagerTheEnd.e;
+    }
+
+    @Override
+    public BiomeBase getBiome(int i, int j, int k) {
+        int l = i >> 2;
+        int i1 = k >> 2;
+
+        if ((long) l * (long) l + (long) i1 * (long) i1 <= 4096L) {
+            return this.i;
+        } else {
+            float f = a(this.f, l * 2 + 1, i1 * 2 + 1);
+
+            return f > 40.0F ? this.j : (f >= 0.0F ? this.k : (f < -20.0F ? this.l : this.m));
+        }
+    }
+
+    public boolean b(long i) {
+        return this.h == i;
+    }
+
+    public static float a(NoiseGenerator3Handler noisegenerator3handler, int i, int j) {
+        int k = i / 2;
+        int l = j / 2;
+        int i1 = i % 2;
+        int j1 = j % 2;
+        float f = 100.0F - MathHelper.c((float) (i * i + j * j)) * 8.0F;
+
+        f = MathHelper.a(f, -100.0F, 80.0F);
+
+        for (int k1 = -12; k1 <= 12; ++k1) {
+            for (int l1 = -12; l1 <= 12; ++l1) {
+                long i2 = (long) (k + k1);
+                long j2 = (long) (l + l1);
+
+                if (i2 * i2 + j2 * j2 > 4096L && noisegenerator3handler.a((double) i2, (double) j2) < -0.8999999761581421D) {
+                    float f1 = (MathHelper.e((float) i2) * 3439.0F + MathHelper.e((float) j2) * 147.0F) % 13.0F + 9.0F;
+                    float f2 = (float) (i1 - k1 * 2);
+                    float f3 = (float) (j1 - l1 * 2);
+                    float f4 = 100.0F - MathHelper.c(f2 * f2 + f3 * f3) * f1;
+
+                    f4 = MathHelper.a(f4, -100.0F, 80.0F);
+                    f = Math.max(f, f4);
+                }
+            }
+        }
+
+        return f;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/BlockBell.java b/src/main/java/net/minecraft/world/level/block/BlockBell.java
new file mode 100644
index 0000000000000000000000000000000000000000..687f7acd8254294b568c9adf3e72d02d12551381
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/BlockBell.java
@@ -0,0 +1,256 @@
+package net.minecraft.world.level.block;
+
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.stats.StatisticList;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.EnumInteractionResult;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.projectile.IProjectile;
+import net.minecraft.world.item.context.BlockActionContext;
+import net.minecraft.world.level.GeneratorAccess;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.IWorldReader;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.entity.TileEntityBell;
+import net.minecraft.world.level.block.state.BlockBase;
+import net.minecraft.world.level.block.state.BlockStateList;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.properties.BlockProperties;
+import net.minecraft.world.level.block.state.properties.BlockPropertyBellAttach;
+import net.minecraft.world.level.block.state.properties.BlockStateBoolean;
+import net.minecraft.world.level.block.state.properties.BlockStateDirection;
+import net.minecraft.world.level.block.state.properties.BlockStateEnum;
+import net.minecraft.world.level.material.EnumPistonReaction;
+import net.minecraft.world.level.pathfinder.PathMode;
+import net.minecraft.world.phys.MovingObjectPositionBlock;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapeCollision;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+
+public class BlockBell extends BlockTileEntity {
+
+    public static final BlockStateDirection a = BlockFacingHorizontal.FACING;
+    public static final BlockStateEnum<BlockPropertyBellAttach> b = BlockProperties.R;
+    public static final BlockStateBoolean c = BlockProperties.w;
+    private static final VoxelShape d = Block.a(0.0D, 0.0D, 4.0D, 16.0D, 16.0D, 12.0D);
+    private static final VoxelShape e = Block.a(4.0D, 0.0D, 0.0D, 12.0D, 16.0D, 16.0D);
+    private static final VoxelShape f = Block.a(5.0D, 6.0D, 5.0D, 11.0D, 13.0D, 11.0D);
+    private static final VoxelShape g = Block.a(4.0D, 4.0D, 4.0D, 12.0D, 6.0D, 12.0D);
+    private static final VoxelShape h = VoxelShapes.a(BlockBell.g, BlockBell.f);
+    private static final VoxelShape i = VoxelShapes.a(BlockBell.h, Block.a(7.0D, 13.0D, 0.0D, 9.0D, 15.0D, 16.0D));
+    private static final VoxelShape j = VoxelShapes.a(BlockBell.h, Block.a(0.0D, 13.0D, 7.0D, 16.0D, 15.0D, 9.0D));
+    private static final VoxelShape k = VoxelShapes.a(BlockBell.h, Block.a(0.0D, 13.0D, 7.0D, 13.0D, 15.0D, 9.0D));
+    private static final VoxelShape o = VoxelShapes.a(BlockBell.h, Block.a(3.0D, 13.0D, 7.0D, 16.0D, 15.0D, 9.0D));
+    private static final VoxelShape p = VoxelShapes.a(BlockBell.h, Block.a(7.0D, 13.0D, 0.0D, 9.0D, 15.0D, 13.0D));
+    private static final VoxelShape q = VoxelShapes.a(BlockBell.h, Block.a(7.0D, 13.0D, 3.0D, 9.0D, 15.0D, 16.0D));
+    private static final VoxelShape r = VoxelShapes.a(BlockBell.h, Block.a(7.0D, 13.0D, 7.0D, 9.0D, 16.0D, 9.0D));
+
+    public BlockBell(BlockBase.Info blockbase_info) {
+        super(blockbase_info);
+        this.j((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) this.blockStateList.getBlockData()).set(BlockBell.a, EnumDirection.NORTH)).set(BlockBell.b, BlockPropertyBellAttach.FLOOR)).set(BlockBell.c, false));
+    }
+
+    @Override
+    public void doPhysics(IBlockData iblockdata, World world, BlockPosition blockposition, Block block, BlockPosition blockposition1, boolean flag) {
+        boolean flag1 = world.isBlockIndirectlyPowered(blockposition);
+
+        if (flag1 != (Boolean) iblockdata.get(BlockBell.c)) {
+            if (flag1) {
+                this.a(world, blockposition, (EnumDirection) null);
+            }
+
+            world.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockBell.c, flag1), 3);
+        }
+
+    }
+
+    @Override
+    public void a(World world, IBlockData iblockdata, MovingObjectPositionBlock movingobjectpositionblock, IProjectile iprojectile) {
+        Entity entity = iprojectile.getShooter();
+        EntityHuman entityhuman = entity instanceof EntityHuman ? (EntityHuman) entity : null;
+
+        this.a(world, iblockdata, movingobjectpositionblock, entityhuman, true);
+    }
+
+    @Override
+    public EnumInteractionResult interact(IBlockData iblockdata, World world, BlockPosition blockposition, EntityHuman entityhuman, EnumHand enumhand, MovingObjectPositionBlock movingobjectpositionblock) {
+        return this.a(world, iblockdata, movingobjectpositionblock, entityhuman, true) ? EnumInteractionResult.a(world.isClientSide) : EnumInteractionResult.PASS;
+    }
+
+    public boolean a(World world, IBlockData iblockdata, MovingObjectPositionBlock movingobjectpositionblock, @Nullable EntityHuman entityhuman, boolean flag) {
+        EnumDirection enumdirection = movingobjectpositionblock.getDirection();
+        BlockPosition blockposition = movingobjectpositionblock.getBlockPosition();
+        boolean flag1 = !flag || this.a(iblockdata, enumdirection, movingobjectpositionblock.getPos().y - (double) blockposition.getY());
+
+        if (flag1) {
+            boolean flag2 = this.a(world, blockposition, enumdirection);
+
+            if (flag2 && entityhuman != null) {
+                entityhuman.a(StatisticList.BELL_RING);
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean a(IBlockData iblockdata, EnumDirection enumdirection, double d0) {
+        if (enumdirection.n() != EnumDirection.EnumAxis.Y && d0 <= 0.8123999834060669D) {
+            EnumDirection enumdirection1 = (EnumDirection) iblockdata.get(BlockBell.a);
+            BlockPropertyBellAttach blockpropertybellattach = (BlockPropertyBellAttach) iblockdata.get(BlockBell.b);
+
+            switch (blockpropertybellattach) {
+                case FLOOR:
+                    return enumdirection1.n() == enumdirection.n();
+                case SINGLE_WALL:
+                case DOUBLE_WALL:
+                    return enumdirection1.n() != enumdirection.n();
+                case CEILING:
+                    return true;
+                default:
+                    return false;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    public boolean a(World world, BlockPosition blockposition, @Nullable EnumDirection enumdirection) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (!world.isClientSide && tileentity instanceof TileEntityBell) {
+            if (enumdirection == null) {
+                enumdirection = (EnumDirection) world.getType(blockposition).get(BlockBell.a);
+            }
+
+            ((TileEntityBell) tileentity).a(enumdirection);
+            world.playSound((EntityHuman) null, blockposition, SoundEffects.BLOCK_BELL_USE, SoundCategory.BLOCKS, 2.0F, 1.0F);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private VoxelShape h(IBlockData iblockdata) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockBell.a);
+        BlockPropertyBellAttach blockpropertybellattach = (BlockPropertyBellAttach) iblockdata.get(BlockBell.b);
+
+        return blockpropertybellattach == BlockPropertyBellAttach.FLOOR ? (enumdirection != EnumDirection.NORTH && enumdirection != EnumDirection.SOUTH ? BlockBell.e : BlockBell.d) : (blockpropertybellattach == BlockPropertyBellAttach.CEILING ? BlockBell.r : (blockpropertybellattach == BlockPropertyBellAttach.DOUBLE_WALL ? (enumdirection != EnumDirection.NORTH && enumdirection != EnumDirection.SOUTH ? BlockBell.j : BlockBell.i) : (enumdirection == EnumDirection.NORTH ? BlockBell.p : (enumdirection == EnumDirection.SOUTH ? BlockBell.q : (enumdirection == EnumDirection.EAST ? BlockBell.o : BlockBell.k)))));
+    }
+
+    @Override
+    public VoxelShape c(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
+        return this.h(iblockdata);
+    }
+
+    @Override
+    public VoxelShape b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
+        return this.h(iblockdata);
+    }
+
+    @Override
+    public EnumRenderType b(IBlockData iblockdata) {
+        return EnumRenderType.MODEL;
+    }
+
+    @Nullable
+    @Override
+    public IBlockData getPlacedState(BlockActionContext blockactioncontext) {
+        EnumDirection enumdirection = blockactioncontext.getClickedFace();
+        BlockPosition blockposition = blockactioncontext.getClickPosition();
+        World world = blockactioncontext.getWorld();
+        EnumDirection.EnumAxis enumdirection_enumaxis = enumdirection.n();
+        IBlockData iblockdata;
+
+        if (enumdirection_enumaxis == EnumDirection.EnumAxis.Y) {
+            iblockdata = (IBlockData) ((IBlockData) this.getBlockData().set(BlockBell.b, enumdirection == EnumDirection.DOWN ? BlockPropertyBellAttach.CEILING : BlockPropertyBellAttach.FLOOR)).set(BlockBell.a, blockactioncontext.f());
+            if (iblockdata.canPlace(blockactioncontext.getWorld(), blockposition)) {
+                return iblockdata;
+            }
+        } else {
+            boolean flag = enumdirection_enumaxis == EnumDirection.EnumAxis.X && world.getType(blockposition.west()).d(world, blockposition.west(), EnumDirection.EAST) && world.getType(blockposition.east()).d(world, blockposition.east(), EnumDirection.WEST) || enumdirection_enumaxis == EnumDirection.EnumAxis.Z && world.getType(blockposition.north()).d(world, blockposition.north(), EnumDirection.SOUTH) && world.getType(blockposition.south()).d(world, blockposition.south(), EnumDirection.NORTH);
+
+            iblockdata = (IBlockData) ((IBlockData) this.getBlockData().set(BlockBell.a, enumdirection.opposite())).set(BlockBell.b, flag ? BlockPropertyBellAttach.DOUBLE_WALL : BlockPropertyBellAttach.SINGLE_WALL);
+            if (iblockdata.canPlace(blockactioncontext.getWorld(), blockactioncontext.getClickPosition())) {
+                return iblockdata;
+            }
+
+            boolean flag1 = world.getType(blockposition.down()).d(world, blockposition.down(), EnumDirection.UP);
+
+            iblockdata = (IBlockData) iblockdata.set(BlockBell.b, flag1 ? BlockPropertyBellAttach.FLOOR : BlockPropertyBellAttach.CEILING);
+            if (iblockdata.canPlace(blockactioncontext.getWorld(), blockactioncontext.getClickPosition())) {
+                return iblockdata;
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public IBlockData updateState(IBlockData iblockdata, EnumDirection enumdirection, IBlockData iblockdata1, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
+        BlockPropertyBellAttach blockpropertybellattach = (BlockPropertyBellAttach) iblockdata.get(BlockBell.b);
+        EnumDirection enumdirection1 = l(iblockdata).opposite();
+
+        if (enumdirection1 == enumdirection && !iblockdata.canPlace(generatoraccess, blockposition) && blockpropertybellattach != BlockPropertyBellAttach.DOUBLE_WALL) {
+            return Blocks.AIR.getBlockData();
+        } else {
+            if (enumdirection.n() == ((EnumDirection) iblockdata.get(BlockBell.a)).n()) {
+                if (blockpropertybellattach == BlockPropertyBellAttach.DOUBLE_WALL && !iblockdata1.d(generatoraccess, blockposition1, enumdirection)) {
+                    return (IBlockData) ((IBlockData) iblockdata.set(BlockBell.b, BlockPropertyBellAttach.SINGLE_WALL)).set(BlockBell.a, enumdirection.opposite());
+                }
+
+                if (blockpropertybellattach == BlockPropertyBellAttach.SINGLE_WALL && enumdirection1.opposite() == enumdirection && iblockdata1.d(generatoraccess, blockposition1, (EnumDirection) iblockdata.get(BlockBell.a))) {
+                    return (IBlockData) iblockdata.set(BlockBell.b, BlockPropertyBellAttach.DOUBLE_WALL);
+                }
+            }
+
+            return super.updateState(iblockdata, enumdirection, iblockdata1, generatoraccess, blockposition, blockposition1);
+        }
+    }
+
+    @Override
+    public boolean canPlace(IBlockData iblockdata, IWorldReader iworldreader, BlockPosition blockposition) {
+        EnumDirection enumdirection = l(iblockdata).opposite();
+
+        return enumdirection == EnumDirection.UP ? Block.a(iworldreader, blockposition.up(), EnumDirection.DOWN) : BlockAttachable.b(iworldreader, blockposition, enumdirection);
+    }
+
+    private static EnumDirection l(IBlockData iblockdata) {
+        switch ((BlockPropertyBellAttach) iblockdata.get(BlockBell.b)) {
+            case FLOOR:
+                return EnumDirection.UP;
+            case CEILING:
+                return EnumDirection.DOWN;
+            default:
+                return ((EnumDirection) iblockdata.get(BlockBell.a)).opposite();
+        }
+    }
+
+    @Override
+    public EnumPistonReaction getPushReaction(IBlockData iblockdata) {
+        return EnumPistonReaction.DESTROY;
+    }
+
+    @Override
+    protected void a(BlockStateList.a<Block, IBlockData> blockstatelist_a) {
+        blockstatelist_a.a(BlockBell.a, BlockBell.b, BlockBell.c);
+    }
+
+    @Nullable
+    @Override
+    public TileEntity createTile(IBlockAccess iblockaccess) {
+        return new TileEntityBell();
+    }
+
+    @Override
+    public boolean a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, PathMode pathmode) {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/BlockFlowerPot.java b/src/main/java/net/minecraft/world/level/block/BlockFlowerPot.java
new file mode 100644
index 0000000000000000000000000000000000000000..a61d1ffeebfd00a5fcd5faf95200b0640da8ea82
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/BlockFlowerPot.java
@@ -0,0 +1,92 @@
+package net.minecraft.world.level.block;
+
+import com.google.common.collect.Maps;
+import java.util.Map;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.stats.StatisticList;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.EnumInteractionResult;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemBlock;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.GeneratorAccess;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.state.BlockBase;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.pathfinder.PathMode;
+import net.minecraft.world.phys.MovingObjectPositionBlock;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapeCollision;
+
+public class BlockFlowerPot extends Block {
+
+    private static final Map<Block, Block> b = Maps.newHashMap();
+    protected static final VoxelShape a = Block.a(5.0D, 0.0D, 5.0D, 11.0D, 6.0D, 11.0D);
+    private final Block c;
+
+    public BlockFlowerPot(Block block, BlockBase.Info blockbase_info) {
+        super(blockbase_info);
+        this.c = block;
+        BlockFlowerPot.b.put(block, this);
+    }
+
+    @Override
+    public VoxelShape b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
+        return BlockFlowerPot.a;
+    }
+
+    @Override
+    public EnumRenderType b(IBlockData iblockdata) {
+        return EnumRenderType.MODEL;
+    }
+
+    @Override
+    public EnumInteractionResult interact(IBlockData iblockdata, World world, BlockPosition blockposition, EntityHuman entityhuman, EnumHand enumhand, MovingObjectPositionBlock movingobjectpositionblock) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+        Item item = itemstack.getItem();
+        Block block = item instanceof ItemBlock ? (Block) BlockFlowerPot.b.getOrDefault(((ItemBlock) item).getBlock(), Blocks.AIR) : Blocks.AIR;
+        boolean flag = block == Blocks.AIR;
+        boolean flag1 = this.c == Blocks.AIR;
+
+        if (flag != flag1) {
+            if (flag1) {
+                world.setTypeAndData(blockposition, block.getBlockData(), 3);
+                entityhuman.a(StatisticList.POT_FLOWER);
+                if (!entityhuman.abilities.canInstantlyBuild) {
+                    itemstack.subtract(1);
+                }
+            } else {
+                ItemStack itemstack1 = new ItemStack(this.c);
+
+                if (itemstack.isEmpty()) {
+                    entityhuman.a(enumhand, itemstack1);
+                } else if (!entityhuman.g(itemstack1)) {
+                    entityhuman.drop(itemstack1, false);
+                }
+
+                world.setTypeAndData(blockposition, Blocks.FLOWER_POT.getBlockData(), 3);
+            }
+
+            return EnumInteractionResult.a(world.isClientSide);
+        } else {
+            return EnumInteractionResult.CONSUME;
+        }
+    }
+
+    @Override
+    public IBlockData updateState(IBlockData iblockdata, EnumDirection enumdirection, IBlockData iblockdata1, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
+        return enumdirection == EnumDirection.DOWN && !iblockdata.canPlace(generatoraccess, blockposition) ? Blocks.AIR.getBlockData() : super.updateState(iblockdata, enumdirection, iblockdata1, generatoraccess, blockposition, blockposition1);
+    }
+
+    public Block c() {
+        return this.c;
+    }
+
+    @Override
+    public boolean a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, PathMode pathmode) {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/BlockIceFrost.java b/src/main/java/net/minecraft/world/level/block/BlockIceFrost.java
new file mode 100644
index 0000000000000000000000000000000000000000..7239a30bd4a5dc4ed09802eea8f7126485ebb635
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/BlockIceFrost.java
@@ -0,0 +1,100 @@
+package net.minecraft.world.level.block;
+
+import java.util.Random;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.state.BlockBase;
+import net.minecraft.world.level.block.state.BlockStateList;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.properties.BlockProperties;
+import net.minecraft.world.level.block.state.properties.BlockStateInteger;
+
+public class BlockIceFrost extends BlockIce {
+
+    public static final BlockStateInteger a = BlockProperties.ag;
+
+    public BlockIceFrost(BlockBase.Info blockbase_info) {
+        super(blockbase_info);
+        this.j((IBlockData) ((IBlockData) this.blockStateList.getBlockData()).set(BlockIceFrost.a, 0));
+    }
+
+    @Override
+    public void tick(IBlockData iblockdata, WorldServer worldserver, BlockPosition blockposition, Random random) {
+        this.tickAlways(iblockdata, worldserver, blockposition, random);
+    }
+
+    @Override
+    public void tickAlways(IBlockData iblockdata, WorldServer worldserver, BlockPosition blockposition, Random random) {
+        if ((random.nextInt(3) == 0 || this.a(worldserver, blockposition, 4)) && worldserver.getLightLevel(blockposition) > 11 - (Integer) iblockdata.get(BlockIceFrost.a) - iblockdata.b((IBlockAccess) worldserver, blockposition) && this.e(iblockdata, (World) worldserver, blockposition)) {
+            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int i = aenumdirection.length;
+
+            for (int j = 0; j < i; ++j) {
+                EnumDirection enumdirection = aenumdirection[j];
+
+                blockposition_mutableblockposition.a((BaseBlockPosition) blockposition, enumdirection);
+                IBlockData iblockdata1 = worldserver.getType(blockposition_mutableblockposition);
+
+                if (iblockdata1.a((Block) this) && !this.e(iblockdata1, (World) worldserver, blockposition_mutableblockposition)) {
+                    worldserver.getBlockTickList().a(blockposition_mutableblockposition, this, MathHelper.nextInt(random, 20, 40));
+                }
+            }
+
+        } else {
+            worldserver.getBlockTickList().a(blockposition, this, MathHelper.nextInt(random, 20, 40));
+        }
+    }
+
+    private boolean e(IBlockData iblockdata, World world, BlockPosition blockposition) {
+        int i = (Integer) iblockdata.get(BlockIceFrost.a);
+
+        if (i < 3) {
+            world.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockIceFrost.a, i + 1), 2);
+            return false;
+        } else {
+            this.melt(iblockdata, world, blockposition);
+            return true;
+        }
+    }
+
+    @Override
+    public void doPhysics(IBlockData iblockdata, World world, BlockPosition blockposition, Block block, BlockPosition blockposition1, boolean flag) {
+        if (block == this && this.a(world, blockposition, 2)) {
+            this.melt(iblockdata, world, blockposition);
+        }
+
+        super.doPhysics(iblockdata, world, blockposition, block, blockposition1, flag);
+    }
+
+    private boolean a(IBlockAccess iblockaccess, BlockPosition blockposition, int i) {
+        int j = 0;
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        EnumDirection[] aenumdirection = EnumDirection.values();
+        int k = aenumdirection.length;
+
+        for (int l = 0; l < k; ++l) {
+            EnumDirection enumdirection = aenumdirection[l];
+
+            blockposition_mutableblockposition.a((BaseBlockPosition) blockposition, enumdirection);
+            if (iblockaccess.getType(blockposition_mutableblockposition).a((Block) this)) {
+                ++j;
+                if (j >= i) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    protected void a(BlockStateList.a<Block, IBlockData> blockstatelist_a) {
+        blockstatelist_a.a(BlockIceFrost.a);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/BlockMinecartTrackAbstract.java b/src/main/java/net/minecraft/world/level/block/BlockMinecartTrackAbstract.java
new file mode 100644
index 0000000000000000000000000000000000000000..f65a53347f26affd1ce8d79527a6486e6bf8fbdd
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/BlockMinecartTrackAbstract.java
@@ -0,0 +1,147 @@
+package net.minecraft.world.level.block;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsBlock;
+import net.minecraft.world.item.context.BlockActionContext;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.IWorldReader;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.state.BlockBase;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.properties.BlockPropertyTrackPosition;
+import net.minecraft.world.level.block.state.properties.IBlockState;
+import net.minecraft.world.level.material.EnumPistonReaction;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapeCollision;
+
+public abstract class BlockMinecartTrackAbstract extends Block {
+
+    protected static final VoxelShape a = Block.a(0.0D, 0.0D, 0.0D, 16.0D, 2.0D, 16.0D);
+    protected static final VoxelShape b = Block.a(0.0D, 0.0D, 0.0D, 16.0D, 8.0D, 16.0D);
+    private final boolean c;
+
+    public static boolean a(World world, BlockPosition blockposition) {
+        return g(world.getType(blockposition));
+    }
+
+    public static boolean g(IBlockData iblockdata) {
+        return iblockdata.a((Tag) TagsBlock.RAILS) && iblockdata.getBlock() instanceof BlockMinecartTrackAbstract;
+    }
+
+    protected BlockMinecartTrackAbstract(boolean flag, BlockBase.Info blockbase_info) {
+        super(blockbase_info);
+        this.c = flag;
+    }
+
+    public boolean c() {
+        return this.c;
+    }
+
+    @Override
+    public VoxelShape b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
+        BlockPropertyTrackPosition blockpropertytrackposition = iblockdata.a((Block) this) ? (BlockPropertyTrackPosition) iblockdata.get(this.d()) : null;
+
+        return blockpropertytrackposition != null && blockpropertytrackposition.c() ? BlockMinecartTrackAbstract.b : BlockMinecartTrackAbstract.a;
+    }
+
+    @Override
+    public boolean canPlace(IBlockData iblockdata, IWorldReader iworldreader, BlockPosition blockposition) {
+        return c((IBlockAccess) iworldreader, blockposition.down());
+    }
+
+    @Override
+    public void onPlace(IBlockData iblockdata, World world, BlockPosition blockposition, IBlockData iblockdata1, boolean flag) {
+        if (!iblockdata1.a(iblockdata.getBlock())) {
+            this.a(iblockdata, world, blockposition, flag);
+        }
+    }
+
+    protected IBlockData a(IBlockData iblockdata, World world, BlockPosition blockposition, boolean flag) {
+        iblockdata = this.a(world, blockposition, iblockdata, true);
+        if (this.c) {
+            iblockdata.doPhysics(world, blockposition, this, blockposition, flag);
+        }
+
+        return iblockdata;
+    }
+
+    @Override
+    public void doPhysics(IBlockData iblockdata, World world, BlockPosition blockposition, Block block, BlockPosition blockposition1, boolean flag) {
+        if (!world.isClientSide && world.getType(blockposition).a((Block) this)) {
+            BlockPropertyTrackPosition blockpropertytrackposition = (BlockPropertyTrackPosition) iblockdata.get(this.d());
+
+            if (a(blockposition, world, blockpropertytrackposition)) {
+                c(iblockdata, world, blockposition);
+                world.a(blockposition, flag);
+            } else {
+                this.a(iblockdata, world, blockposition, block);
+            }
+
+        }
+    }
+
+    private static boolean a(BlockPosition blockposition, World world, BlockPropertyTrackPosition blockpropertytrackposition) {
+        if (!c((IBlockAccess) world, blockposition.down())) {
+            return true;
+        } else {
+            switch (blockpropertytrackposition) {
+                case ASCENDING_EAST:
+                    return !c((IBlockAccess) world, blockposition.east());
+                case ASCENDING_WEST:
+                    return !c((IBlockAccess) world, blockposition.west());
+                case ASCENDING_NORTH:
+                    return !c((IBlockAccess) world, blockposition.north());
+                case ASCENDING_SOUTH:
+                    return !c((IBlockAccess) world, blockposition.south());
+                default:
+                    return false;
+            }
+        }
+    }
+
+    protected void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block) {}
+
+    protected IBlockData a(World world, BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
+        if (world.isClientSide) {
+            return iblockdata;
+        } else {
+            BlockPropertyTrackPosition blockpropertytrackposition = (BlockPropertyTrackPosition) iblockdata.get(this.d());
+
+            return (new MinecartTrackLogic(world, blockposition, iblockdata)).a(world.isBlockIndirectlyPowered(blockposition), flag, blockpropertytrackposition).c();
+        }
+    }
+
+    @Override
+    public EnumPistonReaction getPushReaction(IBlockData iblockdata) {
+        return EnumPistonReaction.NORMAL;
+    }
+
+    @Override
+    public void remove(IBlockData iblockdata, World world, BlockPosition blockposition, IBlockData iblockdata1, boolean flag) {
+        if (!flag) {
+            super.remove(iblockdata, world, blockposition, iblockdata1, flag);
+            if (((BlockPropertyTrackPosition) iblockdata.get(this.d())).c()) {
+                world.applyPhysics(blockposition.up(), this);
+            }
+
+            if (this.c) {
+                world.applyPhysics(blockposition, this);
+                world.applyPhysics(blockposition.down(), this);
+            }
+
+        }
+    }
+
+    @Override
+    public IBlockData getPlacedState(BlockActionContext blockactioncontext) {
+        IBlockData iblockdata = super.getBlockData();
+        EnumDirection enumdirection = blockactioncontext.f();
+        boolean flag = enumdirection == EnumDirection.EAST || enumdirection == EnumDirection.WEST;
+
+        return (IBlockData) iblockdata.set(this.d(), flag ? BlockPropertyTrackPosition.EAST_WEST : BlockPropertyTrackPosition.NORTH_SOUTH);
+    }
+
+    public abstract IBlockState<BlockPropertyTrackPosition> d();
+}
diff --git a/src/main/java/net/minecraft/world/level/block/BlockPumpkin.java b/src/main/java/net/minecraft/world/level/block/BlockPumpkin.java
new file mode 100644
index 0000000000000000000000000000000000000000..130b768ac7155c2960694dfa12163e46315f7797
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/BlockPumpkin.java
@@ -0,0 +1,59 @@
+package net.minecraft.world.level.block;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.EnumInteractionResult;
+import net.minecraft.world.entity.item.EntityItem;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.state.BlockBase;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.phys.MovingObjectPositionBlock;
+
+public class BlockPumpkin extends BlockStemmed {
+
+    protected BlockPumpkin(BlockBase.Info blockbase_info) {
+        super(blockbase_info);
+    }
+
+    @Override
+    public EnumInteractionResult interact(IBlockData iblockdata, World world, BlockPosition blockposition, EntityHuman entityhuman, EnumHand enumhand, MovingObjectPositionBlock movingobjectpositionblock) {
+        ItemStack itemstack = entityhuman.b(enumhand);
+
+        if (itemstack.getItem() == Items.SHEARS) {
+            if (!world.isClientSide) {
+                EnumDirection enumdirection = movingobjectpositionblock.getDirection();
+                EnumDirection enumdirection1 = enumdirection.n() == EnumDirection.EnumAxis.Y ? entityhuman.getDirection().opposite() : enumdirection;
+
+                world.playSound((EntityHuman) null, blockposition, SoundEffects.BLOCK_PUMPKIN_CARVE, SoundCategory.BLOCKS, 1.0F, 1.0F);
+                world.setTypeAndData(blockposition, (IBlockData) Blocks.CARVED_PUMPKIN.getBlockData().set(BlockPumpkinCarved.a, enumdirection1), 11);
+                EntityItem entityitem = new EntityItem(world, (double) blockposition.getX() + 0.5D + (double) enumdirection1.getAdjacentX() * 0.65D, (double) blockposition.getY() + 0.1D, (double) blockposition.getZ() + 0.5D + (double) enumdirection1.getAdjacentZ() * 0.65D, new ItemStack(Items.PUMPKIN_SEEDS, 4));
+
+                entityitem.setMot(0.05D * (double) enumdirection1.getAdjacentX() + world.random.nextDouble() * 0.02D, 0.05D, 0.05D * (double) enumdirection1.getAdjacentZ() + world.random.nextDouble() * 0.02D);
+                world.addEntity(entityitem);
+                itemstack.damage(1, entityhuman, (entityhuman1) -> {
+                    entityhuman1.broadcastItemBreak(enumhand);
+                });
+            }
+
+            return EnumInteractionResult.a(world.isClientSide);
+        } else {
+            return super.interact(iblockdata, world, blockposition, entityhuman, enumhand, movingobjectpositionblock);
+        }
+    }
+
+    @Override
+    public BlockStem c() {
+        return (BlockStem) Blocks.PUMPKIN_STEM;
+    }
+
+    @Override
+    public BlockStemAttached d() {
+        return (BlockStemAttached) Blocks.ATTACHED_PUMPKIN_STEM;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/BlockTarget.java b/src/main/java/net/minecraft/world/level/block/BlockTarget.java
new file mode 100644
index 0000000000000000000000000000000000000000..c336490815dc17991d3d84d8c6f0fc58571a3e3a
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/BlockTarget.java
@@ -0,0 +1,115 @@
+package net.minecraft.world.level.block;
+
+import java.util.Random;
+import net.minecraft.advancements.CriterionTriggers;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.stats.StatisticList;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.projectile.EntityArrow;
+import net.minecraft.world.entity.projectile.IProjectile;
+import net.minecraft.world.level.GeneratorAccess;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.state.BlockBase;
+import net.minecraft.world.level.block.state.BlockStateList;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.properties.BlockProperties;
+import net.minecraft.world.level.block.state.properties.BlockStateInteger;
+import net.minecraft.world.phys.MovingObjectPositionBlock;
+import net.minecraft.world.phys.Vec3D;
+
+public class BlockTarget extends Block {
+
+    private static final BlockStateInteger a = BlockProperties.az;
+
+    public BlockTarget(BlockBase.Info blockbase_info) {
+        super(blockbase_info);
+        this.j((IBlockData) ((IBlockData) this.blockStateList.getBlockData()).set(BlockTarget.a, 0));
+    }
+
+    @Override
+    public void a(World world, IBlockData iblockdata, MovingObjectPositionBlock movingobjectpositionblock, IProjectile iprojectile) {
+        int i = a((GeneratorAccess) world, iblockdata, movingobjectpositionblock, (Entity) iprojectile);
+        Entity entity = iprojectile.getShooter();
+
+        if (entity instanceof EntityPlayer) {
+            EntityPlayer entityplayer = (EntityPlayer) entity;
+
+            entityplayer.a(StatisticList.TARGET_HIT);
+            CriterionTriggers.L.a(entityplayer, iprojectile, movingobjectpositionblock.getPos(), i);
+        }
+
+    }
+
+    private static int a(GeneratorAccess generatoraccess, IBlockData iblockdata, MovingObjectPositionBlock movingobjectpositionblock, Entity entity) {
+        int i = a(movingobjectpositionblock, movingobjectpositionblock.getPos());
+        int j = entity instanceof EntityArrow ? 20 : 8;
+
+        if (!generatoraccess.getBlockTickList().a(movingobjectpositionblock.getBlockPosition(), iblockdata.getBlock())) {
+            a(generatoraccess, iblockdata, i, movingobjectpositionblock.getBlockPosition(), j);
+        }
+
+        return i;
+    }
+
+    private static int a(MovingObjectPositionBlock movingobjectpositionblock, Vec3D vec3d) {
+        EnumDirection enumdirection = movingobjectpositionblock.getDirection();
+        double d0 = Math.abs(MathHelper.h(vec3d.x) - 0.5D);
+        double d1 = Math.abs(MathHelper.h(vec3d.y) - 0.5D);
+        double d2 = Math.abs(MathHelper.h(vec3d.z) - 0.5D);
+        EnumDirection.EnumAxis enumdirection_enumaxis = enumdirection.n();
+        double d3;
+
+        if (enumdirection_enumaxis == EnumDirection.EnumAxis.Y) {
+            d3 = Math.max(d0, d2);
+        } else if (enumdirection_enumaxis == EnumDirection.EnumAxis.Z) {
+            d3 = Math.max(d0, d1);
+        } else {
+            d3 = Math.max(d1, d2);
+        }
+
+        return Math.max(1, MathHelper.f(15.0D * MathHelper.a((0.5D - d3) / 0.5D, 0.0D, 1.0D)));
+    }
+
+    private static void a(GeneratorAccess generatoraccess, IBlockData iblockdata, int i, BlockPosition blockposition, int j) {
+        generatoraccess.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockTarget.a, i), 3);
+        generatoraccess.getBlockTickList().a(blockposition, iblockdata.getBlock(), j);
+    }
+
+    @Override
+    public void tickAlways(IBlockData iblockdata, WorldServer worldserver, BlockPosition blockposition, Random random) {
+        if ((Integer) iblockdata.get(BlockTarget.a) != 0) {
+            worldserver.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockTarget.a, 0), 3);
+        }
+
+    }
+
+    @Override
+    public int a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        return (Integer) iblockdata.get(BlockTarget.a);
+    }
+
+    @Override
+    public boolean isPowerSource(IBlockData iblockdata) {
+        return true;
+    }
+
+    @Override
+    protected void a(BlockStateList.a<Block, IBlockData> blockstatelist_a) {
+        blockstatelist_a.a(BlockTarget.a);
+    }
+
+    @Override
+    public void onPlace(IBlockData iblockdata, World world, BlockPosition blockposition, IBlockData iblockdata1, boolean flag) {
+        if (!world.s_() && !iblockdata.a(iblockdata1.getBlock())) {
+            if ((Integer) iblockdata.get(BlockTarget.a) > 0 && !world.getBlockTickList().a(blockposition, this)) {
+                world.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockTarget.a, 0), 18);
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/DoubleBlockFinder.java b/src/main/java/net/minecraft/world/level/block/DoubleBlockFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..d51f89fed6129c4b37ef63971f8f61dc14e8032d
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/DoubleBlockFinder.java
@@ -0,0 +1,108 @@
+package net.minecraft.world.level.block;
+
+import java.util.function.BiPredicate;
+import java.util.function.Function;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.world.level.GeneratorAccess;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.entity.TileEntityTypes;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.properties.BlockStateDirection;
+
+public class DoubleBlockFinder {
+
+    public static <S extends TileEntity> DoubleBlockFinder.Result<S> a(TileEntityTypes<S> tileentitytypes, Function<IBlockData, DoubleBlockFinder.BlockType> function, Function<IBlockData, EnumDirection> function1, BlockStateDirection blockstatedirection, IBlockData iblockdata, GeneratorAccess generatoraccess, BlockPosition blockposition, BiPredicate<GeneratorAccess, BlockPosition> bipredicate) {
+        S s0 = tileentitytypes.a((IBlockAccess) generatoraccess, blockposition);
+
+        if (s0 == null) {
+            return DoubleBlockFinder.Combiner::b;
+        } else if (bipredicate.test(generatoraccess, blockposition)) {
+            return DoubleBlockFinder.Combiner::b;
+        } else {
+            DoubleBlockFinder.BlockType doubleblockfinder_blocktype = (DoubleBlockFinder.BlockType) function.apply(iblockdata);
+            boolean flag = doubleblockfinder_blocktype == DoubleBlockFinder.BlockType.SINGLE;
+            boolean flag1 = doubleblockfinder_blocktype == DoubleBlockFinder.BlockType.FIRST;
+
+            if (flag) {
+                return new DoubleBlockFinder.Result.Single<>(s0);
+            } else {
+                BlockPosition blockposition1 = blockposition.shift((EnumDirection) function1.apply(iblockdata));
+                IBlockData iblockdata1 = generatoraccess.getType(blockposition1);
+
+                if (iblockdata1.a(iblockdata.getBlock())) {
+                    DoubleBlockFinder.BlockType doubleblockfinder_blocktype1 = (DoubleBlockFinder.BlockType) function.apply(iblockdata1);
+
+                    if (doubleblockfinder_blocktype1 != DoubleBlockFinder.BlockType.SINGLE && doubleblockfinder_blocktype != doubleblockfinder_blocktype1 && iblockdata1.get(blockstatedirection) == iblockdata.get(blockstatedirection)) {
+                        if (bipredicate.test(generatoraccess, blockposition1)) {
+                            return DoubleBlockFinder.Combiner::b;
+                        }
+
+                        S s1 = tileentitytypes.a((IBlockAccess) generatoraccess, blockposition1);
+
+                        if (s1 != null) {
+                            S s2 = flag1 ? s0 : s1;
+                            S s3 = flag1 ? s1 : s0;
+
+                            return new DoubleBlockFinder.Result.Double<>(s2, s3);
+                        }
+                    }
+                }
+
+                return new DoubleBlockFinder.Result.Single<>(s0);
+            }
+        }
+    }
+
+    public interface Result<S> {
+
+        <T> T apply(DoubleBlockFinder.Combiner<? super S, T> doubleblockfinder_combiner);
+
+        public static final class Single<S> implements DoubleBlockFinder.Result<S> {
+
+            private final S a;
+
+            public Single(S s0) {
+                this.a = s0;
+            }
+
+            @Override
+            public <T> T apply(DoubleBlockFinder.Combiner<? super S, T> doubleblockfinder_combiner) {
+                return doubleblockfinder_combiner.a(this.a);
+            }
+        }
+
+        public static final class Double<S> implements DoubleBlockFinder.Result<S> {
+
+            private final S a;
+            private final S b;
+
+            public Double(S s0, S s1) {
+                this.a = s0;
+                this.b = s1;
+            }
+
+            @Override
+            public <T> T apply(DoubleBlockFinder.Combiner<? super S, T> doubleblockfinder_combiner) {
+                return doubleblockfinder_combiner.a(this.a, this.b);
+            }
+        }
+    }
+
+    public interface Combiner<S, T> {
+
+        T a(S s0, S s1);
+
+        T a(S s0);
+
+        T b();
+    }
+
+    public static enum BlockType {
+
+        SINGLE, FIRST, SECOND;
+
+        private BlockType() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/MinecartTrackLogic.java b/src/main/java/net/minecraft/world/level/block/MinecartTrackLogic.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a8e3af0290a9483ee59d5fab061a9a9f5613f0a
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/MinecartTrackLogic.java
@@ -0,0 +1,369 @@
+package net.minecraft.world.level.block;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.properties.BlockPropertyTrackPosition;
+
+public class MinecartTrackLogic {
+
+    private final World a;
+    private final BlockPosition b;
+    private final BlockMinecartTrackAbstract c;
+    private IBlockData d;
+    private final boolean e;
+    private final List<BlockPosition> f = Lists.newArrayList();
+
+    public MinecartTrackLogic(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.a = world;
+        this.b = blockposition;
+        this.d = iblockdata;
+        this.c = (BlockMinecartTrackAbstract) iblockdata.getBlock();
+        BlockPropertyTrackPosition blockpropertytrackposition = (BlockPropertyTrackPosition) iblockdata.get(this.c.d());
+
+        this.e = this.c.c();
+        this.a(blockpropertytrackposition);
+    }
+
+    public List<BlockPosition> a() {
+        return this.f;
+    }
+
+    private void a(BlockPropertyTrackPosition blockpropertytrackposition) {
+        this.f.clear();
+        switch (blockpropertytrackposition) {
+            case NORTH_SOUTH:
+                this.f.add(this.b.north());
+                this.f.add(this.b.south());
+                break;
+            case EAST_WEST:
+                this.f.add(this.b.west());
+                this.f.add(this.b.east());
+                break;
+            case ASCENDING_EAST:
+                this.f.add(this.b.west());
+                this.f.add(this.b.east().up());
+                break;
+            case ASCENDING_WEST:
+                this.f.add(this.b.west().up());
+                this.f.add(this.b.east());
+                break;
+            case ASCENDING_NORTH:
+                this.f.add(this.b.north().up());
+                this.f.add(this.b.south());
+                break;
+            case ASCENDING_SOUTH:
+                this.f.add(this.b.north());
+                this.f.add(this.b.south().up());
+                break;
+            case SOUTH_EAST:
+                this.f.add(this.b.east());
+                this.f.add(this.b.south());
+                break;
+            case SOUTH_WEST:
+                this.f.add(this.b.west());
+                this.f.add(this.b.south());
+                break;
+            case NORTH_WEST:
+                this.f.add(this.b.west());
+                this.f.add(this.b.north());
+                break;
+            case NORTH_EAST:
+                this.f.add(this.b.east());
+                this.f.add(this.b.north());
+        }
+
+    }
+
+    private void d() {
+        for (int i = 0; i < this.f.size(); ++i) {
+            MinecartTrackLogic minecarttracklogic = this.b((BlockPosition) this.f.get(i));
+
+            if (minecarttracklogic != null && minecarttracklogic.a(this)) {
+                this.f.set(i, minecarttracklogic.b);
+            } else {
+                this.f.remove(i--);
+            }
+        }
+
+    }
+
+    private boolean a(BlockPosition blockposition) {
+        return BlockMinecartTrackAbstract.a(this.a, blockposition) || BlockMinecartTrackAbstract.a(this.a, blockposition.up()) || BlockMinecartTrackAbstract.a(this.a, blockposition.down());
+    }
+
+    @Nullable
+    private MinecartTrackLogic b(BlockPosition blockposition) {
+        IBlockData iblockdata = this.a.getType(blockposition);
+
+        if (BlockMinecartTrackAbstract.g(iblockdata)) {
+            return new MinecartTrackLogic(this.a, blockposition, iblockdata);
+        } else {
+            BlockPosition blockposition1 = blockposition.up();
+
+            iblockdata = this.a.getType(blockposition1);
+            if (BlockMinecartTrackAbstract.g(iblockdata)) {
+                return new MinecartTrackLogic(this.a, blockposition1, iblockdata);
+            } else {
+                blockposition1 = blockposition.down();
+                iblockdata = this.a.getType(blockposition1);
+                return BlockMinecartTrackAbstract.g(iblockdata) ? new MinecartTrackLogic(this.a, blockposition1, iblockdata) : null;
+            }
+        }
+    }
+
+    private boolean a(MinecartTrackLogic minecarttracklogic) {
+        return this.c(minecarttracklogic.b);
+    }
+
+    private boolean c(BlockPosition blockposition) {
+        for (int i = 0; i < this.f.size(); ++i) {
+            BlockPosition blockposition1 = (BlockPosition) this.f.get(i);
+
+            if (blockposition1.getX() == blockposition.getX() && blockposition1.getZ() == blockposition.getZ()) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    protected int b() {
+        int i = 0;
+        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            EnumDirection enumdirection = (EnumDirection) iterator.next();
+
+            if (this.a(this.b.shift(enumdirection))) {
+                ++i;
+            }
+        }
+
+        return i;
+    }
+
+    private boolean b(MinecartTrackLogic minecarttracklogic) {
+        return this.a(minecarttracklogic) || this.f.size() != 2;
+    }
+
+    private void c(MinecartTrackLogic minecarttracklogic) {
+        this.f.add(minecarttracklogic.b);
+        BlockPosition blockposition = this.b.north();
+        BlockPosition blockposition1 = this.b.south();
+        BlockPosition blockposition2 = this.b.west();
+        BlockPosition blockposition3 = this.b.east();
+        boolean flag = this.c(blockposition);
+        boolean flag1 = this.c(blockposition1);
+        boolean flag2 = this.c(blockposition2);
+        boolean flag3 = this.c(blockposition3);
+        BlockPropertyTrackPosition blockpropertytrackposition = null;
+
+        if (flag || flag1) {
+            blockpropertytrackposition = BlockPropertyTrackPosition.NORTH_SOUTH;
+        }
+
+        if (flag2 || flag3) {
+            blockpropertytrackposition = BlockPropertyTrackPosition.EAST_WEST;
+        }
+
+        if (!this.e) {
+            if (flag1 && flag3 && !flag && !flag2) {
+                blockpropertytrackposition = BlockPropertyTrackPosition.SOUTH_EAST;
+            }
+
+            if (flag1 && flag2 && !flag && !flag3) {
+                blockpropertytrackposition = BlockPropertyTrackPosition.SOUTH_WEST;
+            }
+
+            if (flag && flag2 && !flag1 && !flag3) {
+                blockpropertytrackposition = BlockPropertyTrackPosition.NORTH_WEST;
+            }
+
+            if (flag && flag3 && !flag1 && !flag2) {
+                blockpropertytrackposition = BlockPropertyTrackPosition.NORTH_EAST;
+            }
+        }
+
+        if (blockpropertytrackposition == BlockPropertyTrackPosition.NORTH_SOUTH) {
+            if (BlockMinecartTrackAbstract.a(this.a, blockposition.up())) {
+                blockpropertytrackposition = BlockPropertyTrackPosition.ASCENDING_NORTH;
+            }
+
+            if (BlockMinecartTrackAbstract.a(this.a, blockposition1.up())) {
+                blockpropertytrackposition = BlockPropertyTrackPosition.ASCENDING_SOUTH;
+            }
+        }
+
+        if (blockpropertytrackposition == BlockPropertyTrackPosition.EAST_WEST) {
+            if (BlockMinecartTrackAbstract.a(this.a, blockposition3.up())) {
+                blockpropertytrackposition = BlockPropertyTrackPosition.ASCENDING_EAST;
+            }
+
+            if (BlockMinecartTrackAbstract.a(this.a, blockposition2.up())) {
+                blockpropertytrackposition = BlockPropertyTrackPosition.ASCENDING_WEST;
+            }
+        }
+
+        if (blockpropertytrackposition == null) {
+            blockpropertytrackposition = BlockPropertyTrackPosition.NORTH_SOUTH;
+        }
+
+        this.d = (IBlockData) this.d.set(this.c.d(), blockpropertytrackposition);
+        this.a.setTypeAndData(this.b, this.d, 3);
+    }
+
+    private boolean d(BlockPosition blockposition) {
+        MinecartTrackLogic minecarttracklogic = this.b(blockposition);
+
+        if (minecarttracklogic == null) {
+            return false;
+        } else {
+            minecarttracklogic.d();
+            return minecarttracklogic.b(this);
+        }
+    }
+
+    public MinecartTrackLogic a(boolean flag, boolean flag1, BlockPropertyTrackPosition blockpropertytrackposition) {
+        BlockPosition blockposition = this.b.north();
+        BlockPosition blockposition1 = this.b.south();
+        BlockPosition blockposition2 = this.b.west();
+        BlockPosition blockposition3 = this.b.east();
+        boolean flag2 = this.d(blockposition);
+        boolean flag3 = this.d(blockposition1);
+        boolean flag4 = this.d(blockposition2);
+        boolean flag5 = this.d(blockposition3);
+        BlockPropertyTrackPosition blockpropertytrackposition1 = null;
+        boolean flag6 = flag2 || flag3;
+        boolean flag7 = flag4 || flag5;
+
+        if (flag6 && !flag7) {
+            blockpropertytrackposition1 = BlockPropertyTrackPosition.NORTH_SOUTH;
+        }
+
+        if (flag7 && !flag6) {
+            blockpropertytrackposition1 = BlockPropertyTrackPosition.EAST_WEST;
+        }
+
+        boolean flag8 = flag3 && flag5;
+        boolean flag9 = flag3 && flag4;
+        boolean flag10 = flag2 && flag5;
+        boolean flag11 = flag2 && flag4;
+
+        if (!this.e) {
+            if (flag8 && !flag2 && !flag4) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.SOUTH_EAST;
+            }
+
+            if (flag9 && !flag2 && !flag5) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.SOUTH_WEST;
+            }
+
+            if (flag11 && !flag3 && !flag5) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.NORTH_WEST;
+            }
+
+            if (flag10 && !flag3 && !flag4) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.NORTH_EAST;
+            }
+        }
+
+        if (blockpropertytrackposition1 == null) {
+            if (flag6 && flag7) {
+                blockpropertytrackposition1 = blockpropertytrackposition;
+            } else if (flag6) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.NORTH_SOUTH;
+            } else if (flag7) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.EAST_WEST;
+            }
+
+            if (!this.e) {
+                if (flag) {
+                    if (flag8) {
+                        blockpropertytrackposition1 = BlockPropertyTrackPosition.SOUTH_EAST;
+                    }
+
+                    if (flag9) {
+                        blockpropertytrackposition1 = BlockPropertyTrackPosition.SOUTH_WEST;
+                    }
+
+                    if (flag10) {
+                        blockpropertytrackposition1 = BlockPropertyTrackPosition.NORTH_EAST;
+                    }
+
+                    if (flag11) {
+                        blockpropertytrackposition1 = BlockPropertyTrackPosition.NORTH_WEST;
+                    }
+                } else {
+                    if (flag11) {
+                        blockpropertytrackposition1 = BlockPropertyTrackPosition.NORTH_WEST;
+                    }
+
+                    if (flag10) {
+                        blockpropertytrackposition1 = BlockPropertyTrackPosition.NORTH_EAST;
+                    }
+
+                    if (flag9) {
+                        blockpropertytrackposition1 = BlockPropertyTrackPosition.SOUTH_WEST;
+                    }
+
+                    if (flag8) {
+                        blockpropertytrackposition1 = BlockPropertyTrackPosition.SOUTH_EAST;
+                    }
+                }
+            }
+        }
+
+        if (blockpropertytrackposition1 == BlockPropertyTrackPosition.NORTH_SOUTH) {
+            if (BlockMinecartTrackAbstract.a(this.a, blockposition.up())) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.ASCENDING_NORTH;
+            }
+
+            if (BlockMinecartTrackAbstract.a(this.a, blockposition1.up())) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.ASCENDING_SOUTH;
+            }
+        }
+
+        if (blockpropertytrackposition1 == BlockPropertyTrackPosition.EAST_WEST) {
+            if (BlockMinecartTrackAbstract.a(this.a, blockposition3.up())) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.ASCENDING_EAST;
+            }
+
+            if (BlockMinecartTrackAbstract.a(this.a, blockposition2.up())) {
+                blockpropertytrackposition1 = BlockPropertyTrackPosition.ASCENDING_WEST;
+            }
+        }
+
+        if (blockpropertytrackposition1 == null) {
+            blockpropertytrackposition1 = blockpropertytrackposition;
+        }
+
+        this.a(blockpropertytrackposition1);
+        this.d = (IBlockData) this.d.set(this.c.d(), blockpropertytrackposition1);
+        if (flag1 || this.a.getType(this.b) != this.d) {
+            this.a.setTypeAndData(this.b, this.d, 3);
+
+            for (int i = 0; i < this.f.size(); ++i) {
+                MinecartTrackLogic minecarttracklogic = this.b((BlockPosition) this.f.get(i));
+
+                if (minecarttracklogic != null) {
+                    minecarttracklogic.d();
+                    if (minecarttracklogic.b(this)) {
+                        minecarttracklogic.c(this);
+                    }
+                }
+            }
+        }
+
+        return this;
+    }
+
+    public IBlockData c() {
+        return this.d;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/SoundEffectType.java b/src/main/java/net/minecraft/world/level/block/SoundEffectType.java
new file mode 100644
index 0000000000000000000000000000000000000000..0987b25ac586d5d7b7954256c740fdf736498dae
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/SoundEffectType.java
@@ -0,0 +1,92 @@
+package net.minecraft.world.level.block;
+
+import net.minecraft.sounds.SoundEffect;
+import net.minecraft.sounds.SoundEffects;
+
+public class SoundEffectType {
+
+    public static final SoundEffectType a = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_WOOD_BREAK, SoundEffects.BLOCK_WOOD_STEP, SoundEffects.BLOCK_WOOD_PLACE, SoundEffects.BLOCK_WOOD_HIT, SoundEffects.BLOCK_WOOD_FALL);
+    public static final SoundEffectType b = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_GRAVEL_BREAK, SoundEffects.BLOCK_GRAVEL_STEP, SoundEffects.BLOCK_GRAVEL_PLACE, SoundEffects.BLOCK_GRAVEL_HIT, SoundEffects.BLOCK_GRAVEL_FALL);
+    public static final SoundEffectType c = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_GRASS_BREAK, SoundEffects.BLOCK_GRASS_STEP, SoundEffects.BLOCK_GRASS_PLACE, SoundEffects.BLOCK_GRASS_HIT, SoundEffects.BLOCK_GRASS_FALL);
+    public static final SoundEffectType d = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_GRASS_BREAK, SoundEffects.BLOCK_GRASS_STEP, SoundEffects.BLOCK_LILY_PAD_PLACE, SoundEffects.BLOCK_GRASS_HIT, SoundEffects.BLOCK_GRASS_FALL);
+    public static final SoundEffectType e = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_STONE_BREAK, SoundEffects.BLOCK_STONE_STEP, SoundEffects.BLOCK_STONE_PLACE, SoundEffects.BLOCK_STONE_HIT, SoundEffects.BLOCK_STONE_FALL);
+    public static final SoundEffectType f = new SoundEffectType(1.0F, 1.5F, SoundEffects.BLOCK_METAL_BREAK, SoundEffects.BLOCK_METAL_STEP, SoundEffects.BLOCK_METAL_PLACE, SoundEffects.BLOCK_METAL_HIT, SoundEffects.BLOCK_METAL_FALL);
+    public static final SoundEffectType g = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_GLASS_BREAK, SoundEffects.BLOCK_GLASS_STEP, SoundEffects.BLOCK_GLASS_PLACE, SoundEffects.BLOCK_GLASS_HIT, SoundEffects.BLOCK_GLASS_FALL);
+    public static final SoundEffectType h = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_WOOL_BREAK, SoundEffects.BLOCK_WOOL_STEP, SoundEffects.BLOCK_WOOL_PLACE, SoundEffects.BLOCK_WOOL_HIT, SoundEffects.BLOCK_WOOL_FALL);
+    public static final SoundEffectType i = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_SAND_BREAK, SoundEffects.BLOCK_SAND_STEP, SoundEffects.BLOCK_SAND_PLACE, SoundEffects.BLOCK_SAND_HIT, SoundEffects.BLOCK_SAND_FALL);
+    public static final SoundEffectType j = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_SNOW_BREAK, SoundEffects.BLOCK_SNOW_STEP, SoundEffects.BLOCK_SNOW_PLACE, SoundEffects.BLOCK_SNOW_HIT, SoundEffects.BLOCK_SNOW_FALL);
+    public static final SoundEffectType k = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_LADDER_BREAK, SoundEffects.BLOCK_LADDER_STEP, SoundEffects.BLOCK_LADDER_PLACE, SoundEffects.BLOCK_LADDER_HIT, SoundEffects.BLOCK_LADDER_FALL);
+    public static final SoundEffectType l = new SoundEffectType(0.3F, 1.0F, SoundEffects.BLOCK_ANVIL_BREAK, SoundEffects.BLOCK_ANVIL_STEP, SoundEffects.BLOCK_ANVIL_PLACE, SoundEffects.BLOCK_ANVIL_HIT, SoundEffects.BLOCK_ANVIL_FALL);
+    public static final SoundEffectType m = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_SLIME_BLOCK_BREAK, SoundEffects.BLOCK_SLIME_BLOCK_STEP, SoundEffects.BLOCK_SLIME_BLOCK_PLACE, SoundEffects.BLOCK_SLIME_BLOCK_HIT, SoundEffects.BLOCK_SLIME_BLOCK_FALL);
+    public static final SoundEffectType n = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_HONEY_BLOCK_BREAK, SoundEffects.BLOCK_HONEY_BLOCK_STEP, SoundEffects.BLOCK_HONEY_BLOCK_PLACE, SoundEffects.BLOCK_HONEY_BLOCK_HIT, SoundEffects.BLOCK_HONEY_BLOCK_FALL);
+    public static final SoundEffectType o = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_WET_GRASS_BREAK, SoundEffects.BLOCK_WET_GRASS_STEP, SoundEffects.BLOCK_WET_GRASS_PLACE, SoundEffects.BLOCK_WET_GRASS_HIT, SoundEffects.BLOCK_WET_GRASS_FALL);
+    public static final SoundEffectType p = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_CORAL_BLOCK_BREAK, SoundEffects.BLOCK_CORAL_BLOCK_STEP, SoundEffects.BLOCK_CORAL_BLOCK_PLACE, SoundEffects.BLOCK_CORAL_BLOCK_HIT, SoundEffects.BLOCK_CORAL_BLOCK_FALL);
+    public static final SoundEffectType q = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_BAMBOO_BREAK, SoundEffects.BLOCK_BAMBOO_STEP, SoundEffects.BLOCK_BAMBOO_PLACE, SoundEffects.BLOCK_BAMBOO_HIT, SoundEffects.BLOCK_BAMBOO_FALL);
+    public static final SoundEffectType r = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_BAMBOO_SAPLING_BREAK, SoundEffects.BLOCK_BAMBOO_STEP, SoundEffects.BLOCK_BAMBOO_SAPLING_PLACE, SoundEffects.BLOCK_BAMBOO_SAPLING_HIT, SoundEffects.BLOCK_BAMBOO_FALL);
+    public static final SoundEffectType s = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_SCAFFOLDING_BREAK, SoundEffects.BLOCK_SCAFFOLDING_STEP, SoundEffects.BLOCK_SCAFFOLDING_PLACE, SoundEffects.BLOCK_SCAFFOLDING_HIT, SoundEffects.BLOCK_SCAFFOLDING_FALL);
+    public static final SoundEffectType t = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_SWEET_BERRY_BUSH_BREAK, SoundEffects.BLOCK_GRASS_STEP, SoundEffects.BLOCK_SWEET_BERRY_BUSH_PLACE, SoundEffects.BLOCK_GRASS_HIT, SoundEffects.BLOCK_GRASS_FALL);
+    public static final SoundEffectType u = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_CROP_BREAK, SoundEffects.BLOCK_GRASS_STEP, SoundEffects.ITEM_CROP_PLANT, SoundEffects.BLOCK_GRASS_HIT, SoundEffects.BLOCK_GRASS_FALL);
+    public static final SoundEffectType v = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_WOOD_BREAK, SoundEffects.BLOCK_WOOD_STEP, SoundEffects.ITEM_CROP_PLANT, SoundEffects.BLOCK_WOOD_HIT, SoundEffects.BLOCK_WOOD_FALL);
+    public static final SoundEffectType w = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_GRASS_BREAK, SoundEffects.BLOCK_VINE_STEP, SoundEffects.BLOCK_GRASS_PLACE, SoundEffects.BLOCK_GRASS_HIT, SoundEffects.BLOCK_GRASS_FALL);
+    public static final SoundEffectType x = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_NETHER_WART_BREAK, SoundEffects.BLOCK_STONE_STEP, SoundEffects.ITEM_NETHER_WART_PLANT, SoundEffects.BLOCK_STONE_HIT, SoundEffects.BLOCK_STONE_FALL);
+    public static final SoundEffectType y = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_LANTERN_BREAK, SoundEffects.BLOCK_LANTERN_STEP, SoundEffects.BLOCK_LANTERN_PLACE, SoundEffects.BLOCK_LANTERN_HIT, SoundEffects.BLOCK_LANTERN_FALL);
+    public static final SoundEffectType z = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_STEM_BREAK, SoundEffects.BLOCK_STEM_STEP, SoundEffects.BLOCK_STEM_PLACE, SoundEffects.BLOCK_STEM_HIT, SoundEffects.BLOCK_STEM_FALL);
+    public static final SoundEffectType A = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_NYLIUM_BREAK, SoundEffects.BLOCK_NYLIUM_STEP, SoundEffects.BLOCK_NYLIUM_PLACE, SoundEffects.BLOCK_NYLIUM_HIT, SoundEffects.BLOCK_NYLIUM_FALL);
+    public static final SoundEffectType B = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_FUNGUS_BREAK, SoundEffects.BLOCK_FUNGUS_STEP, SoundEffects.BLOCK_FUNGUS_PLACE, SoundEffects.BLOCK_FUNGUS_HIT, SoundEffects.BLOCK_FUNGUS_FALL);
+    public static final SoundEffectType C = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_ROOTS_BREAK, SoundEffects.BLOCK_ROOTS_STEP, SoundEffects.BLOCK_ROOTS_PLACE, SoundEffects.BLOCK_ROOTS_HIT, SoundEffects.BLOCK_ROOTS_FALL);
+    public static final SoundEffectType D = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_SHROOMLIGHT_BREAK, SoundEffects.BLOCK_SHROOMLIGHT_STEP, SoundEffects.BLOCK_SHROOMLIGHT_PLACE, SoundEffects.BLOCK_SHROOMLIGHT_HIT, SoundEffects.BLOCK_SHROOMLIGHT_FALL);
+    public static final SoundEffectType E = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_WEEPING_VINES_BREAK, SoundEffects.BLOCK_WEEPING_VINES_STEP, SoundEffects.BLOCK_WEEPING_VINES_PLACE, SoundEffects.BLOCK_WEEPING_VINES_HIT, SoundEffects.BLOCK_WEEPING_VINES_FALL);
+    public static final SoundEffectType F = new SoundEffectType(1.0F, 0.5F, SoundEffects.BLOCK_WEEPING_VINES_BREAK, SoundEffects.BLOCK_WEEPING_VINES_STEP, SoundEffects.BLOCK_WEEPING_VINES_PLACE, SoundEffects.BLOCK_WEEPING_VINES_HIT, SoundEffects.BLOCK_WEEPING_VINES_FALL);
+    public static final SoundEffectType G = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_SOUL_SAND_BREAK, SoundEffects.BLOCK_SOUL_SAND_STEP, SoundEffects.BLOCK_SOUL_SAND_PLACE, SoundEffects.BLOCK_SOUL_SAND_HIT, SoundEffects.BLOCK_SOUL_SAND_FALL);
+    public static final SoundEffectType H = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_SOUL_SOIL_BREAK, SoundEffects.BLOCK_SOUL_SOIL_STEP, SoundEffects.BLOCK_SOUL_SOIL_PLACE, SoundEffects.BLOCK_SOUL_SOIL_HIT, SoundEffects.BLOCK_SOUL_SOIL_FALL);
+    public static final SoundEffectType I = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_BASALT_BREAK, SoundEffects.BLOCK_BASALT_STEP, SoundEffects.BLOCK_BASALT_PLACE, SoundEffects.BLOCK_BASALT_HIT, SoundEffects.BLOCK_BASALT_FALL);
+    public static final SoundEffectType J = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_WART_BLOCK_BREAK, SoundEffects.BLOCK_WART_BLOCK_STEP, SoundEffects.BLOCK_WART_BLOCK_PLACE, SoundEffects.BLOCK_WART_BLOCK_HIT, SoundEffects.BLOCK_WART_BLOCK_FALL);
+    public static final SoundEffectType K = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_NETHERRACK_BREAK, SoundEffects.BLOCK_NETHERRACK_STEP, SoundEffects.BLOCK_NETHERRACK_PLACE, SoundEffects.BLOCK_NETHERRACK_HIT, SoundEffects.BLOCK_NETHERRACK_FALL);
+    public static final SoundEffectType L = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_NETHER_BRICKS_BREAK, SoundEffects.BLOCK_NETHER_BRICKS_STEP, SoundEffects.BLOCK_NETHER_BRICKS_PLACE, SoundEffects.BLOCK_NETHER_BRICKS_HIT, SoundEffects.BLOCK_NETHER_BRICKS_FALL);
+    public static final SoundEffectType M = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_NETHER_SPROUTS_BREAK, SoundEffects.BLOCK_NETHER_SPROUTS_STEP, SoundEffects.BLOCK_NETHER_SPROUTS_PLACE, SoundEffects.BLOCK_NETHER_SPROUTS_HIT, SoundEffects.BLOCK_NETHER_SPROUTS_FALL);
+    public static final SoundEffectType N = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_NETHER_ORE_BREAK, SoundEffects.BLOCK_NETHER_ORE_STEP, SoundEffects.BLOCK_NETHER_ORE_PLACE, SoundEffects.BLOCK_NETHER_ORE_HIT, SoundEffects.BLOCK_NETHER_ORE_FALL);
+    public static final SoundEffectType O = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_BONE_BLOCK_BREAK, SoundEffects.BLOCK_BONE_BLOCK_STEP, SoundEffects.BLOCK_BONE_BLOCK_PLACE, SoundEffects.BLOCK_BONE_BLOCK_HIT, SoundEffects.BLOCK_BONE_BLOCK_FALL);
+    public static final SoundEffectType P = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_NETHERITE_BLOCK_BREAK, SoundEffects.BLOCK_NETHERITE_BLOCK_STEP, SoundEffects.BLOCK_NETHERITE_BLOCK_PLACE, SoundEffects.BLOCK_NETHERITE_BLOCK_HIT, SoundEffects.BLOCK_NETHERITE_BLOCK_FALL);
+    public static final SoundEffectType Q = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_ANCIENT_DEBRIS_BREAK, SoundEffects.BLOCK_ANCIENT_DEBRIS_STEP, SoundEffects.BLOCK_ANCIENT_DEBRIS_PLACE, SoundEffects.BLOCK_ANCIENT_DEBRIS_HIT, SoundEffects.BLOCK_ANCIENT_DEBRIS_FALL);
+    public static final SoundEffectType R = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_LODESTONE_BREAK, SoundEffects.BLOCK_LODESTONE_STEP, SoundEffects.BLOCK_LODESTONE_PLACE, SoundEffects.BLOCK_LODESTONE_HIT, SoundEffects.BLOCK_LODESTONE_FALL);
+    public static final SoundEffectType S = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_CHAIN_BREAK, SoundEffects.BLOCK_CHAIN_STEP, SoundEffects.BLOCK_CHAIN_PLACE, SoundEffects.BLOCK_CHAIN_HIT, SoundEffects.BLOCK_CHAIN_FALL);
+    public static final SoundEffectType T = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_NETHER_GOLD_ORE_BREAK, SoundEffects.BLOCK_NETHER_GOLD_ORE_STEP, SoundEffects.BLOCK_NETHER_GOLD_ORE_PLACE, SoundEffects.BLOCK_NETHER_GOLD_ORE_HIT, SoundEffects.BLOCK_NETHER_GOLD_ORE_FALL);
+    public static final SoundEffectType U = new SoundEffectType(1.0F, 1.0F, SoundEffects.BLOCK_GILDED_BLACKSTONE_BREAK, SoundEffects.BLOCK_GILDED_BLACKSTONE_STEP, SoundEffects.BLOCK_GILDED_BLACKSTONE_PLACE, SoundEffects.BLOCK_GILDED_BLACKSTONE_HIT, SoundEffects.BLOCK_GILDED_BLACKSTONE_FALL);
+    public final float volume;
+    public final float pitch;
+    public final SoundEffect breakSound;
+    private final SoundEffect stepSound;
+    private final SoundEffect placeSound;
+    public final SoundEffect hitSound;
+    private final SoundEffect fallSound;
+
+    public SoundEffectType(float f, float f1, SoundEffect soundeffect, SoundEffect soundeffect1, SoundEffect soundeffect2, SoundEffect soundeffect3, SoundEffect soundeffect4) {
+        this.volume = f;
+        this.pitch = f1;
+        this.breakSound = soundeffect;
+        this.stepSound = soundeffect1;
+        this.placeSound = soundeffect2;
+        this.hitSound = soundeffect3;
+        this.fallSound = soundeffect4;
+    }
+
+    public float getVolume() {
+        return this.volume;
+    }
+
+    public float getPitch() {
+        return this.pitch;
+    }
+
+    public SoundEffect getStepSound() {
+        return this.stepSound;
+    }
+
+    public SoundEffect getPlaceSound() {
+        return this.placeSound;
+    }
+
+    public SoundEffect getFallSound() {
+        return this.fallSound;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/entity/EnumBannerPatternType.java b/src/main/java/net/minecraft/world/level/block/entity/EnumBannerPatternType.java
new file mode 100644
index 0000000000000000000000000000000000000000..988e52c675dbb5ef368c8dbb5fb6d4229eb30174
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/entity/EnumBannerPatternType.java
@@ -0,0 +1,67 @@
+package net.minecraft.world.level.block.entity;
+
+import com.google.common.collect.Lists;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.world.item.EnumColor;
+import org.apache.commons.lang3.tuple.Pair;
+
+public enum EnumBannerPatternType {
+
+    BASE("base", "b", false), SQUARE_BOTTOM_LEFT("square_bottom_left", "bl"), SQUARE_BOTTOM_RIGHT("square_bottom_right", "br"), SQUARE_TOP_LEFT("square_top_left", "tl"), SQUARE_TOP_RIGHT("square_top_right", "tr"), STRIPE_BOTTOM("stripe_bottom", "bs"), STRIPE_TOP("stripe_top", "ts"), STRIPE_LEFT("stripe_left", "ls"), STRIPE_RIGHT("stripe_right", "rs"), STRIPE_CENTER("stripe_center", "cs"), STRIPE_MIDDLE("stripe_middle", "ms"), STRIPE_DOWNRIGHT("stripe_downright", "drs"), STRIPE_DOWNLEFT("stripe_downleft", "dls"), STRIPE_SMALL("small_stripes", "ss"), CROSS("cross", "cr"), STRAIGHT_CROSS("straight_cross", "sc"), TRIANGLE_BOTTOM("triangle_bottom", "bt"), TRIANGLE_TOP("triangle_top", "tt"), TRIANGLES_BOTTOM("triangles_bottom", "bts"), TRIANGLES_TOP("triangles_top", "tts"), DIAGONAL_LEFT("diagonal_left", "ld"), DIAGONAL_RIGHT("diagonal_up_right", "rd"), DIAGONAL_LEFT_MIRROR("diagonal_up_left", "lud"), DIAGONAL_RIGHT_MIRROR("diagonal_right", "rud"), CIRCLE_MIDDLE("circle", "mc"), RHOMBUS_MIDDLE("rhombus", "mr"), HALF_VERTICAL("half_vertical", "vh"), HALF_HORIZONTAL("half_horizontal", "hh"), HALF_VERTICAL_MIRROR("half_vertical_right", "vhr"), HALF_HORIZONTAL_MIRROR("half_horizontal_bottom", "hhb"), BORDER("border", "bo"), CURLY_BORDER("curly_border", "cbo"), GRADIENT("gradient", "gra"), GRADIENT_UP("gradient_up", "gru"), BRICKS("bricks", "bri"), GLOBE("globe", "glb", true), CREEPER("creeper", "cre", true), SKULL("skull", "sku", true), FLOWER("flower", "flo", true), MOJANG("mojang", "moj", true), PIGLIN("piglin", "pig", true);
+
+    private static final EnumBannerPatternType[] S = values();
+    public static final int P = EnumBannerPatternType.S.length;
+    public static final int Q = (int) Arrays.stream(EnumBannerPatternType.S).filter((enumbannerpatterntype) -> {
+        return enumbannerpatterntype.T;
+    }).count();
+    public static final int R = EnumBannerPatternType.P - EnumBannerPatternType.Q - 1;
+    private final boolean T;
+    private final String U;
+    private final String V;
+
+    private EnumBannerPatternType(String s, String s1) {
+        this(s, s1, false);
+    }
+
+    private EnumBannerPatternType(String s, String s1, boolean flag) {
+        this.U = s;
+        this.V = s1;
+        this.T = flag;
+    }
+
+    public String b() {
+        return this.V;
+    }
+
+    public static class a {
+
+        private final List<Pair<EnumBannerPatternType, EnumColor>> a = Lists.newArrayList();
+
+        public a() {}
+
+        public EnumBannerPatternType.a a(EnumBannerPatternType enumbannerpatterntype, EnumColor enumcolor) {
+            this.a.add(Pair.of(enumbannerpatterntype, enumcolor));
+            return this;
+        }
+
+        public NBTTagList a() {
+            NBTTagList nbttaglist = new NBTTagList();
+            Iterator iterator = this.a.iterator();
+
+            while (iterator.hasNext()) {
+                Pair<EnumBannerPatternType, EnumColor> pair = (Pair) iterator.next();
+                NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+                nbttagcompound.setString("Pattern", ((EnumBannerPatternType) pair.getLeft()).V);
+                nbttagcompound.setInt("Color", ((EnumColor) pair.getRight()).getColorIndex());
+                nbttaglist.add(nbttagcompound);
+            }
+
+            return nbttaglist;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/entity/IHopper.java b/src/main/java/net/minecraft/world/level/block/entity/IHopper.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0943ae1f372784716195666212ff83e6ee4873e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/entity/IHopper.java
@@ -0,0 +1,28 @@
+package net.minecraft.world.level.block.entity;
+
+import javax.annotation.Nullable;
+import net.minecraft.world.IInventory;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+
+public interface IHopper extends IInventory {
+
+    VoxelShape a = Block.a(2.0D, 11.0D, 2.0D, 14.0D, 16.0D, 14.0D);
+    VoxelShape b = Block.a(0.0D, 16.0D, 0.0D, 16.0D, 32.0D, 16.0D);
+    VoxelShape c = VoxelShapes.a(IHopper.a, IHopper.b);
+
+    default VoxelShape aa_() {
+        return IHopper.c;
+    }
+
+    @Nullable
+    World getWorld();
+
+    double x();
+
+    double z();
+
+    double A();
+}
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TileEntityBell.java b/src/main/java/net/minecraft/world/level/block/entity/TileEntityBell.java
new file mode 100644
index 0000000000000000000000000000000000000000..e97d229da3cf7631555f418a73bc74255494cc01
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/entity/TileEntityBell.java
@@ -0,0 +1,179 @@
+package net.minecraft.world.level.block.entity;
+
+import java.util.Iterator;
+import java.util.List;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.IPosition;
+import net.minecraft.core.particles.Particles;
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsEntity;
+import net.minecraft.util.ColorUtil;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.EntityLiving;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.level.World;
+import net.minecraft.world.phys.AxisAlignedBB;
+import org.apache.commons.lang3.mutable.MutableInt;
+
+public class TileEntityBell extends TileEntity implements ITickable {
+
+    private long g;
+    public int a;
+    public boolean b;
+    public EnumDirection c;
+    private List<EntityLiving> h;
+    private boolean i;
+    private int j;
+
+    public TileEntityBell() {
+        super(TileEntityTypes.BELL);
+    }
+
+    @Override
+    public boolean setProperty(int i, int j) {
+        if (i == 1) {
+            this.f();
+            this.j = 0;
+            this.c = EnumDirection.fromType1(j);
+            this.a = 0;
+            this.b = true;
+            return true;
+        } else {
+            return super.setProperty(i, j);
+        }
+    }
+
+    @Override
+    public void tick() {
+        if (this.b) {
+            ++this.a;
+        }
+
+        if (this.a >= 50) {
+            this.b = false;
+            this.a = 0;
+        }
+
+        if (this.a >= 5 && this.j == 0 && this.h()) {
+            this.i = true;
+            this.d();
+        }
+
+        if (this.i) {
+            if (this.j < 40) {
+                ++this.j;
+            } else {
+                this.a(this.world);
+                this.b(this.world);
+                this.i = false;
+            }
+        }
+
+    }
+
+    private void d() {
+        this.world.playSound((EntityHuman) null, this.getPosition(), SoundEffects.BLOCK_BELL_RESONATE, SoundCategory.BLOCKS, 1.0F, 1.0F);
+    }
+
+    public void a(EnumDirection enumdirection) {
+        BlockPosition blockposition = this.getPosition();
+
+        this.c = enumdirection;
+        if (this.b) {
+            this.a = 0;
+        } else {
+            this.b = true;
+        }
+
+        this.world.playBlockAction(blockposition, this.getBlock().getBlock(), 1, enumdirection.c());
+    }
+
+    private void f() {
+        BlockPosition blockposition = this.getPosition();
+
+        if (this.world.getTime() > this.g + 60L || this.h == null) {
+            this.g = this.world.getTime();
+            AxisAlignedBB axisalignedbb = (new AxisAlignedBB(blockposition)).g(48.0D);
+
+            this.h = this.world.a(EntityLiving.class, axisalignedbb);
+        }
+
+        if (!this.world.isClientSide) {
+            Iterator iterator = this.h.iterator();
+
+            while (iterator.hasNext()) {
+                EntityLiving entityliving = (EntityLiving) iterator.next();
+
+                if (entityliving.isAlive() && !entityliving.dead && blockposition.a((IPosition) entityliving.getPositionVector(), 32.0D)) {
+                    entityliving.getBehaviorController().setMemory(MemoryModuleType.HEARD_BELL_TIME, (Object) this.world.getTime());
+                }
+            }
+        }
+
+    }
+
+    private boolean h() {
+        BlockPosition blockposition = this.getPosition();
+        Iterator iterator = this.h.iterator();
+
+        EntityLiving entityliving;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            entityliving = (EntityLiving) iterator.next();
+        } while (!entityliving.isAlive() || entityliving.dead || !blockposition.a((IPosition) entityliving.getPositionVector(), 32.0D) || !entityliving.getEntityType().a((Tag) TagsEntity.RADIERS));
+
+        return true;
+    }
+
+    private void a(World world) {
+        if (!world.isClientSide) {
+            this.h.stream().filter(this::a).forEach(this::b);
+        }
+    }
+
+    private void b(World world) {
+        if (world.isClientSide) {
+            BlockPosition blockposition = this.getPosition();
+            MutableInt mutableint = new MutableInt(16700985);
+            int i = (int) this.h.stream().filter((entityliving) -> {
+                return blockposition.a((IPosition) entityliving.getPositionVector(), 48.0D);
+            }).count();
+
+            this.h.stream().filter(this::a).forEach((entityliving) -> {
+                float f = 1.0F;
+                float f1 = MathHelper.sqrt((entityliving.locX() - (double) blockposition.getX()) * (entityliving.locX() - (double) blockposition.getX()) + (entityliving.locZ() - (double) blockposition.getZ()) * (entityliving.locZ() - (double) blockposition.getZ()));
+                double d0 = (double) ((float) blockposition.getX() + 0.5F) + (double) (1.0F / f1) * (entityliving.locX() - (double) blockposition.getX());
+                double d1 = (double) ((float) blockposition.getZ() + 0.5F) + (double) (1.0F / f1) * (entityliving.locZ() - (double) blockposition.getZ());
+                int j = MathHelper.clamp((i - 21) / -2, 3, 15);
+
+                for (int k = 0; k < j; ++k) {
+                    int l = mutableint.addAndGet(5);
+                    double d2 = (double) ColorUtil.a.b(l) / 255.0D;
+                    double d3 = (double) ColorUtil.a.c(l) / 255.0D;
+                    double d4 = (double) ColorUtil.a.d(l) / 255.0D;
+
+                    world.addParticle(Particles.ENTITY_EFFECT, d0, (double) ((float) blockposition.getY() + 0.5F), d1, d2, d3, d4);
+                }
+
+            });
+        }
+    }
+
+    private boolean a(EntityLiving entityliving) {
+        return entityliving.isAlive() && !entityliving.dead && this.getPosition().a((IPosition) entityliving.getPositionVector(), 48.0D) && entityliving.getEntityType().a((Tag) TagsEntity.RADIERS);
+    }
+
+    private void b(EntityLiving entityliving) {
+        entityliving.addEffect(new MobEffect(MobEffects.GLOWING, 60));
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TileEntityEnderChest.java b/src/main/java/net/minecraft/world/level/block/entity/TileEntityEnderChest.java
new file mode 100644
index 0000000000000000000000000000000000000000..930f1bd091d9754f7ca5d9e36cdf49b2be03eb23
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/entity/TileEntityEnderChest.java
@@ -0,0 +1,97 @@
+package net.minecraft.world.level.block.entity;
+
+import net.minecraft.sounds.SoundCategory;
+import net.minecraft.sounds.SoundEffects;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.level.block.Blocks;
+
+public class TileEntityEnderChest extends TileEntity implements ITickable {
+
+    public float a;
+    public float b;
+    public int c;
+    private int g;
+
+    public TileEntityEnderChest() {
+        super(TileEntityTypes.ENDER_CHEST);
+    }
+
+    @Override
+    public void tick() {
+        if (++this.g % 20 * 4 == 0) {
+            this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.c);
+        }
+
+        this.b = this.a;
+        int i = this.position.getX();
+        int j = this.position.getY();
+        int k = this.position.getZ();
+        float f = 0.1F;
+        double d0;
+
+        if (this.c > 0 && this.a == 0.0F) {
+            double d1 = (double) i + 0.5D;
+
+            d0 = (double) k + 0.5D;
+            this.world.playSound((EntityHuman) null, d1, (double) j + 0.5D, d0, SoundEffects.BLOCK_ENDER_CHEST_OPEN, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.c == 0 && this.a > 0.0F || this.c > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.c > 0) {
+                this.a += 0.1F;
+            } else {
+                this.a -= 0.1F;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < 0.5F && f1 >= 0.5F) {
+                d0 = (double) i + 0.5D;
+                double d2 = (double) k + 0.5D;
+
+                this.world.playSound((EntityHuman) null, d0, (double) j + 0.5D, d2, SoundEffects.BLOCK_ENDER_CHEST_CLOSE, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+
+    }
+
+    @Override
+    public boolean setProperty(int i, int j) {
+        if (i == 1) {
+            this.c = j;
+            return true;
+        } else {
+            return super.setProperty(i, j);
+        }
+    }
+
+    @Override
+    public void al_() {
+        this.invalidateBlockCache();
+        super.al_();
+    }
+
+    public void d() {
+        ++this.c;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.c);
+    }
+
+    public void f() {
+        --this.c;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.c);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.position) != this ? false : entityhuman.h((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TileEntityLootable.java b/src/main/java/net/minecraft/world/level/block/entity/TileEntityLootable.java
new file mode 100644
index 0000000000000000000000000000000000000000..62e6833a90d7adae3c7df33e3bc73b4288e0370b
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/entity/TileEntityLootable.java
@@ -0,0 +1,162 @@
+package net.minecraft.world.level.block.entity;
+
+import java.util.Random;
+import javax.annotation.Nullable;
+import net.minecraft.advancements.CriterionTriggers;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.NonNullList;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.ContainerUtil;
+import net.minecraft.world.entity.player.EntityHuman;
+import net.minecraft.world.entity.player.PlayerInventory;
+import net.minecraft.world.inventory.Container;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.storage.loot.LootTable;
+import net.minecraft.world.level.storage.loot.LootTableInfo;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParameterSets;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParameters;
+import net.minecraft.world.phys.Vec3D;
+
+public abstract class TileEntityLootable extends TileEntityContainer {
+
+    @Nullable
+    public MinecraftKey lootTable;
+    public long lootTableSeed;
+
+    protected TileEntityLootable(TileEntityTypes<?> tileentitytypes) {
+        super(tileentitytypes);
+    }
+
+    public static void a(IBlockAccess iblockaccess, Random random, BlockPosition blockposition, MinecraftKey minecraftkey) {
+        TileEntity tileentity = iblockaccess.getTileEntity(blockposition);
+
+        if (tileentity instanceof TileEntityLootable) {
+            ((TileEntityLootable) tileentity).setLootTable(minecraftkey, random.nextLong());
+        }
+
+    }
+
+    protected boolean b(NBTTagCompound nbttagcompound) {
+        if (nbttagcompound.hasKeyOfType("LootTable", 8)) {
+            this.lootTable = new MinecraftKey(nbttagcompound.getString("LootTable"));
+            this.lootTableSeed = nbttagcompound.getLong("LootTableSeed");
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    protected boolean c(NBTTagCompound nbttagcompound) {
+        if (this.lootTable == null) {
+            return false;
+        } else {
+            nbttagcompound.setString("LootTable", this.lootTable.toString());
+            if (this.lootTableSeed != 0L) {
+                nbttagcompound.setLong("LootTableSeed", this.lootTableSeed);
+            }
+
+            return true;
+        }
+    }
+
+    public void d(@Nullable EntityHuman entityhuman) {
+        if (this.lootTable != null && this.world.getMinecraftServer() != null) {
+            LootTable loottable = this.world.getMinecraftServer().getLootTableRegistry().getLootTable(this.lootTable);
+
+            if (entityhuman instanceof EntityPlayer) {
+                CriterionTriggers.N.a((EntityPlayer) entityhuman, this.lootTable);
+            }
+
+            this.lootTable = null;
+            LootTableInfo.Builder loottableinfo_builder = (new LootTableInfo.Builder((WorldServer) this.world)).set(LootContextParameters.ORIGIN, Vec3D.a((BaseBlockPosition) this.position)).a(this.lootTableSeed);
+
+            if (entityhuman != null) {
+                loottableinfo_builder.a(entityhuman.eU()).set(LootContextParameters.THIS_ENTITY, entityhuman);
+            }
+
+            loottable.fillInventory(this, loottableinfo_builder.build(LootContextParameterSets.CHEST));
+        }
+
+    }
+
+    public void setLootTable(MinecraftKey minecraftkey, long i) {
+        this.lootTable = minecraftkey;
+        this.lootTableSeed = i;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        this.d((EntityHuman) null);
+        return this.f().stream().allMatch(ItemStack::isEmpty);
+    }
+
+    @Override
+    public ItemStack getItem(int i) {
+        this.d((EntityHuman) null);
+        return (ItemStack) this.f().get(i);
+    }
+
+    @Override
+    public ItemStack splitStack(int i, int j) {
+        this.d((EntityHuman) null);
+        ItemStack itemstack = ContainerUtil.a(this.f(), i, j);
+
+        if (!itemstack.isEmpty()) {
+            this.update();
+        }
+
+        return itemstack;
+    }
+
+    @Override
+    public ItemStack splitWithoutUpdate(int i) {
+        this.d((EntityHuman) null);
+        return ContainerUtil.a(this.f(), i);
+    }
+
+    @Override
+    public void setItem(int i, ItemStack itemstack) {
+        this.d((EntityHuman) null);
+        this.f().set(i, itemstack);
+        if (itemstack.getCount() > this.getMaxStackSize()) {
+            itemstack.setCount(this.getMaxStackSize());
+        }
+
+        this.update();
+    }
+
+    @Override
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.position) != this ? false : entityhuman.h((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
+    }
+
+    @Override
+    public void clear() {
+        this.f().clear();
+    }
+
+    protected abstract NonNullList<ItemStack> f();
+
+    protected abstract void a(NonNullList<ItemStack> nonnulllist);
+
+    @Override
+    public boolean e(EntityHuman entityhuman) {
+        return super.e(entityhuman) && (this.lootTable == null || !entityhuman.isSpectator());
+    }
+
+    @Nullable
+    @Override
+    public Container createMenu(int i, PlayerInventory playerinventory, EntityHuman entityhuman) {
+        if (this.e(entityhuman)) {
+            this.d(playerinventory.player);
+            return this.createContainer(i, playerinventory);
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/piston/TileEntityPiston.java b/src/main/java/net/minecraft/world/level/block/piston/TileEntityPiston.java
new file mode 100644
index 0000000000000000000000000000000000000000..a549195e67236c0146861b896fb9e4907073af58
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/piston/TileEntityPiston.java
@@ -0,0 +1,364 @@
+package net.minecraft.world.level.block.piston;
+
+import java.util.Iterator;
+import java.util.List;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.nbt.GameProfileSerializer;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EnumMoveType;
+import net.minecraft.world.level.GeneratorAccess;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.ITickable;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.entity.TileEntityTypes;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.properties.BlockProperties;
+import net.minecraft.world.level.block.state.properties.BlockPropertyPistonType;
+import net.minecraft.world.level.material.EnumPistonReaction;
+import net.minecraft.world.phys.AxisAlignedBB;
+import net.minecraft.world.phys.Vec3D;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+
+public class TileEntityPiston extends TileEntity implements ITickable {
+
+    private IBlockData a;
+    private EnumDirection b;
+    private boolean c;
+    private boolean g;
+    private static final ThreadLocal<EnumDirection> h = ThreadLocal.withInitial(() -> {
+        return null;
+    });
+    private float i;
+    private float j;
+    private long k;
+    private int l;
+
+    public TileEntityPiston() {
+        super(TileEntityTypes.PISTON);
+    }
+
+    public TileEntityPiston(IBlockData iblockdata, EnumDirection enumdirection, boolean flag, boolean flag1) {
+        this();
+        this.a = iblockdata;
+        this.b = enumdirection;
+        this.c = flag;
+        this.g = flag1;
+    }
+
+    @Override
+    public NBTTagCompound b() {
+        return this.save(new NBTTagCompound());
+    }
+
+    public boolean d() {
+        return this.c;
+    }
+
+    public EnumDirection f() {
+        return this.b;
+    }
+
+    public boolean h() {
+        return this.g;
+    }
+
+    public float a(float f) {
+        if (f > 1.0F) {
+            f = 1.0F;
+        }
+
+        return MathHelper.g(f, this.j, this.i);
+    }
+
+    private float e(float f) {
+        return this.c ? f - 1.0F : 1.0F - f;
+    }
+
+    private IBlockData x() {
+        return !this.d() && this.h() && this.a.getBlock() instanceof BlockPiston ? (IBlockData) ((IBlockData) ((IBlockData) Blocks.PISTON_HEAD.getBlockData().set(BlockPistonExtension.SHORT, this.i > 0.25F)).set(BlockPistonExtension.TYPE, this.a.a(Blocks.STICKY_PISTON) ? BlockPropertyPistonType.STICKY : BlockPropertyPistonType.DEFAULT)).set(BlockPistonExtension.FACING, this.a.get(BlockPiston.FACING)) : this.a;
+    }
+
+    private void f(float f) {
+        EnumDirection enumdirection = this.j();
+        double d0 = (double) (f - this.i);
+        VoxelShape voxelshape = this.x().getCollisionShape(this.world, this.getPosition());
+
+        if (!voxelshape.isEmpty()) {
+            AxisAlignedBB axisalignedbb = this.a(voxelshape.getBoundingBox());
+            List<Entity> list = this.world.getEntities((Entity) null, PistonUtil.a(axisalignedbb, enumdirection, d0).b(axisalignedbb));
+
+            if (!list.isEmpty()) {
+                List<AxisAlignedBB> list1 = voxelshape.d();
+                boolean flag = this.a.a(Blocks.SLIME_BLOCK);
+                Iterator iterator = list.iterator();
+
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
+
+                    if (entity.getPushReaction() != EnumPistonReaction.IGNORE) {
+                        if (flag) {
+                            if (entity instanceof EntityPlayer) {
+                                continue;
+                            }
+
+                            Vec3D vec3d = entity.getMot();
+                            double d1 = vec3d.x;
+                            double d2 = vec3d.y;
+                            double d3 = vec3d.z;
+
+                            switch (enumdirection.n()) {
+                                case X:
+                                    d1 = (double) enumdirection.getAdjacentX();
+                                    break;
+                                case Y:
+                                    d2 = (double) enumdirection.getAdjacentY();
+                                    break;
+                                case Z:
+                                    d3 = (double) enumdirection.getAdjacentZ();
+                            }
+
+                            entity.setMot(d1, d2, d3);
+                        }
+
+                        double d4 = 0.0D;
+                        Iterator iterator1 = list1.iterator();
+
+                        while (iterator1.hasNext()) {
+                            AxisAlignedBB axisalignedbb1 = (AxisAlignedBB) iterator1.next();
+                            AxisAlignedBB axisalignedbb2 = PistonUtil.a(this.a(axisalignedbb1), enumdirection, d0);
+                            AxisAlignedBB axisalignedbb3 = entity.getBoundingBox();
+
+                            if (axisalignedbb2.c(axisalignedbb3)) {
+                                d4 = Math.max(d4, a(axisalignedbb2, enumdirection, axisalignedbb3));
+                                if (d4 >= d0) {
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (d4 > 0.0D) {
+                            d4 = Math.min(d4, d0) + 0.01D;
+                            a(enumdirection, entity, d4, enumdirection);
+                            if (!this.c && this.g) {
+                                this.a(entity, enumdirection, d0);
+                            }
+                        }
+                    }
+                }
+
+            }
+        }
+    }
+
+    private static void a(EnumDirection enumdirection, Entity entity, double d0, EnumDirection enumdirection1) {
+        TileEntityPiston.h.set(enumdirection);
+        entity.move(EnumMoveType.PISTON, new Vec3D(d0 * (double) enumdirection1.getAdjacentX(), d0 * (double) enumdirection1.getAdjacentY(), d0 * (double) enumdirection1.getAdjacentZ()));
+        TileEntityPiston.h.set((Object) null);
+    }
+
+    private void g(float f) {
+        if (this.y()) {
+            EnumDirection enumdirection = this.j();
+
+            if (enumdirection.n().d()) {
+                double d0 = this.a.getCollisionShape(this.world, this.position).c(EnumDirection.EnumAxis.Y);
+                AxisAlignedBB axisalignedbb = this.a(new AxisAlignedBB(0.0D, d0, 0.0D, 1.0D, 1.5000000999999998D, 1.0D));
+                double d1 = (double) (f - this.i);
+                List<Entity> list = this.world.getEntities((Entity) null, axisalignedbb, (entity) -> {
+                    return a(axisalignedbb, entity);
+                });
+                Iterator iterator = list.iterator();
+
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
+
+                    a(enumdirection, entity, d1, enumdirection);
+                }
+
+            }
+        }
+    }
+
+    private static boolean a(AxisAlignedBB axisalignedbb, Entity entity) {
+        return entity.getPushReaction() == EnumPistonReaction.NORMAL && entity.isOnGround() && entity.locX() >= axisalignedbb.minX && entity.locX() <= axisalignedbb.maxX && entity.locZ() >= axisalignedbb.minZ && entity.locZ() <= axisalignedbb.maxZ;
+    }
+
+    private boolean y() {
+        return this.a.a(Blocks.HONEY_BLOCK);
+    }
+
+    public EnumDirection j() {
+        return this.c ? this.b : this.b.opposite();
+    }
+
+    private static double a(AxisAlignedBB axisalignedbb, EnumDirection enumdirection, AxisAlignedBB axisalignedbb1) {
+        switch (enumdirection) {
+            case EAST:
+                return axisalignedbb.maxX - axisalignedbb1.minX;
+            case WEST:
+                return axisalignedbb1.maxX - axisalignedbb.minX;
+            case UP:
+            default:
+                return axisalignedbb.maxY - axisalignedbb1.minY;
+            case DOWN:
+                return axisalignedbb1.maxY - axisalignedbb.minY;
+            case SOUTH:
+                return axisalignedbb.maxZ - axisalignedbb1.minZ;
+            case NORTH:
+                return axisalignedbb1.maxZ - axisalignedbb.minZ;
+        }
+    }
+
+    private AxisAlignedBB a(AxisAlignedBB axisalignedbb) {
+        double d0 = (double) this.e(this.i);
+
+        return axisalignedbb.d((double) this.position.getX() + d0 * (double) this.b.getAdjacentX(), (double) this.position.getY() + d0 * (double) this.b.getAdjacentY(), (double) this.position.getZ() + d0 * (double) this.b.getAdjacentZ());
+    }
+
+    private void a(Entity entity, EnumDirection enumdirection, double d0) {
+        AxisAlignedBB axisalignedbb = entity.getBoundingBox();
+        AxisAlignedBB axisalignedbb1 = VoxelShapes.b().getBoundingBox().a(this.position);
+
+        if (axisalignedbb.c(axisalignedbb1)) {
+            EnumDirection enumdirection1 = enumdirection.opposite();
+            double d1 = a(axisalignedbb1, enumdirection1, axisalignedbb) + 0.01D;
+            double d2 = a(axisalignedbb1, enumdirection1, axisalignedbb.a(axisalignedbb1)) + 0.01D;
+
+            if (Math.abs(d1 - d2) < 0.01D) {
+                d1 = Math.min(d1, d0) + 0.01D;
+                a(enumdirection, entity, d1, enumdirection1);
+            }
+        }
+
+    }
+
+    public IBlockData k() {
+        return this.a;
+    }
+
+    public void l() {
+        if (this.world != null && (this.j < 1.0F || this.world.isClientSide)) {
+            this.i = 1.0F;
+            this.j = this.i;
+            this.world.removeTileEntity(this.position);
+            this.al_();
+            if (this.world.getType(this.position).a(Blocks.MOVING_PISTON)) {
+                IBlockData iblockdata;
+
+                if (this.g) {
+                    iblockdata = Blocks.AIR.getBlockData();
+                } else {
+                    iblockdata = Block.b(this.a, (GeneratorAccess) this.world, this.position);
+                }
+
+                this.world.setTypeAndData(this.position, iblockdata, 3);
+                this.world.a(this.position, iblockdata.getBlock(), this.position);
+            }
+        }
+
+    }
+
+    @Override
+    public void tick() {
+        this.k = this.world.getTime();
+        this.j = this.i;
+        if (this.j >= 1.0F) {
+            if (this.world.isClientSide && this.l < 5) {
+                ++this.l;
+            } else {
+                this.world.removeTileEntity(this.position);
+                this.al_();
+                if (this.a != null && this.world.getType(this.position).a(Blocks.MOVING_PISTON)) {
+                    IBlockData iblockdata = Block.b(this.a, (GeneratorAccess) this.world, this.position);
+
+                    if (iblockdata.isAir()) {
+                        this.world.setTypeAndData(this.position, this.a, 84);
+                        Block.a(this.a, iblockdata, this.world, this.position, 3);
+                    } else {
+                        if (iblockdata.b(BlockProperties.C) && (Boolean) iblockdata.get(BlockProperties.C)) {
+                            iblockdata = (IBlockData) iblockdata.set(BlockProperties.C, false);
+                        }
+
+                        this.world.setTypeAndData(this.position, iblockdata, 67);
+                        this.world.a(this.position, iblockdata.getBlock(), this.position);
+                    }
+                }
+
+            }
+        } else {
+            float f = this.i + 0.5F;
+
+            this.f(f);
+            this.g(f);
+            this.i = f;
+            if (this.i >= 1.0F) {
+                this.i = 1.0F;
+            }
+
+        }
+    }
+
+    @Override
+    public void load(IBlockData iblockdata, NBTTagCompound nbttagcompound) {
+        super.load(iblockdata, nbttagcompound);
+        this.a = GameProfileSerializer.c(nbttagcompound.getCompound("blockState"));
+        this.b = EnumDirection.fromType1(nbttagcompound.getInt("facing"));
+        this.i = nbttagcompound.getFloat("progress");
+        this.j = this.i;
+        this.c = nbttagcompound.getBoolean("extending");
+        this.g = nbttagcompound.getBoolean("source");
+    }
+
+    @Override
+    public NBTTagCompound save(NBTTagCompound nbttagcompound) {
+        super.save(nbttagcompound);
+        nbttagcompound.set("blockState", GameProfileSerializer.a(this.a));
+        nbttagcompound.setInt("facing", this.b.c());
+        nbttagcompound.setFloat("progress", this.j);
+        nbttagcompound.setBoolean("extending", this.c);
+        nbttagcompound.setBoolean("source", this.g);
+        return nbttagcompound;
+    }
+
+    public VoxelShape a(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        VoxelShape voxelshape;
+
+        if (!this.c && this.g) {
+            voxelshape = ((IBlockData) this.a.set(BlockPiston.EXTENDED, true)).getCollisionShape(iblockaccess, blockposition);
+        } else {
+            voxelshape = VoxelShapes.a();
+        }
+
+        EnumDirection enumdirection = (EnumDirection) TileEntityPiston.h.get();
+
+        if ((double) this.i < 1.0D && enumdirection == this.j()) {
+            return voxelshape;
+        } else {
+            IBlockData iblockdata;
+
+            if (this.h()) {
+                iblockdata = (IBlockData) ((IBlockData) Blocks.PISTON_HEAD.getBlockData().set(BlockPistonExtension.FACING, this.b)).set(BlockPistonExtension.SHORT, this.c != 1.0F - this.i < 0.25F);
+            } else {
+                iblockdata = this.a;
+            }
+
+            float f = this.e(this.i);
+            double d0 = (double) ((float) this.b.getAdjacentX() * f);
+            double d1 = (double) ((float) this.b.getAdjacentY() * f);
+            double d2 = (double) ((float) this.b.getAdjacentZ() * f);
+
+            return VoxelShapes.a(voxelshape, iblockdata.getCollisionShape(iblockaccess, blockposition).a(d0, d1, d2));
+        }
+    }
+
+    public long m() {
+        return this.k;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/state/IBlockData.java b/src/main/java/net/minecraft/world/level/block/state/IBlockData.java
new file mode 100644
index 0000000000000000000000000000000000000000..9e1ebfd7befe9e2fc3396b4dcd5e8fc7c23ee305
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/state/IBlockData.java
@@ -0,0 +1,22 @@
+package net.minecraft.world.level.block.state;
+
+import com.google.common.collect.ImmutableMap;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.MapCodec;
+import net.minecraft.core.IRegistry;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.properties.IBlockState;
+
+public class IBlockData extends BlockBase.BlockData {
+
+    public static final Codec<IBlockData> b = a((Codec) IRegistry.BLOCK, Block::getBlockData).stable();
+
+    public IBlockData(Block block, ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap, MapCodec<IBlockData> mapcodec) {
+        super(block, immutablemap, mapcodec);
+    }
+
+    @Override
+    protected IBlockData p() {
+        return this;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/state/IBlockDataHolder.java b/src/main/java/net/minecraft/world/level/block/state/IBlockDataHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..074bd5f060c6bb80568b72d23ce84c27ba774578
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/state/IBlockDataHolder.java
@@ -0,0 +1,170 @@
+package net.minecraft.world.level.block.state;
+
+import com.google.common.collect.ArrayTable;
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Table;
+import com.google.common.collect.UnmodifiableIterator;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.MapCodec;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
+import net.minecraft.world.level.block.state.properties.IBlockState;
+
+public abstract class IBlockDataHolder<O, S> {
+
+    public static final Function<Entry<IBlockState<?>, Comparable<?>>, String> STATE_TO_VALUE = new Function<Entry<IBlockState<?>, Comparable<?>>, String>() {
+        public String apply(@Nullable Entry<IBlockState<?>, Comparable<?>> entry) {
+            if (entry == null) {
+                return "<NULL>";
+            } else {
+                IBlockState<?> iblockstate = (IBlockState) entry.getKey();
+
+                return iblockstate.getName() + "=" + this.a(iblockstate, (Comparable) entry.getValue());
+            }
+        }
+
+        private <T extends Comparable<T>> String a(IBlockState<T> iblockstate, Comparable<?> comparable) {
+            return iblockstate.a(comparable);
+        }
+    };
+    protected final O c;
+    private final ImmutableMap<IBlockState<?>, Comparable<?>> b;
+    private Table<IBlockState<?>, Comparable<?>, S> e;
+    protected final MapCodec<S> d;
+
+    protected IBlockDataHolder(O o0, ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap, MapCodec<S> mapcodec) {
+        this.c = o0;
+        this.b = immutablemap;
+        this.d = mapcodec;
+    }
+
+    public <T extends Comparable<T>> S a(IBlockState<T> iblockstate) {
+        return this.set(iblockstate, (Comparable) a(iblockstate.getValues(), (Object) this.get(iblockstate)));
+    }
+
+    protected static <T> T a(Collection<T> collection, T t0) {
+        Iterator iterator = collection.iterator();
+
+        do {
+            if (!iterator.hasNext()) {
+                return iterator.next();
+            }
+        } while (!iterator.next().equals(t0));
+
+        if (iterator.hasNext()) {
+            return iterator.next();
+        } else {
+            return collection.iterator().next();
+        }
+    }
+
+    public String toString() {
+        StringBuilder stringbuilder = new StringBuilder();
+
+        stringbuilder.append(this.c);
+        if (!this.getStateMap().isEmpty()) {
+            stringbuilder.append('[');
+            stringbuilder.append((String) this.getStateMap().entrySet().stream().map(IBlockDataHolder.STATE_TO_VALUE).collect(Collectors.joining(",")));
+            stringbuilder.append(']');
+        }
+
+        return stringbuilder.toString();
+    }
+
+    public Collection<IBlockState<?>> r() {
+        return Collections.unmodifiableCollection(this.b.keySet());
+    }
+
+    public <T extends Comparable<T>> boolean b(IBlockState<T> iblockstate) {
+        return this.b.containsKey(iblockstate);
+    }
+
+    public <T extends Comparable<T>> T get(IBlockState<T> iblockstate) {
+        Comparable<?> comparable = (Comparable) this.b.get(iblockstate);
+
+        if (comparable == null) {
+            throw new IllegalArgumentException("Cannot get property " + iblockstate + " as it does not exist in " + this.c);
+        } else {
+            return (Comparable) iblockstate.getType().cast(comparable);
+        }
+    }
+
+    public <T extends Comparable<T>> Optional<T> d(IBlockState<T> iblockstate) {
+        Comparable<?> comparable = (Comparable) this.b.get(iblockstate);
+
+        return comparable == null ? Optional.empty() : Optional.of(iblockstate.getType().cast(comparable));
+    }
+
+    public <T extends Comparable<T>, V extends T> S set(IBlockState<T> iblockstate, V v0) {
+        Comparable<?> comparable = (Comparable) this.b.get(iblockstate);
+
+        if (comparable == null) {
+            throw new IllegalArgumentException("Cannot set property " + iblockstate + " as it does not exist in " + this.c);
+        } else if (comparable == v0) {
+            return this;
+        } else {
+            S s0 = this.e.get(iblockstate, v0);
+
+            if (s0 == null) {
+                throw new IllegalArgumentException("Cannot set property " + iblockstate + " to " + v0 + " on " + this.c + ", it is not an allowed value");
+            } else {
+                return s0;
+            }
+        }
+    }
+
+    public void a(Map<Map<IBlockState<?>, Comparable<?>>, S> map) {
+        if (this.e != null) {
+            throw new IllegalStateException();
+        } else {
+            Table<IBlockState<?>, Comparable<?>, S> table = HashBasedTable.create();
+            UnmodifiableIterator unmodifiableiterator = this.b.entrySet().iterator();
+
+            while (unmodifiableiterator.hasNext()) {
+                Entry<IBlockState<?>, Comparable<?>> entry = (Entry) unmodifiableiterator.next();
+                IBlockState<?> iblockstate = (IBlockState) entry.getKey();
+                Iterator iterator = iblockstate.getValues().iterator();
+
+                while (iterator.hasNext()) {
+                    Comparable<?> comparable = (Comparable) iterator.next();
+
+                    if (comparable != entry.getValue()) {
+                        table.put(iblockstate, comparable, map.get(this.b(iblockstate, comparable)));
+                    }
+                }
+            }
+
+            this.e = (Table) (table.isEmpty() ? table : ArrayTable.create(table));
+        }
+    }
+
+    private Map<IBlockState<?>, Comparable<?>> b(IBlockState<?> iblockstate, Comparable<?> comparable) {
+        Map<IBlockState<?>, Comparable<?>> map = Maps.newHashMap(this.b);
+
+        map.put(iblockstate, comparable);
+        return map;
+    }
+
+    public ImmutableMap<IBlockState<?>, Comparable<?>> getStateMap() {
+        return this.b;
+    }
+
+    protected static <O, S extends IBlockDataHolder<O, S>> Codec<S> a(Codec<O> codec, Function<O, S> function) {
+        return codec.dispatch("Name", (iblockdataholder) -> {
+            return iblockdataholder.c;
+        }, (object) -> {
+            S s0 = (IBlockDataHolder) function.apply(object);
+
+            return s0.getStateMap().isEmpty() ? Codec.unit(s0) : s0.d.fieldOf("Properties").codec();
+        });
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/state/properties/BlockStateBoolean.java b/src/main/java/net/minecraft/world/level/block/state/properties/BlockStateBoolean.java
new file mode 100644
index 0000000000000000000000000000000000000000..0701c1a178852345b6bf01bce8b1d0559c535d45
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/state/properties/BlockStateBoolean.java
@@ -0,0 +1,50 @@
+package net.minecraft.world.level.block.state.properties;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.Collection;
+import java.util.Optional;
+
+public class BlockStateBoolean extends IBlockState<Boolean> {
+
+    private final ImmutableSet<Boolean> a = ImmutableSet.of(true, false);
+
+    protected BlockStateBoolean(String s) {
+        super(s, Boolean.class);
+    }
+
+    @Override
+    public Collection<Boolean> getValues() {
+        return this.a;
+    }
+
+    public static BlockStateBoolean of(String s) {
+        return new BlockStateBoolean(s);
+    }
+
+    @Override
+    public Optional<Boolean> b(String s) {
+        return !"true".equals(s) && !"false".equals(s) ? Optional.empty() : Optional.of(Boolean.valueOf(s));
+    }
+
+    public String a(Boolean obool) {
+        return obool.toString();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (object instanceof BlockStateBoolean && super.equals(object)) {
+            BlockStateBoolean blockstateboolean = (BlockStateBoolean) object;
+
+            return this.a.equals(blockstateboolean.a);
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public int b() {
+        return 31 * super.b() + this.a.hashCode();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/state/properties/BlockStateEnum.java b/src/main/java/net/minecraft/world/level/block/state/properties/BlockStateEnum.java
new file mode 100644
index 0000000000000000000000000000000000000000..a6aaf0efed5a9c5e458ca04a80a7a5e71a31d886
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/state/properties/BlockStateEnum.java
@@ -0,0 +1,90 @@
+package net.minecraft.world.level.block.state.properties;
+
+import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import net.minecraft.util.INamable;
+
+public class BlockStateEnum<T extends Enum<T> & INamable> extends IBlockState<T> {
+
+    private final ImmutableSet<T> a;
+    private final Map<String, T> b = Maps.newHashMap();
+
+    protected BlockStateEnum(String s, Class<T> oclass, Collection<T> collection) {
+        super(s, oclass);
+        this.a = ImmutableSet.copyOf(collection);
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            T t0 = (Enum) iterator.next();
+            String s1 = ((INamable) t0).getName();
+
+            if (this.b.containsKey(s1)) {
+                throw new IllegalArgumentException("Multiple values have the same name '" + s1 + "'");
+            }
+
+            this.b.put(s1, t0);
+        }
+
+    }
+
+    @Override
+    public Collection<T> getValues() {
+        return this.a;
+    }
+
+    @Override
+    public Optional<T> b(String s) {
+        return Optional.ofNullable(this.b.get(s));
+    }
+
+    public String a(T t0) {
+        return ((INamable) t0).getName();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (object instanceof BlockStateEnum && super.equals(object)) {
+            BlockStateEnum<?> blockstateenum = (BlockStateEnum) object;
+
+            return this.a.equals(blockstateenum.a) && this.b.equals(blockstateenum.b);
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public int b() {
+        int i = super.b();
+
+        i = 31 * i + this.a.hashCode();
+        i = 31 * i + this.b.hashCode();
+        return i;
+    }
+
+    public static <T extends Enum<T> & INamable> BlockStateEnum<T> of(String s, Class<T> oclass) {
+        return a(s, oclass, (Predicate) Predicates.alwaysTrue());
+    }
+
+    public static <T extends Enum<T> & INamable> BlockStateEnum<T> a(String s, Class<T> oclass, Predicate<T> predicate) {
+        return a(s, oclass, (Collection) Arrays.stream(oclass.getEnumConstants()).filter(predicate).collect(Collectors.toList()));
+    }
+
+    public static <T extends Enum<T> & INamable> BlockStateEnum<T> of(String s, Class<T> oclass, T... at) {
+        return a(s, oclass, (Collection) Lists.newArrayList(at));
+    }
+
+    public static <T extends Enum<T> & INamable> BlockStateEnum<T> a(String s, Class<T> oclass, Collection<T> collection) {
+        return new BlockStateEnum<>(s, oclass, collection);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/state/properties/IBlockState.java b/src/main/java/net/minecraft/world/level/block/state/properties/IBlockState.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e6ba74027685c6190426c825736e84cda87ca63
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/state/properties/IBlockState.java
@@ -0,0 +1,133 @@
+package net.minecraft.world.level.block.state.properties;
+
+import com.google.common.base.MoreObjects;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import java.util.Collection;
+import java.util.Optional;
+import java.util.stream.Stream;
+import net.minecraft.world.level.block.state.IBlockDataHolder;
+
+public abstract class IBlockState<T extends Comparable<T>> {
+
+    private final Class<T> a;
+    private final String b;
+    private Integer c;
+    private final Codec<T> d;
+    private final Codec<IBlockState.a<T>> e;
+
+    protected IBlockState(String s, Class<T> oclass) {
+        this.d = Codec.STRING.comapFlatMap((s1) -> {
+            return (DataResult) this.b(s1).map(DataResult::success).orElseGet(() -> {
+                return DataResult.error("Unable to read property: " + this + " with value: " + s1);
+            });
+        }, this::a);
+        this.e = this.d.xmap(this::b, IBlockState.a::b);
+        this.a = oclass;
+        this.b = s;
+    }
+
+    public IBlockState.a<T> b(T t0) {
+        return new IBlockState.a<>(this, t0);
+    }
+
+    public IBlockState.a<T> a(IBlockDataHolder<?, ?> iblockdataholder) {
+        return new IBlockState.a<>(this, iblockdataholder.get(this));
+    }
+
+    public Stream<IBlockState.a<T>> c() {
+        return this.getValues().stream().map(this::b);
+    }
+
+    public Codec<IBlockState.a<T>> e() {
+        return this.e;
+    }
+
+    public String getName() {
+        return this.b;
+    }
+
+    public Class<T> getType() {
+        return this.a;
+    }
+
+    public abstract Collection<T> getValues();
+
+    public abstract String a(T t0);
+
+    public abstract Optional<T> b(String s);
+
+    public String toString() {
+        return MoreObjects.toStringHelper(this).add("name", this.b).add("clazz", this.a).add("values", this.getValues()).toString();
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof IBlockState)) {
+            return false;
+        } else {
+            IBlockState<?> iblockstate = (IBlockState) object;
+
+            return this.a.equals(iblockstate.a) && this.b.equals(iblockstate.b);
+        }
+    }
+
+    public final int hashCode() {
+        if (this.c == null) {
+            this.c = this.b();
+        }
+
+        return this.c;
+    }
+
+    public int b() {
+        return 31 * this.a.hashCode() + this.b.hashCode();
+    }
+
+    public static final class a<T extends Comparable<T>> {
+
+        private final IBlockState<T> a;
+        private final T b;
+
+        private a(IBlockState<T> iblockstate, T t0) {
+            if (!iblockstate.getValues().contains(t0)) {
+                throw new IllegalArgumentException("Value " + t0 + " does not belong to property " + iblockstate);
+            } else {
+                this.a = iblockstate;
+                this.b = t0;
+            }
+        }
+
+        public IBlockState<T> a() {
+            return this.a;
+        }
+
+        public T b() {
+            return this.b;
+        }
+
+        public String toString() {
+            return this.a.getName() + "=" + this.a.a(this.b);
+        }
+
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            } else if (!(object instanceof IBlockState.a)) {
+                return false;
+            } else {
+                IBlockState.a<?> iblockstate_a = (IBlockState.a) object;
+
+                return this.a == iblockstate_a.a && this.b.equals(iblockstate_a.b);
+            }
+        }
+
+        public int hashCode() {
+            int i = this.a.hashCode();
+
+            i = 31 * i + this.b.hashCode();
+            return i;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkConverter.java b/src/main/java/net/minecraft/world/level/chunk/ChunkConverter.java
new file mode 100644
index 0000000000000000000000000000000000000000..60ecd3a92af0f1968b10bb8babfb43147ef568d3
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkConverter.java
@@ -0,0 +1,390 @@
+package net.minecraft.world.level.chunk;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import java.util.EnumSet;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.EnumDirection8;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.GeneratorAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BlockChest;
+import net.minecraft.world.level.block.BlockFacingHorizontal;
+import net.minecraft.world.level.block.BlockStem;
+import net.minecraft.world.level.block.BlockStemmed;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.entity.TileEntityChest;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.properties.BlockProperties;
+import net.minecraft.world.level.block.state.properties.BlockPropertyChestType;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ChunkConverter {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    public static final ChunkConverter a = new ChunkConverter();
+    private static final EnumDirection8[] c = EnumDirection8.values();
+    private final EnumSet<EnumDirection8> d;
+    private final int[][] e;
+    private static final Map<Block, ChunkConverter.a> f = new IdentityHashMap();
+    private static final Set<ChunkConverter.a> g = Sets.newHashSet();
+
+    private ChunkConverter() {
+        this.d = EnumSet.noneOf(EnumDirection8.class);
+        this.e = new int[16][];
+    }
+
+    public ChunkConverter(NBTTagCompound nbttagcompound) {
+        this();
+        if (nbttagcompound.hasKeyOfType("Indices", 10)) {
+            NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Indices");
+
+            for (int i = 0; i < this.e.length; ++i) {
+                String s = String.valueOf(i);
+
+                if (nbttagcompound1.hasKeyOfType(s, 11)) {
+                    this.e[i] = nbttagcompound1.getIntArray(s);
+                }
+            }
+        }
+
+        int j = nbttagcompound.getInt("Sides");
+        EnumDirection8[] aenumdirection8 = EnumDirection8.values();
+        int k = aenumdirection8.length;
+
+        for (int l = 0; l < k; ++l) {
+            EnumDirection8 enumdirection8 = aenumdirection8[l];
+
+            if ((j & 1 << enumdirection8.ordinal()) != 0) {
+                this.d.add(enumdirection8);
+            }
+        }
+
+    }
+
+    public void a(Chunk chunk) {
+        this.b(chunk);
+        EnumDirection8[] aenumdirection8 = ChunkConverter.c;
+        int i = aenumdirection8.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDirection8 enumdirection8 = aenumdirection8[j];
+
+            a(chunk, enumdirection8);
+        }
+
+        World world = chunk.getWorld();
+
+        ChunkConverter.g.forEach((chunkconverter_a) -> {
+            chunkconverter_a.a(world);
+        });
+    }
+
+    private static void a(Chunk chunk, EnumDirection8 enumdirection8) {
+        World world = chunk.getWorld();
+
+        if (chunk.p().d.remove(enumdirection8)) {
+            Set<EnumDirection> set = enumdirection8.a();
+            boolean flag = false;
+            boolean flag1 = true;
+            boolean flag2 = set.contains(EnumDirection.EAST);
+            boolean flag3 = set.contains(EnumDirection.WEST);
+            boolean flag4 = set.contains(EnumDirection.SOUTH);
+            boolean flag5 = set.contains(EnumDirection.NORTH);
+            boolean flag6 = set.size() == 1;
+            ChunkCoordIntPair chunkcoordintpair = chunk.getPos();
+            int i = chunkcoordintpair.d() + (flag6 && (flag5 || flag4) ? 1 : (flag3 ? 0 : 15));
+            int j = chunkcoordintpair.d() + (flag6 && (flag5 || flag4) ? 14 : (flag3 ? 0 : 15));
+            int k = chunkcoordintpair.e() + (flag6 && (flag2 || flag3) ? 1 : (flag5 ? 0 : 15));
+            int l = chunkcoordintpair.e() + (flag6 && (flag2 || flag3) ? 14 : (flag5 ? 0 : 15));
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+            Iterator iterator = BlockPosition.b(i, 0, k, j, world.getBuildHeight() - 1, l).iterator();
+
+            while (iterator.hasNext()) {
+                BlockPosition blockposition = (BlockPosition) iterator.next();
+                IBlockData iblockdata = world.getType(blockposition);
+                IBlockData iblockdata1 = iblockdata;
+                EnumDirection[] aenumdirection1 = aenumdirection;
+                int i1 = aenumdirection.length;
+
+                for (int j1 = 0; j1 < i1; ++j1) {
+                    EnumDirection enumdirection = aenumdirection1[j1];
+
+                    blockposition_mutableblockposition.a((BaseBlockPosition) blockposition, enumdirection);
+                    iblockdata1 = a(iblockdata1, enumdirection, world, blockposition, blockposition_mutableblockposition);
+                }
+
+                Block.a(iblockdata, iblockdata1, world, blockposition, 18);
+            }
+
+        }
+    }
+
+    private static IBlockData a(IBlockData iblockdata, EnumDirection enumdirection, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
+        return ((ChunkConverter.a) ChunkConverter.f.getOrDefault(iblockdata.getBlock(), ChunkConverter.Type.DEFAULT)).a(iblockdata, enumdirection, generatoraccess.getType(blockposition1), generatoraccess, blockposition, blockposition1);
+    }
+
+    private void b(Chunk chunk) {
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition1 = new BlockPosition.MutableBlockPosition();
+        ChunkCoordIntPair chunkcoordintpair = chunk.getPos();
+        World world = chunk.getWorld();
+
+        int i;
+
+        for (i = 0; i < 16; ++i) {
+            ChunkSection chunksection = chunk.getSections()[i];
+            int[] aint = this.e[i];
+
+            this.e[i] = null;
+            if (chunksection != null && aint != null && aint.length > 0) {
+                EnumDirection[] aenumdirection = EnumDirection.values();
+                DataPaletteBlock<IBlockData> datapaletteblock = chunksection.getBlocks();
+                int[] aint1 = aint;
+                int j = aint.length;
+
+                for (int k = 0; k < j; ++k) {
+                    int l = aint1[k];
+                    int i1 = l & 15;
+                    int j1 = l >> 8 & 15;
+                    int k1 = l >> 4 & 15;
+
+                    blockposition_mutableblockposition.d(chunkcoordintpair.d() + i1, (i << 4) + j1, chunkcoordintpair.e() + k1);
+                    IBlockData iblockdata = (IBlockData) datapaletteblock.a(l);
+                    IBlockData iblockdata1 = iblockdata;
+                    EnumDirection[] aenumdirection1 = aenumdirection;
+                    int l1 = aenumdirection.length;
+
+                    for (int i2 = 0; i2 < l1; ++i2) {
+                        EnumDirection enumdirection = aenumdirection1[i2];
+
+                        blockposition_mutableblockposition1.a((BaseBlockPosition) blockposition_mutableblockposition, enumdirection);
+                        if (blockposition_mutableblockposition.getX() >> 4 == chunkcoordintpair.x && blockposition_mutableblockposition.getZ() >> 4 == chunkcoordintpair.z) {
+                            iblockdata1 = a(iblockdata1, enumdirection, world, blockposition_mutableblockposition, blockposition_mutableblockposition1);
+                        }
+                    }
+
+                    Block.a(iblockdata, iblockdata1, world, blockposition_mutableblockposition, 18);
+                }
+            }
+        }
+
+        for (i = 0; i < this.e.length; ++i) {
+            if (this.e[i] != null) {
+                ChunkConverter.LOGGER.warn("Discarding update data for section {} for chunk ({} {})", i, chunkcoordintpair.x, chunkcoordintpair.z);
+            }
+
+            this.e[i] = null;
+        }
+
+    }
+
+    public boolean a() {
+        int[][] aint = this.e;
+        int i = aint.length;
+
+        for (int j = 0; j < i; ++j) {
+            int[] aint1 = aint[j];
+
+            if (aint1 != null) {
+                return false;
+            }
+        }
+
+        return this.d.isEmpty();
+    }
+
+    public NBTTagCompound b() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+        int i;
+
+        for (i = 0; i < this.e.length; ++i) {
+            String s = String.valueOf(i);
+
+            if (this.e[i] != null && this.e[i].length != 0) {
+                nbttagcompound1.setIntArray(s, this.e[i]);
+            }
+        }
+
+        if (!nbttagcompound1.isEmpty()) {
+            nbttagcompound.set("Indices", nbttagcompound1);
+        }
+
+        i = 0;
+
+        EnumDirection8 enumdirection8;
+
+        for (Iterator iterator = this.d.iterator(); iterator.hasNext(); i |= 1 << enumdirection8.ordinal()) {
+            enumdirection8 = (EnumDirection8) iterator.next();
+        }
+
+        nbttagcompound.setByte("Sides", (byte) i);
+        return nbttagcompound;
+    }
+
+    static enum Type implements ChunkConverter.a {
+
+        BLACKLIST(new Block[]{Blocks.OBSERVER, Blocks.NETHER_PORTAL, Blocks.WHITE_CONCRETE_POWDER, Blocks.ORANGE_CONCRETE_POWDER, Blocks.MAGENTA_CONCRETE_POWDER, Blocks.LIGHT_BLUE_CONCRETE_POWDER, Blocks.YELLOW_CONCRETE_POWDER, Blocks.LIME_CONCRETE_POWDER, Blocks.PINK_CONCRETE_POWDER, Blocks.GRAY_CONCRETE_POWDER, Blocks.LIGHT_GRAY_CONCRETE_POWDER, Blocks.CYAN_CONCRETE_POWDER, Blocks.PURPLE_CONCRETE_POWDER, Blocks.BLUE_CONCRETE_POWDER, Blocks.BROWN_CONCRETE_POWDER, Blocks.GREEN_CONCRETE_POWDER, Blocks.RED_CONCRETE_POWDER, Blocks.BLACK_CONCRETE_POWDER, Blocks.ANVIL, Blocks.CHIPPED_ANVIL, Blocks.DAMAGED_ANVIL, Blocks.DRAGON_EGG, Blocks.GRAVEL, Blocks.SAND, Blocks.RED_SAND, Blocks.OAK_SIGN, Blocks.SPRUCE_SIGN, Blocks.BIRCH_SIGN, Blocks.ACACIA_SIGN, Blocks.JUNGLE_SIGN, Blocks.DARK_OAK_SIGN, Blocks.OAK_WALL_SIGN, Blocks.SPRUCE_WALL_SIGN, Blocks.BIRCH_WALL_SIGN, Blocks.ACACIA_WALL_SIGN, Blocks.JUNGLE_WALL_SIGN, Blocks.DARK_OAK_WALL_SIGN}) {
+            @Override
+            public IBlockData a(IBlockData iblockdata, EnumDirection enumdirection, IBlockData iblockdata1, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
+                return iblockdata;
+            }
+        },
+        DEFAULT(new Block[0]) {
+            @Override
+            public IBlockData a(IBlockData iblockdata, EnumDirection enumdirection, IBlockData iblockdata1, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
+                return iblockdata.updateState(enumdirection, generatoraccess.getType(blockposition1), generatoraccess, blockposition, blockposition1);
+            }
+        },
+        CHEST(new Block[]{Blocks.CHEST, Blocks.TRAPPED_CHEST}) {
+            @Override
+            public IBlockData a(IBlockData iblockdata, EnumDirection enumdirection, IBlockData iblockdata1, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
+                if (iblockdata1.a(iblockdata.getBlock()) && enumdirection.n().d() && iblockdata.get(BlockChest.c) == BlockPropertyChestType.SINGLE && iblockdata1.get(BlockChest.c) == BlockPropertyChestType.SINGLE) {
+                    EnumDirection enumdirection1 = (EnumDirection) iblockdata.get(BlockChest.FACING);
+
+                    if (enumdirection.n() != enumdirection1.n() && enumdirection1 == iblockdata1.get(BlockChest.FACING)) {
+                        BlockPropertyChestType blockpropertychesttype = enumdirection == enumdirection1.g() ? BlockPropertyChestType.LEFT : BlockPropertyChestType.RIGHT;
+
+                        generatoraccess.setTypeAndData(blockposition1, (IBlockData) iblockdata1.set(BlockChest.c, blockpropertychesttype.b()), 18);
+                        if (enumdirection1 == EnumDirection.NORTH || enumdirection1 == EnumDirection.EAST) {
+                            TileEntity tileentity = generatoraccess.getTileEntity(blockposition);
+                            TileEntity tileentity1 = generatoraccess.getTileEntity(blockposition1);
+
+                            if (tileentity instanceof TileEntityChest && tileentity1 instanceof TileEntityChest) {
+                                TileEntityChest.a((TileEntityChest) tileentity, (TileEntityChest) tileentity1);
+                            }
+                        }
+
+                        return (IBlockData) iblockdata.set(BlockChest.c, blockpropertychesttype);
+                    }
+                }
+
+                return iblockdata;
+            }
+        },
+        LEAVES(true, new Block[]{Blocks.ACACIA_LEAVES, Blocks.BIRCH_LEAVES, Blocks.DARK_OAK_LEAVES, Blocks.JUNGLE_LEAVES, Blocks.OAK_LEAVES, Blocks.SPRUCE_LEAVES}) {
+            private final ThreadLocal<List<ObjectSet<BlockPosition>>> g = ThreadLocal.withInitial(() -> {
+                return Lists.newArrayListWithCapacity(7);
+            });
+
+            @Override
+            public IBlockData a(IBlockData iblockdata, EnumDirection enumdirection, IBlockData iblockdata1, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
+                IBlockData iblockdata2 = iblockdata.updateState(enumdirection, generatoraccess.getType(blockposition1), generatoraccess, blockposition, blockposition1);
+
+                if (iblockdata != iblockdata2) {
+                    int i = (Integer) iblockdata2.get(BlockProperties.an);
+                    List<ObjectSet<BlockPosition>> list = (List) this.g.get();
+
+                    if (list.isEmpty()) {
+                        for (int j = 0; j < 7; ++j) {
+                            list.add(new ObjectOpenHashSet());
+                        }
+                    }
+
+                    ((ObjectSet) list.get(i)).add(blockposition.immutableCopy());
+                }
+
+                return iblockdata;
+            }
+
+            @Override
+            public void a(GeneratorAccess generatoraccess) {
+                BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+                List<ObjectSet<BlockPosition>> list = (List) this.g.get();
+
+                for (int i = 2; i < list.size(); ++i) {
+                    int j = i - 1;
+                    ObjectSet<BlockPosition> objectset = (ObjectSet) list.get(j);
+                    ObjectSet<BlockPosition> objectset1 = (ObjectSet) list.get(i);
+                    ObjectIterator objectiterator = objectset.iterator();
+
+                    while (objectiterator.hasNext()) {
+                        BlockPosition blockposition = (BlockPosition) objectiterator.next();
+                        IBlockData iblockdata = generatoraccess.getType(blockposition);
+
+                        if ((Integer) iblockdata.get(BlockProperties.an) >= j) {
+                            generatoraccess.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockProperties.an, j), 18);
+                            if (i != 7) {
+                                EnumDirection[] aenumdirection = null.f;
+                                int k = aenumdirection.length;
+
+                                for (int l = 0; l < k; ++l) {
+                                    EnumDirection enumdirection = aenumdirection[l];
+
+                                    blockposition_mutableblockposition.a((BaseBlockPosition) blockposition, enumdirection);
+                                    IBlockData iblockdata1 = generatoraccess.getType(blockposition_mutableblockposition);
+
+                                    if (iblockdata1.b(BlockProperties.an) && (Integer) iblockdata.get(BlockProperties.an) > i) {
+                                        objectset1.add(blockposition_mutableblockposition.immutableCopy());
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                list.clear();
+            }
+        },
+        STEM_BLOCK(new Block[]{Blocks.MELON_STEM, Blocks.PUMPKIN_STEM}) {
+            @Override
+            public IBlockData a(IBlockData iblockdata, EnumDirection enumdirection, IBlockData iblockdata1, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1) {
+                if ((Integer) iblockdata.get(BlockStem.AGE) == 7) {
+                    BlockStemmed blockstemmed = ((BlockStem) iblockdata.getBlock()).d();
+
+                    if (iblockdata1.a((Block) blockstemmed)) {
+                        return (IBlockData) blockstemmed.d().getBlockData().set(BlockFacingHorizontal.FACING, enumdirection);
+                    }
+                }
+
+                return iblockdata;
+            }
+        };
+
+        public static final EnumDirection[] f = EnumDirection.values();
+
+        private Type(Block... ablock) {
+            this(false, ablock);
+        }
+
+        private Type(boolean flag, Block... ablock) {
+            Block[] ablock1 = ablock;
+            int i = ablock.length;
+
+            for (int j = 0; j < i; ++j) {
+                Block block = ablock1[j];
+
+                ChunkConverter.f.put(block, this);
+            }
+
+            if (flag) {
+                ChunkConverter.g.add(this);
+            }
+
+        }
+    }
+
+    public interface a {
+
+        IBlockData a(IBlockData iblockdata, EnumDirection enumdirection, IBlockData iblockdata1, GeneratorAccess generatoraccess, BlockPosition blockposition, BlockPosition blockposition1);
+
+        default void a(GeneratorAccess generatoraccess) {}
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkEmpty.java b/src/main/java/net/minecraft/world/level/chunk/ChunkEmpty.java
new file mode 100644
index 0000000000000000000000000000000000000000..395d21afaabcbd99f9ce0551d647f5db9507a518
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkEmpty.java
@@ -0,0 +1,108 @@
+package net.minecraft.world.level.chunk;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IRegistry;
+import net.minecraft.data.worldgen.biome.BiomeRegistry;
+import net.minecraft.server.level.PlayerChunk;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.lighting.LightEngine;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.FluidTypes;
+import net.minecraft.world.phys.AxisAlignedBB;
+
+public class ChunkEmpty extends Chunk {
+
+    private static final BiomeBase[] b = (BiomeBase[]) SystemUtils.a((Object) (new BiomeBase[BiomeStorage.a]), (abiomebase) -> {
+        Arrays.fill(abiomebase, BiomeRegistry.a);
+    });
+
+    public ChunkEmpty(World world, ChunkCoordIntPair chunkcoordintpair) {
+        super(world, chunkcoordintpair, new BiomeStorage(world.r().b(IRegistry.ay), ChunkEmpty.b));
+    }
+
+    @Override
+    public IBlockData getType(BlockPosition blockposition) {
+        return Blocks.VOID_AIR.getBlockData();
+    }
+
+    @Nullable
+    @Override
+    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
+        return null;
+    }
+
+    @Override
+    public Fluid getFluid(BlockPosition blockposition) {
+        return FluidTypes.EMPTY.h();
+    }
+
+    @Nullable
+    @Override
+    public LightEngine e() {
+        return null;
+    }
+
+    @Override
+    public int g(BlockPosition blockposition) {
+        return 0;
+    }
+
+    @Override
+    public void a(Entity entity) {}
+
+    @Override
+    public void b(Entity entity) {}
+
+    @Override
+    public void a(Entity entity, int i) {}
+
+    @Nullable
+    @Override
+    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
+        return null;
+    }
+
+    @Override
+    public void a(TileEntity tileentity) {}
+
+    @Override
+    public void setTileEntity(BlockPosition blockposition, TileEntity tileentity) {}
+
+    @Override
+    public void removeTileEntity(BlockPosition blockposition) {}
+
+    @Override
+    public void markDirty() {}
+
+    @Override
+    public void a(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, Predicate<? super Entity> predicate) {}
+
+    @Override
+    public <T extends Entity> void a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, List<T> list, Predicate<? super T> predicate) {}
+
+    @Override
+    public boolean isEmpty() {
+        return true;
+    }
+
+    @Override
+    public boolean a(int i, int j) {
+        return true;
+    }
+
+    @Override
+    public PlayerChunk.State getState() {
+        return PlayerChunk.State.BORDER;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/ChunkSection.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf2dd6da5ce88aafdcc4db63af18eda9396a066a
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkSection.java
@@ -0,0 +1,154 @@
+package net.minecraft.world.level.chunk;
+
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.nbt.GameProfileSerializer;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.material.Fluid;
+
+public class ChunkSection {
+
+    public static final DataPalette<IBlockData> GLOBAL_PALETTE = new DataPaletteGlobal<>(Block.REGISTRY_ID, Blocks.AIR.getBlockData());
+    private final int yPos;
+    private short nonEmptyBlockCount;
+    private short tickingBlockCount;
+    private short e;
+    private final DataPaletteBlock<IBlockData> blockIds;
+
+    public ChunkSection(int i) {
+        this(i, (short) 0, (short) 0, (short) 0);
+    }
+
+    public ChunkSection(int i, short short0, short short1, short short2) {
+        this.yPos = i;
+        this.nonEmptyBlockCount = short0;
+        this.tickingBlockCount = short1;
+        this.e = short2;
+        this.blockIds = new DataPaletteBlock<>(ChunkSection.GLOBAL_PALETTE, Block.REGISTRY_ID, GameProfileSerializer::c, GameProfileSerializer::a, Blocks.AIR.getBlockData());
+    }
+
+    public IBlockData getType(int i, int j, int k) {
+        return (IBlockData) this.blockIds.a(i, j, k);
+    }
+
+    public Fluid b(int i, int j, int k) {
+        return ((IBlockData) this.blockIds.a(i, j, k)).getFluid();
+    }
+
+    public void a() {
+        this.blockIds.a();
+    }
+
+    public void b() {
+        this.blockIds.b();
+    }
+
+    public IBlockData setType(int i, int j, int k, IBlockData iblockdata) {
+        return this.setType(i, j, k, iblockdata, true);
+    }
+
+    public IBlockData setType(int i, int j, int k, IBlockData iblockdata, boolean flag) {
+        IBlockData iblockdata1;
+
+        if (flag) {
+            iblockdata1 = (IBlockData) this.blockIds.setBlock(i, j, k, iblockdata);
+        } else {
+            iblockdata1 = (IBlockData) this.blockIds.b(i, j, k, iblockdata);
+        }
+
+        Fluid fluid = iblockdata1.getFluid();
+        Fluid fluid1 = iblockdata.getFluid();
+
+        if (!iblockdata1.isAir()) {
+            --this.nonEmptyBlockCount;
+            if (iblockdata1.isTicking()) {
+                --this.tickingBlockCount;
+            }
+        }
+
+        if (!fluid.isEmpty()) {
+            --this.e;
+        }
+
+        if (!iblockdata.isAir()) {
+            ++this.nonEmptyBlockCount;
+            if (iblockdata.isTicking()) {
+                ++this.tickingBlockCount;
+            }
+        }
+
+        if (!fluid1.isEmpty()) {
+            ++this.e;
+        }
+
+        return iblockdata1;
+    }
+
+    public boolean c() {
+        return this.nonEmptyBlockCount == 0;
+    }
+
+    public static boolean a(@Nullable ChunkSection chunksection) {
+        return chunksection == Chunk.a || chunksection.c();
+    }
+
+    public boolean d() {
+        return this.shouldTick() || this.f();
+    }
+
+    public boolean shouldTick() {
+        return this.tickingBlockCount > 0;
+    }
+
+    public boolean f() {
+        return this.e > 0;
+    }
+
+    public int getYPosition() {
+        return this.yPos;
+    }
+
+    public void recalcBlockCounts() {
+        this.nonEmptyBlockCount = 0;
+        this.tickingBlockCount = 0;
+        this.e = 0;
+        this.blockIds.a((iblockdata, i) -> {
+            Fluid fluid = iblockdata.getFluid();
+
+            if (!iblockdata.isAir()) {
+                this.nonEmptyBlockCount = (short) (this.nonEmptyBlockCount + i);
+                if (iblockdata.isTicking()) {
+                    this.tickingBlockCount = (short) (this.tickingBlockCount + i);
+                }
+            }
+
+            if (!fluid.isEmpty()) {
+                this.nonEmptyBlockCount = (short) (this.nonEmptyBlockCount + i);
+                if (fluid.f()) {
+                    this.e = (short) (this.e + i);
+                }
+            }
+
+        });
+    }
+
+    public DataPaletteBlock<IBlockData> getBlocks() {
+        return this.blockIds;
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeShort(this.nonEmptyBlockCount);
+        this.blockIds.b(packetdataserializer);
+    }
+
+    public int j() {
+        return 2 + this.blockIds.c();
+    }
+
+    public boolean a(Predicate<IBlockData> predicate) {
+        return this.blockIds.contains(predicate);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/DataPalette.java b/src/main/java/net/minecraft/world/level/chunk/DataPalette.java
new file mode 100644
index 0000000000000000000000000000000000000000..f1dd62541187d007a69087f0279508b6b18d5166
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/DataPalette.java
@@ -0,0 +1,22 @@
+package net.minecraft.world.level.chunk;
+
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.network.PacketDataSerializer;
+
+public interface DataPalette<T> {
+
+    int a(T t0);
+
+    boolean a(Predicate<T> predicate);
+
+    @Nullable
+    T a(int i);
+
+    void b(PacketDataSerializer packetdataserializer);
+
+    int a();
+
+    void a(NBTTagList nbttaglist);
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/DataPaletteBlock.java b/src/main/java/net/minecraft/world/level/chunk/DataPaletteBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe441146757a4ac0562d5b493fb6430e33b9ee28
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/DataPaletteBlock.java
@@ -0,0 +1,242 @@
+package net.minecraft.world.level.chunk;
+
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import net.minecraft.CrashReport;
+import net.minecraft.CrashReportSystemDetails;
+import net.minecraft.ReportedException;
+import net.minecraft.core.RegistryBlockID;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.util.DataBits;
+import net.minecraft.util.MathHelper;
+
+public class DataPaletteBlock<T> implements DataPaletteExpandable<T> {
+
+    private final DataPalette<T> b;
+    private final DataPaletteExpandable<T> c = (i, object) -> {
+        return 0;
+    };
+    private final RegistryBlockID<T> d;
+    private final Function<NBTTagCompound, T> e;
+    private final Function<T, NBTTagCompound> f;
+    private final T g;
+    protected DataBits a;
+    private DataPalette<T> h;
+    private int i;
+    private final ReentrantLock j = new ReentrantLock();
+
+    public void a() {
+        if (this.j.isLocked() && !this.j.isHeldByCurrentThread()) {
+            String s = (String) Thread.getAllStackTraces().keySet().stream().filter(Objects::nonNull).map((thread) -> {
+                return thread.getName() + ": \n\tat " + (String) Arrays.stream(thread.getStackTrace()).map(Object::toString).collect(Collectors.joining("\n\tat "));
+            }).collect(Collectors.joining("\n"));
+            CrashReport crashreport = new CrashReport("Writing into PalettedContainer from multiple threads", new IllegalStateException());
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Thread dumps");
+
+            crashreportsystemdetails.a("Thread dumps", (Object) s);
+            throw new ReportedException(crashreport);
+        } else {
+            this.j.lock();
+        }
+    }
+
+    public void b() {
+        this.j.unlock();
+    }
+
+    public DataPaletteBlock(DataPalette<T> datapalette, RegistryBlockID<T> registryblockid, Function<NBTTagCompound, T> function, Function<T, NBTTagCompound> function1, T t0) {
+        this.b = datapalette;
+        this.d = registryblockid;
+        this.e = function;
+        this.f = function1;
+        this.g = t0;
+        this.b(4);
+    }
+
+    private static int b(int i, int j, int k) {
+        return j << 8 | k << 4 | i;
+    }
+
+    private void b(int i) {
+        if (i != this.i) {
+            this.i = i;
+            if (this.i <= 4) {
+                this.i = 4;
+                this.h = new DataPaletteLinear<>(this.d, this.i, this, this.e);
+            } else if (this.i < 9) {
+                this.h = new DataPaletteHash<>(this.d, this.i, this, this.e, this.f);
+            } else {
+                this.h = this.b;
+                this.i = MathHelper.e(this.d.a());
+            }
+
+            this.h.a(this.g);
+            this.a = new DataBits(this.i, 4096);
+        }
+    }
+
+    @Override
+    public int onResize(int i, T t0) {
+        this.a();
+        DataBits databits = this.a;
+        DataPalette<T> datapalette = this.h;
+
+        this.b(i);
+
+        int j;
+
+        for (j = 0; j < databits.b(); ++j) {
+            T t1 = datapalette.a(databits.a(j));
+
+            if (t1 != null) {
+                this.setBlockIndex(j, t1);
+            }
+        }
+
+        j = this.h.a(t0);
+        this.b();
+        return j;
+    }
+
+    public T setBlock(int i, int j, int k, T t0) {
+        this.a();
+        T t1 = this.a(b(i, j, k), t0);
+
+        this.b();
+        return t1;
+    }
+
+    public T b(int i, int j, int k, T t0) {
+        return this.a(b(i, j, k), t0);
+    }
+
+    protected T a(int i, T t0) {
+        int j = this.h.a(t0);
+        int k = this.a.a(i, j);
+        T t1 = this.h.a(k);
+
+        return t1 == null ? this.g : t1;
+    }
+
+    protected void setBlockIndex(int i, T t0) {
+        int j = this.h.a(t0);
+
+        this.a.b(i, j);
+    }
+
+    public T a(int i, int j, int k) {
+        return this.a(b(i, j, k));
+    }
+
+    protected T a(int i) {
+        T t0 = this.h.a(this.a.a(i));
+
+        return t0 == null ? this.g : t0;
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        this.a();
+        packetdataserializer.writeByte(this.i);
+        this.h.b(packetdataserializer);
+        packetdataserializer.a(this.a.a());
+        this.b();
+    }
+
+    public void a(NBTTagList nbttaglist, long[] along) {
+        this.a();
+        int i = Math.max(4, MathHelper.e(nbttaglist.size()));
+
+        if (i != this.i) {
+            this.b(i);
+        }
+
+        this.h.a(nbttaglist);
+        int j = along.length * 64 / 4096;
+
+        if (this.h == this.b) {
+            DataPalette<T> datapalette = new DataPaletteHash<>(this.d, i, this.c, this.e, this.f);
+
+            datapalette.a(nbttaglist);
+            DataBits databits = new DataBits(i, 4096, along);
+
+            for (int k = 0; k < 4096; ++k) {
+                this.a.b(k, this.b.a(datapalette.a(databits.a(k))));
+            }
+        } else if (j == this.i) {
+            System.arraycopy(along, 0, this.a.a(), 0, along.length);
+        } else {
+            DataBits databits1 = new DataBits(j, 4096, along);
+
+            for (int l = 0; l < 4096; ++l) {
+                this.a.b(l, databits1.a(l));
+            }
+        }
+
+        this.b();
+    }
+
+    public void a(NBTTagCompound nbttagcompound, String s, String s1) {
+        this.a();
+        DataPaletteHash<T> datapalettehash = new DataPaletteHash<>(this.d, this.i, this.c, this.e, this.f);
+        T t0 = this.g;
+        int i = datapalettehash.a(this.g);
+        int[] aint = new int[4096];
+
+        for (int j = 0; j < 4096; ++j) {
+            T t1 = this.a(j);
+
+            if (t1 != t0) {
+                t0 = t1;
+                i = datapalettehash.a(t1);
+            }
+
+            aint[j] = i;
+        }
+
+        NBTTagList nbttaglist = new NBTTagList();
+
+        datapalettehash.b(nbttaglist);
+        nbttagcompound.set(s, nbttaglist);
+        int k = Math.max(4, MathHelper.e(nbttaglist.size()));
+        DataBits databits = new DataBits(k, 4096);
+
+        for (int l = 0; l < aint.length; ++l) {
+            databits.b(l, aint[l]);
+        }
+
+        nbttagcompound.a(s1, databits.a());
+        this.b();
+    }
+
+    public int c() {
+        return 1 + this.h.a() + PacketDataSerializer.a(this.a.b()) + this.a.a().length * 8;
+    }
+
+    public boolean contains(Predicate<T> predicate) {
+        return this.h.a(predicate);
+    }
+
+    public void a(DataPaletteBlock.a<T> datapaletteblock_a) {
+        Int2IntOpenHashMap int2intopenhashmap = new Int2IntOpenHashMap();
+
+        this.a.a((i) -> {
+            int2intopenhashmap.put(i, int2intopenhashmap.get(i) + 1);
+        });
+        int2intopenhashmap.int2IntEntrySet().forEach((entry) -> {
+            datapaletteblock_a.accept(this.h.a(entry.getIntKey()), entry.getIntValue());
+        });
+    }
+
+    @FunctionalInterface
+    public interface a<T> {
+
+        void accept(T t0, int i);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/IChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/IChunkAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..2cd04abd72f1135446182ad6294003e526f99a4b
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/IChunkAccess.java
@@ -0,0 +1,148 @@
+package net.minecraft.world.level.chunk;
+
+import it.unimi.dsi.fastutil.shorts.ShortArrayList;
+import it.unimi.dsi.fastutil.shorts.ShortList;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.TickList;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.levelgen.HeightMap;
+import net.minecraft.world.level.levelgen.feature.StructureGenerator;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import net.minecraft.world.level.material.FluidType;
+import org.apache.logging.log4j.LogManager;
+
+public interface IChunkAccess extends IBlockAccess, IStructureAccess {
+
+    @Nullable
+    IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag);
+
+    void setTileEntity(BlockPosition blockposition, TileEntity tileentity);
+
+    void a(Entity entity);
+
+    @Nullable
+    default ChunkSection a() {
+        ChunkSection[] achunksection = this.getSections();
+
+        for (int i = achunksection.length - 1; i >= 0; --i) {
+            ChunkSection chunksection = achunksection[i];
+
+            if (!ChunkSection.a(chunksection)) {
+                return chunksection;
+            }
+        }
+
+        return null;
+    }
+
+    default int b() {
+        ChunkSection chunksection = this.a();
+
+        return chunksection == null ? 0 : chunksection.getYPosition();
+    }
+
+    Set<BlockPosition> c();
+
+    ChunkSection[] getSections();
+
+    Collection<Entry<HeightMap.Type, HeightMap>> f();
+
+    void a(HeightMap.Type heightmap_type, long[] along);
+
+    HeightMap a(HeightMap.Type heightmap_type);
+
+    int getHighestBlock(HeightMap.Type heightmap_type, int i, int j);
+
+    ChunkCoordIntPair getPos();
+
+    void setLastSaved(long i);
+
+    Map<StructureGenerator<?>, StructureStart<?>> h();
+
+    void a(Map<StructureGenerator<?>, StructureStart<?>> map);
+
+    default boolean a(int i, int j) {
+        if (i < 0) {
+            i = 0;
+        }
+
+        if (j >= 256) {
+            j = 255;
+        }
+
+        for (int k = i; k <= j; k += 16) {
+            if (!ChunkSection.a(this.getSections()[k >> 4])) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Nullable
+    BiomeStorage getBiomeIndex();
+
+    void setNeedsSaving(boolean flag);
+
+    boolean isNeedsSaving();
+
+    ChunkStatus getChunkStatus();
+
+    void removeTileEntity(BlockPosition blockposition);
+
+    default void e(BlockPosition blockposition) {
+        LogManager.getLogger().warn("Trying to mark a block for PostProcessing @ {}, but this operation is not supported.", blockposition);
+    }
+
+    ShortList[] l();
+
+    default void a(short short0, int i) {
+        a(this.l(), i).add(short0);
+    }
+
+    default void a(NBTTagCompound nbttagcompound) {
+        LogManager.getLogger().warn("Trying to set a BlockEntity, but this operation is not supported.");
+    }
+
+    @Nullable
+    NBTTagCompound i(BlockPosition blockposition);
+
+    @Nullable
+    NBTTagCompound j(BlockPosition blockposition);
+
+    Stream<BlockPosition> m();
+
+    TickList<Block> n();
+
+    TickList<FluidType> o();
+
+    ChunkConverter p();
+
+    void setInhabitedTime(long i);
+
+    long getInhabitedTime();
+
+    static ShortList a(ShortList[] ashortlist, int i) {
+        if (ashortlist[i] == null) {
+            ashortlist[i] = new ShortArrayList();
+        }
+
+        return ashortlist[i];
+    }
+
+    boolean r();
+
+    void b(boolean flag);
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/ILightAccess.java b/src/main/java/net/minecraft/world/level/chunk/ILightAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..43b8361e8ad0a8c429406cb6ff538020f670bdbd
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/ILightAccess.java
@@ -0,0 +1,16 @@
+package net.minecraft.world.level.chunk;
+
+import javax.annotation.Nullable;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.IBlockAccess;
+
+public interface ILightAccess {
+
+    @Nullable
+    IBlockAccess c(int i, int j);
+
+    default void a(EnumSkyBlock enumskyblock, SectionPosition sectionposition) {}
+
+    IBlockAccess getWorld();
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..4192d30ad2117a12a4058b48581d6cf93b50088c
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -0,0 +1,512 @@
+package net.minecraft.world.level.chunk;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
+import it.unimi.dsi.fastutil.shorts.ShortList;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.levelgen.HeightMap;
+import net.minecraft.world.level.levelgen.WorldGenStage;
+import net.minecraft.world.level.levelgen.feature.StructureGenerator;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import net.minecraft.world.level.lighting.LightEngine;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.FluidType;
+import net.minecraft.world.level.material.FluidTypes;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ProtoChunk implements IChunkAccess {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final ChunkCoordIntPair b;
+    private volatile boolean c;
+    @Nullable
+    private BiomeStorage d;
+    @Nullable
+    private volatile LightEngine e;
+    private final Map<HeightMap.Type, HeightMap> f;
+    private volatile ChunkStatus g;
+    private final Map<BlockPosition, TileEntity> h;
+    private final Map<BlockPosition, NBTTagCompound> i;
+    private final ChunkSection[] j;
+    private final List<NBTTagCompound> k;
+    private final List<BlockPosition> l;
+    private final ShortList[] m;
+    private final Map<StructureGenerator<?>, StructureStart<?>> n;
+    private final Map<StructureGenerator<?>, LongSet> o;
+    private final ChunkConverter p;
+    private final ProtoChunkTickList<Block> q;
+    private final ProtoChunkTickList<FluidType> r;
+    private long s;
+    private final Map<WorldGenStage.Features, BitSet> t;
+    private volatile boolean u;
+
+    public ProtoChunk(ChunkCoordIntPair chunkcoordintpair, ChunkConverter chunkconverter) {
+        this(chunkcoordintpair, chunkconverter, (ChunkSection[]) null, new ProtoChunkTickList<>((block) -> {
+            return block == null || block.getBlockData().isAir();
+        }, chunkcoordintpair), new ProtoChunkTickList<>((fluidtype) -> {
+            return fluidtype == null || fluidtype == FluidTypes.EMPTY;
+        }, chunkcoordintpair));
+    }
+
+    public ProtoChunk(ChunkCoordIntPair chunkcoordintpair, ChunkConverter chunkconverter, @Nullable ChunkSection[] achunksection, ProtoChunkTickList<Block> protochunkticklist, ProtoChunkTickList<FluidType> protochunkticklist1) {
+        this.f = Maps.newEnumMap(HeightMap.Type.class);
+        this.g = ChunkStatus.EMPTY;
+        this.h = Maps.newHashMap();
+        this.i = Maps.newHashMap();
+        this.j = new ChunkSection[16];
+        this.k = Lists.newArrayList();
+        this.l = Lists.newArrayList();
+        this.m = new ShortList[16];
+        this.n = Maps.newHashMap();
+        this.o = Maps.newHashMap();
+        this.t = new Object2ObjectArrayMap();
+        this.b = chunkcoordintpair;
+        this.p = chunkconverter;
+        this.q = protochunkticklist;
+        this.r = protochunkticklist1;
+        if (achunksection != null) {
+            if (this.j.length == achunksection.length) {
+                System.arraycopy(achunksection, 0, this.j, 0, this.j.length);
+            } else {
+                ProtoChunk.LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", achunksection.length, this.j.length);
+            }
+        }
+
+    }
+
+    @Override
+    public IBlockData getType(BlockPosition blockposition) {
+        int i = blockposition.getY();
+
+        if (World.b(i)) {
+            return Blocks.VOID_AIR.getBlockData();
+        } else {
+            ChunkSection chunksection = this.getSections()[i >> 4];
+
+            return ChunkSection.a(chunksection) ? Blocks.AIR.getBlockData() : chunksection.getType(blockposition.getX() & 15, i & 15, blockposition.getZ() & 15);
+        }
+    }
+
+    @Override
+    public Fluid getFluid(BlockPosition blockposition) {
+        int i = blockposition.getY();
+
+        if (World.b(i)) {
+            return FluidTypes.EMPTY.h();
+        } else {
+            ChunkSection chunksection = this.getSections()[i >> 4];
+
+            return ChunkSection.a(chunksection) ? FluidTypes.EMPTY.h() : chunksection.b(blockposition.getX() & 15, i & 15, blockposition.getZ() & 15);
+        }
+    }
+
+    @Override
+    public Stream<BlockPosition> m() {
+        return this.l.stream();
+    }
+
+    public ShortList[] w() {
+        ShortList[] ashortlist = new ShortList[16];
+        Iterator iterator = this.l.iterator();
+
+        while (iterator.hasNext()) {
+            BlockPosition blockposition = (BlockPosition) iterator.next();
+
+            IChunkAccess.a(ashortlist, blockposition.getY() >> 4).add(l(blockposition));
+        }
+
+        return ashortlist;
+    }
+
+    public void b(short short0, int i) {
+        this.k(a(short0, i, this.b));
+    }
+
+    public void k(BlockPosition blockposition) {
+        this.l.add(blockposition.immutableCopy());
+    }
+
+    @Nullable
+    @Override
+    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
+        int i = blockposition.getX();
+        int j = blockposition.getY();
+        int k = blockposition.getZ();
+
+        if (j >= 0 && j < 256) {
+            if (this.j[j >> 4] == Chunk.a && iblockdata.a(Blocks.AIR)) {
+                return iblockdata;
+            } else {
+                if (iblockdata.f() > 0) {
+                    this.l.add(new BlockPosition((i & 15) + this.getPos().d(), j, (k & 15) + this.getPos().e()));
+                }
+
+                ChunkSection chunksection = this.a(j >> 4);
+                IBlockData iblockdata1 = chunksection.setType(i & 15, j & 15, k & 15, iblockdata);
+
+                if (this.g.b(ChunkStatus.FEATURES) && iblockdata != iblockdata1 && (iblockdata.b((IBlockAccess) this, blockposition) != iblockdata1.b((IBlockAccess) this, blockposition) || iblockdata.f() != iblockdata1.f() || iblockdata.e() || iblockdata1.e())) {
+                    LightEngine lightengine = this.e();
+
+                    lightengine.a(blockposition);
+                }
+
+                EnumSet<HeightMap.Type> enumset = this.getChunkStatus().h();
+                EnumSet<HeightMap.Type> enumset1 = null;
+                Iterator iterator = enumset.iterator();
+
+                HeightMap.Type heightmap_type;
+
+                while (iterator.hasNext()) {
+                    heightmap_type = (HeightMap.Type) iterator.next();
+                    HeightMap heightmap = (HeightMap) this.f.get(heightmap_type);
+
+                    if (heightmap == null) {
+                        if (enumset1 == null) {
+                            enumset1 = EnumSet.noneOf(HeightMap.Type.class);
+                        }
+
+                        enumset1.add(heightmap_type);
+                    }
+                }
+
+                if (enumset1 != null) {
+                    HeightMap.a(this, enumset1);
+                }
+
+                iterator = enumset.iterator();
+
+                while (iterator.hasNext()) {
+                    heightmap_type = (HeightMap.Type) iterator.next();
+                    ((HeightMap) this.f.get(heightmap_type)).a(i & 15, j, k & 15, iblockdata);
+                }
+
+                return iblockdata1;
+            }
+        } else {
+            return Blocks.VOID_AIR.getBlockData();
+        }
+    }
+
+    public ChunkSection a(int i) {
+        if (this.j[i] == Chunk.a) {
+            this.j[i] = new ChunkSection(i << 4);
+        }
+
+        return this.j[i];
+    }
+
+    @Override
+    public void setTileEntity(BlockPosition blockposition, TileEntity tileentity) {
+        tileentity.setPosition(blockposition);
+        this.h.put(blockposition, tileentity);
+    }
+
+    @Override
+    public Set<BlockPosition> c() {
+        Set<BlockPosition> set = Sets.newHashSet(this.i.keySet());
+
+        set.addAll(this.h.keySet());
+        return set;
+    }
+
+    @Nullable
+    @Override
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        return (TileEntity) this.h.get(blockposition);
+    }
+
+    public Map<BlockPosition, TileEntity> x() {
+        return this.h;
+    }
+
+    public void b(NBTTagCompound nbttagcompound) {
+        this.k.add(nbttagcompound);
+    }
+
+    @Override
+    public void a(Entity entity) {
+        if (!entity.isPassenger()) {
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+            entity.d(nbttagcompound);
+            this.b(nbttagcompound);
+        }
+    }
+
+    public List<NBTTagCompound> y() {
+        return this.k;
+    }
+
+    public void a(BiomeStorage biomestorage) {
+        this.d = biomestorage;
+    }
+
+    @Nullable
+    @Override
+    public BiomeStorage getBiomeIndex() {
+        return this.d;
+    }
+
+    @Override
+    public void setNeedsSaving(boolean flag) {
+        this.c = flag;
+    }
+
+    @Override
+    public boolean isNeedsSaving() {
+        return this.c;
+    }
+
+    @Override
+    public ChunkStatus getChunkStatus() {
+        return this.g;
+    }
+
+    public void a(ChunkStatus chunkstatus) {
+        this.g = chunkstatus;
+        this.setNeedsSaving(true);
+    }
+
+    @Override
+    public ChunkSection[] getSections() {
+        return this.j;
+    }
+
+    @Nullable
+    public LightEngine e() {
+        return this.e;
+    }
+
+    @Override
+    public Collection<Entry<HeightMap.Type, HeightMap>> f() {
+        return Collections.unmodifiableSet(this.f.entrySet());
+    }
+
+    @Override
+    public void a(HeightMap.Type heightmap_type, long[] along) {
+        this.a(heightmap_type).a(along);
+    }
+
+    @Override
+    public HeightMap a(HeightMap.Type heightmap_type) {
+        return (HeightMap) this.f.computeIfAbsent(heightmap_type, (heightmap_type1) -> {
+            return new HeightMap(this, heightmap_type1);
+        });
+    }
+
+    @Override
+    public int getHighestBlock(HeightMap.Type heightmap_type, int i, int j) {
+        HeightMap heightmap = (HeightMap) this.f.get(heightmap_type);
+
+        if (heightmap == null) {
+            HeightMap.a(this, EnumSet.of(heightmap_type));
+            heightmap = (HeightMap) this.f.get(heightmap_type);
+        }
+
+        return heightmap.a(i & 15, j & 15) - 1;
+    }
+
+    @Override
+    public ChunkCoordIntPair getPos() {
+        return this.b;
+    }
+
+    @Override
+    public void setLastSaved(long i) {}
+
+    @Nullable
+    @Override
+    public StructureStart<?> a(StructureGenerator<?> structuregenerator) {
+        return (StructureStart) this.n.get(structuregenerator);
+    }
+
+    @Override
+    public void a(StructureGenerator<?> structuregenerator, StructureStart<?> structurestart) {
+        this.n.put(structuregenerator, structurestart);
+        this.c = true;
+    }
+
+    @Override
+    public Map<StructureGenerator<?>, StructureStart<?>> h() {
+        return Collections.unmodifiableMap(this.n);
+    }
+
+    @Override
+    public void a(Map<StructureGenerator<?>, StructureStart<?>> map) {
+        this.n.clear();
+        this.n.putAll(map);
+        this.c = true;
+    }
+
+    @Override
+    public LongSet b(StructureGenerator<?> structuregenerator) {
+        return (LongSet) this.o.computeIfAbsent(structuregenerator, (structuregenerator1) -> {
+            return new LongOpenHashSet();
+        });
+    }
+
+    @Override
+    public void a(StructureGenerator<?> structuregenerator, long i) {
+        ((LongSet) this.o.computeIfAbsent(structuregenerator, (structuregenerator1) -> {
+            return new LongOpenHashSet();
+        })).add(i);
+        this.c = true;
+    }
+
+    @Override
+    public Map<StructureGenerator<?>, LongSet> v() {
+        return Collections.unmodifiableMap(this.o);
+    }
+
+    @Override
+    public void b(Map<StructureGenerator<?>, LongSet> map) {
+        this.o.clear();
+        this.o.putAll(map);
+        this.c = true;
+    }
+
+    public static short l(BlockPosition blockposition) {
+        int i = blockposition.getX();
+        int j = blockposition.getY();
+        int k = blockposition.getZ();
+        int l = i & 15;
+        int i1 = j & 15;
+        int j1 = k & 15;
+
+        return (short) (l | i1 << 4 | j1 << 8);
+    }
+
+    public static BlockPosition a(short short0, int i, ChunkCoordIntPair chunkcoordintpair) {
+        int j = (short0 & 15) + (chunkcoordintpair.x << 4);
+        int k = (short0 >>> 4 & 15) + (i << 4);
+        int l = (short0 >>> 8 & 15) + (chunkcoordintpair.z << 4);
+
+        return new BlockPosition(j, k, l);
+    }
+
+    @Override
+    public void e(BlockPosition blockposition) {
+        if (!World.isOutsideWorld(blockposition)) {
+            IChunkAccess.a(this.m, blockposition.getY() >> 4).add(l(blockposition));
+        }
+
+    }
+
+    @Override
+    public ShortList[] l() {
+        return this.m;
+    }
+
+    @Override
+    public void a(short short0, int i) {
+        IChunkAccess.a(this.m, i).add(short0);
+    }
+
+    @Override
+    public ProtoChunkTickList<Block> n() {
+        return this.q;
+    }
+
+    @Override
+    public ProtoChunkTickList<FluidType> o() {
+        return this.r;
+    }
+
+    @Override
+    public ChunkConverter p() {
+        return this.p;
+    }
+
+    @Override
+    public void setInhabitedTime(long i) {
+        this.s = i;
+    }
+
+    @Override
+    public long getInhabitedTime() {
+        return this.s;
+    }
+
+    @Override
+    public void a(NBTTagCompound nbttagcompound) {
+        this.i.put(new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z")), nbttagcompound);
+    }
+
+    public Map<BlockPosition, NBTTagCompound> z() {
+        return Collections.unmodifiableMap(this.i);
+    }
+
+    @Override
+    public NBTTagCompound i(BlockPosition blockposition) {
+        return (NBTTagCompound) this.i.get(blockposition);
+    }
+
+    @Nullable
+    @Override
+    public NBTTagCompound j(BlockPosition blockposition) {
+        TileEntity tileentity = this.getTileEntity(blockposition);
+
+        return tileentity != null ? tileentity.save(new NBTTagCompound()) : (NBTTagCompound) this.i.get(blockposition);
+    }
+
+    @Override
+    public void removeTileEntity(BlockPosition blockposition) {
+        this.h.remove(blockposition);
+        this.i.remove(blockposition);
+    }
+
+    @Nullable
+    public BitSet a(WorldGenStage.Features worldgenstage_features) {
+        return (BitSet) this.t.get(worldgenstage_features);
+    }
+
+    public BitSet b(WorldGenStage.Features worldgenstage_features) {
+        return (BitSet) this.t.computeIfAbsent(worldgenstage_features, (worldgenstage_features1) -> {
+            return new BitSet(65536);
+        });
+    }
+
+    public void a(WorldGenStage.Features worldgenstage_features, BitSet bitset) {
+        this.t.put(worldgenstage_features, bitset);
+    }
+
+    public void a(LightEngine lightengine) {
+        this.e = lightengine;
+    }
+
+    @Override
+    public boolean r() {
+        return this.u;
+    }
+
+    @Override
+    public void b(boolean flag) {
+        this.u = flag;
+        this.setNeedsSaving(true);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java
new file mode 100644
index 0000000000000000000000000000000000000000..c059d3d055c35b492680556e8605966e2caaf7fd
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java
@@ -0,0 +1,219 @@
+package net.minecraft.world.level.chunk;
+
+import it.unimi.dsi.fastutil.longs.LongSet;
+import java.util.BitSet;
+import java.util.Map;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.levelgen.HeightMap;
+import net.minecraft.world.level.levelgen.WorldGenStage;
+import net.minecraft.world.level.levelgen.feature.StructureGenerator;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import net.minecraft.world.level.lighting.LightEngine;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.FluidType;
+import net.minecraft.world.level.material.FluidTypes;
+
+public class ProtoChunkExtension extends ProtoChunk {
+
+    private final Chunk a;
+
+    public ProtoChunkExtension(Chunk chunk) {
+        super(chunk.getPos(), ChunkConverter.a);
+        this.a = chunk;
+    }
+
+    @Nullable
+    @Override
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        return this.a.getTileEntity(blockposition);
+    }
+
+    @Nullable
+    @Override
+    public IBlockData getType(BlockPosition blockposition) {
+        return this.a.getType(blockposition);
+    }
+
+    @Override
+    public Fluid getFluid(BlockPosition blockposition) {
+        return this.a.getFluid(blockposition);
+    }
+
+    @Override
+    public int K() {
+        return this.a.K();
+    }
+
+    @Nullable
+    @Override
+    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
+        return null;
+    }
+
+    @Override
+    public void setTileEntity(BlockPosition blockposition, TileEntity tileentity) {}
+
+    @Override
+    public void a(Entity entity) {}
+
+    @Override
+    public void a(ChunkStatus chunkstatus) {}
+
+    @Override
+    public ChunkSection[] getSections() {
+        return this.a.getSections();
+    }
+
+    @Nullable
+    @Override
+    public LightEngine e() {
+        return this.a.e();
+    }
+
+    @Override
+    public void a(HeightMap.Type heightmap_type, long[] along) {}
+
+    private HeightMap.Type c(HeightMap.Type heightmap_type) {
+        return heightmap_type == HeightMap.Type.WORLD_SURFACE_WG ? HeightMap.Type.WORLD_SURFACE : (heightmap_type == HeightMap.Type.OCEAN_FLOOR_WG ? HeightMap.Type.OCEAN_FLOOR : heightmap_type);
+    }
+
+    @Override
+    public int getHighestBlock(HeightMap.Type heightmap_type, int i, int j) {
+        return this.a.getHighestBlock(this.c(heightmap_type), i, j);
+    }
+
+    @Override
+    public ChunkCoordIntPair getPos() {
+        return this.a.getPos();
+    }
+
+    @Override
+    public void setLastSaved(long i) {}
+
+    @Nullable
+    @Override
+    public StructureStart<?> a(StructureGenerator<?> structuregenerator) {
+        return this.a.a(structuregenerator);
+    }
+
+    @Override
+    public void a(StructureGenerator<?> structuregenerator, StructureStart<?> structurestart) {}
+
+    @Override
+    public Map<StructureGenerator<?>, StructureStart<?>> h() {
+        return this.a.h();
+    }
+
+    @Override
+    public void a(Map<StructureGenerator<?>, StructureStart<?>> map) {}
+
+    @Override
+    public LongSet b(StructureGenerator<?> structuregenerator) {
+        return this.a.b(structuregenerator);
+    }
+
+    @Override
+    public void a(StructureGenerator<?> structuregenerator, long i) {}
+
+    @Override
+    public Map<StructureGenerator<?>, LongSet> v() {
+        return this.a.v();
+    }
+
+    @Override
+    public void b(Map<StructureGenerator<?>, LongSet> map) {}
+
+    @Override
+    public BiomeStorage getBiomeIndex() {
+        return this.a.getBiomeIndex();
+    }
+
+    @Override
+    public void setNeedsSaving(boolean flag) {}
+
+    @Override
+    public boolean isNeedsSaving() {
+        return false;
+    }
+
+    @Override
+    public ChunkStatus getChunkStatus() {
+        return this.a.getChunkStatus();
+    }
+
+    @Override
+    public void removeTileEntity(BlockPosition blockposition) {}
+
+    @Override
+    public void e(BlockPosition blockposition) {}
+
+    @Override
+    public void a(NBTTagCompound nbttagcompound) {}
+
+    @Nullable
+    @Override
+    public NBTTagCompound i(BlockPosition blockposition) {
+        return this.a.i(blockposition);
+    }
+
+    @Nullable
+    @Override
+    public NBTTagCompound j(BlockPosition blockposition) {
+        return this.a.j(blockposition);
+    }
+
+    @Override
+    public void a(BiomeStorage biomestorage) {}
+
+    @Override
+    public Stream<BlockPosition> m() {
+        return this.a.m();
+    }
+
+    @Override
+    public ProtoChunkTickList<Block> n() {
+        return new ProtoChunkTickList<>((block) -> {
+            return block.getBlockData().isAir();
+        }, this.getPos());
+    }
+
+    @Override
+    public ProtoChunkTickList<FluidType> o() {
+        return new ProtoChunkTickList<>((fluidtype) -> {
+            return fluidtype == FluidTypes.EMPTY;
+        }, this.getPos());
+    }
+
+    @Override
+    public BitSet a(WorldGenStage.Features worldgenstage_features) {
+        throw (UnsupportedOperationException) SystemUtils.c((Throwable) (new UnsupportedOperationException("Meaningless in this context")));
+    }
+
+    @Override
+    public BitSet b(WorldGenStage.Features worldgenstage_features) {
+        throw (UnsupportedOperationException) SystemUtils.c((Throwable) (new UnsupportedOperationException("Meaningless in this context")));
+    }
+
+    public Chunk u() {
+        return this.a;
+    }
+
+    @Override
+    public boolean r() {
+        return this.a.r();
+    }
+
+    @Override
+    public void b(boolean flag) {
+        this.a.b(flag);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java b/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java
new file mode 100644
index 0000000000000000000000000000000000000000..88c2643a18165bd7a9e6e056b926d6e894ff60d4
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java
@@ -0,0 +1,187 @@
+package net.minecraft.world.level.chunk.storage;
+
+import com.google.common.collect.Maps;
+import com.mojang.datafixers.util.Either;
+import java.io.File;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.util.Unit;
+import net.minecraft.util.thread.PairedQueue;
+import net.minecraft.util.thread.ThreadedMailbox;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class IOWorker implements AutoCloseable {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final AtomicBoolean b = new AtomicBoolean();
+    private final ThreadedMailbox<PairedQueue.b> c;
+    private final RegionFileCache d;
+    private final Map<ChunkCoordIntPair, IOWorker.a> e = Maps.newLinkedHashMap();
+
+    protected IOWorker(File file, boolean flag, String s) {
+        this.d = new RegionFileCache(file, flag);
+        this.c = new ThreadedMailbox<>(new PairedQueue.a(IOWorker.Priority.values().length), SystemUtils.g(), "IOWorker-" + s);
+    }
+
+    public CompletableFuture<Void> a(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) {
+        return this.a(() -> {
+            IOWorker.a ioworker_a = (IOWorker.a) this.e.computeIfAbsent(chunkcoordintpair, (chunkcoordintpair1) -> {
+                return new IOWorker.a(nbttagcompound);
+            });
+
+            ioworker_a.a = nbttagcompound;
+            return Either.left(ioworker_a.b);
+        }).thenCompose(Function.identity());
+    }
+
+    @Nullable
+    public NBTTagCompound a(ChunkCoordIntPair chunkcoordintpair) throws IOException {
+        CompletableFuture completablefuture = this.a(() -> {
+            IOWorker.a ioworker_a = (IOWorker.a) this.e.get(chunkcoordintpair);
+
+            if (ioworker_a != null) {
+                return Either.left(ioworker_a.a);
+            } else {
+                try {
+                    NBTTagCompound nbttagcompound = this.d.read(chunkcoordintpair);
+
+                    return Either.left(nbttagcompound);
+                } catch (Exception exception) {
+                    IOWorker.LOGGER.warn("Failed to read chunk {}", chunkcoordintpair, exception);
+                    return Either.right(exception);
+                }
+            }
+        });
+
+        try {
+            return (NBTTagCompound) completablefuture.join();
+        } catch (CompletionException completionexception) {
+            if (completionexception.getCause() instanceof IOException) {
+                throw (IOException) completionexception.getCause();
+            } else {
+                throw completionexception;
+            }
+        }
+    }
+
+    public CompletableFuture<Void> a() {
+        CompletableFuture<Void> completablefuture = this.a(() -> {
+            return Either.left(CompletableFuture.allOf((CompletableFuture[]) this.e.values().stream().map((ioworker_a) -> {
+                return ioworker_a.b;
+            }).toArray((i) -> {
+                return new CompletableFuture[i];
+            })));
+        }).thenCompose(Function.identity());
+
+        return completablefuture.thenCompose((ovoid) -> {
+            return this.a(() -> {
+                try {
+                    this.d.a();
+                    return Either.left((Object) null);
+                } catch (Exception exception) {
+                    IOWorker.LOGGER.warn("Failed to synchronized chunks", exception);
+                    return Either.right(exception);
+                }
+            });
+        });
+    }
+
+    private <T> CompletableFuture<T> a(Supplier<Either<T, Exception>> supplier) {
+        return this.c.c((mailbox) -> {
+            return new PairedQueue.b(IOWorker.Priority.HIGH.ordinal(), () -> {
+                if (!this.b.get()) {
+                    mailbox.a(supplier.get());
+                }
+
+                this.c();
+            });
+        });
+    }
+
+    private void b() {
+        Iterator<Entry<ChunkCoordIntPair, IOWorker.a>> iterator = this.e.entrySet().iterator();
+
+        if (iterator.hasNext()) {
+            Entry<ChunkCoordIntPair, IOWorker.a> entry = (Entry) iterator.next();
+
+            iterator.remove();
+            this.a((ChunkCoordIntPair) entry.getKey(), (IOWorker.a) entry.getValue());
+            this.c();
+        }
+    }
+
+    private void c() {
+        this.c.a((Object) (new PairedQueue.b(IOWorker.Priority.LOW.ordinal(), this::b)));
+    }
+
+    private void a(ChunkCoordIntPair chunkcoordintpair, IOWorker.a ioworker_a) {
+        try {
+            this.d.write(chunkcoordintpair, ioworker_a.a);
+            ioworker_a.b.complete((Object) null);
+        } catch (Exception exception) {
+            IOWorker.LOGGER.error("Failed to store chunk {}", chunkcoordintpair, exception);
+            ioworker_a.b.completeExceptionally(exception);
+        }
+
+    }
+
+    public void close() throws IOException {
+        if (this.b.compareAndSet(false, true)) {
+            CompletableFuture completablefuture = this.c.b((mailbox) -> {
+                return new PairedQueue.b(IOWorker.Priority.HIGH.ordinal(), () -> {
+                    mailbox.a(Unit.INSTANCE);
+                });
+            });
+
+            try {
+                completablefuture.join();
+            } catch (CompletionException completionexception) {
+                if (completionexception.getCause() instanceof IOException) {
+                    throw (IOException) completionexception.getCause();
+                }
+
+                throw completionexception;
+            }
+
+            this.c.close();
+            this.e.forEach(this::a);
+            this.e.clear();
+
+            try {
+                this.d.close();
+            } catch (Exception exception) {
+                IOWorker.LOGGER.error("Failed to close storage", exception);
+            }
+
+        }
+    }
+
+    static class a {
+
+        private NBTTagCompound a;
+        private final CompletableFuture<Void> b = new CompletableFuture();
+
+        public a(NBTTagCompound nbttagcompound) {
+            this.a = nbttagcompound;
+        }
+    }
+
+    static enum Priority {
+
+        HIGH, LOW;
+
+        private Priority() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileBitSet.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileBitSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..c96eac4b0b519b2807153fa5a8ebf5a020a2b140
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileBitSet.java
@@ -0,0 +1,34 @@
+package net.minecraft.world.level.chunk.storage;
+
+import java.util.BitSet;
+
+public class RegionFileBitSet {
+
+    private final BitSet a = new BitSet();
+
+    public RegionFileBitSet() {}
+
+    public void a(int i, int j) {
+        this.a.set(i, i + j);
+    }
+
+    public void b(int i, int j) {
+        this.a.clear(i, i + j);
+    }
+
+    public int a(int i) {
+        int j = 0;
+
+        while (true) {
+            int k = this.a.nextClearBit(j);
+            int l = this.a.nextSetBit(k);
+
+            if (l == -1 || l - k >= i) {
+                this.a(k, i);
+                return k;
+            }
+
+            j = l;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileCompression.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileCompression.java
new file mode 100644
index 0000000000000000000000000000000000000000..78728e064479e7056b7c69e306854330691faa12
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileCompression.java
@@ -0,0 +1,65 @@
+package net.minecraft.world.level.chunk.storage;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+import java.util.zip.InflaterInputStream;
+import javax.annotation.Nullable;
+
+public class RegionFileCompression {
+
+    private static final Int2ObjectMap<RegionFileCompression> d = new Int2ObjectOpenHashMap();
+    public static final RegionFileCompression a = a(new RegionFileCompression(1, GZIPInputStream::new, GZIPOutputStream::new));
+    public static final RegionFileCompression b = a(new RegionFileCompression(2, InflaterInputStream::new, DeflaterOutputStream::new));
+    public static final RegionFileCompression c = a(new RegionFileCompression(3, (inputstream) -> {
+        return inputstream;
+    }, (outputstream) -> {
+        return outputstream;
+    }));
+    private final int e;
+    private final RegionFileCompression.a<InputStream> f;
+    private final RegionFileCompression.a<OutputStream> g;
+
+    private RegionFileCompression(int i, RegionFileCompression.a<InputStream> regionfilecompression_a, RegionFileCompression.a<OutputStream> regionfilecompression_a1) {
+        this.e = i;
+        this.f = regionfilecompression_a;
+        this.g = regionfilecompression_a1;
+    }
+
+    private static RegionFileCompression a(RegionFileCompression regionfilecompression) {
+        RegionFileCompression.d.put(regionfilecompression.e, regionfilecompression);
+        return regionfilecompression;
+    }
+
+    @Nullable
+    public static RegionFileCompression a(int i) {
+        return (RegionFileCompression) RegionFileCompression.d.get(i);
+    }
+
+    public static boolean b(int i) {
+        return RegionFileCompression.d.containsKey(i);
+    }
+
+    public int a() {
+        return this.e;
+    }
+
+    public OutputStream a(OutputStream outputstream) throws IOException {
+        return (OutputStream) this.g.wrap(outputstream);
+    }
+
+    public InputStream a(InputStream inputstream) throws IOException {
+        return (InputStream) this.f.wrap(inputstream);
+    }
+
+    @FunctionalInterface
+    interface a<O> {
+
+        O wrap(O o0) throws IOException;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileSection.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileSection.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ad97a8a2189553da88810380b1c240079eacc93
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileSection.java
@@ -0,0 +1,230 @@
+package net.minecraft.world.level.chunk.storage;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.mojang.datafixers.DataFixer;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Dynamic;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.OptionalDynamic;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
+import java.io.File;
+import java.io.IOException;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.BooleanSupplier;
+import java.util.function.Function;
+import javax.annotation.Nullable;
+import net.minecraft.SharedConstants;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.nbt.DynamicOpsNBT;
+import net.minecraft.nbt.NBTBase;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.util.datafix.DataFixTypes;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.World;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class RegionFileSection<R> implements AutoCloseable {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private final IOWorker b;
+    private final Long2ObjectMap<Optional<R>> c = new Long2ObjectOpenHashMap();
+    private final LongLinkedOpenHashSet d = new LongLinkedOpenHashSet();
+    private final Function<Runnable, Codec<R>> e;
+    private final Function<Runnable, R> f;
+    private final DataFixer g;
+    private final DataFixTypes h;
+
+    public RegionFileSection(File file, Function<Runnable, Codec<R>> function, Function<Runnable, R> function1, DataFixer datafixer, DataFixTypes datafixtypes, boolean flag) {
+        this.e = function;
+        this.f = function1;
+        this.g = datafixer;
+        this.h = datafixtypes;
+        this.b = new IOWorker(file, flag, file.getName());
+    }
+
+    protected void a(BooleanSupplier booleansupplier) {
+        while (!this.d.isEmpty() && booleansupplier.getAsBoolean()) {
+            ChunkCoordIntPair chunkcoordintpair = SectionPosition.a(this.d.firstLong()).r();
+
+            this.d(chunkcoordintpair);
+        }
+
+    }
+
+    @Nullable
+    protected Optional<R> c(long i) {
+        return (Optional) this.c.get(i);
+    }
+
+    protected Optional<R> d(long i) {
+        SectionPosition sectionposition = SectionPosition.a(i);
+
+        if (this.b(sectionposition)) {
+            return Optional.empty();
+        } else {
+            Optional<R> optional = this.c(i);
+
+            if (optional != null) {
+                return optional;
+            } else {
+                this.b(sectionposition.r());
+                optional = this.c(i);
+                if (optional == null) {
+                    throw (IllegalStateException) SystemUtils.c((Throwable) (new IllegalStateException()));
+                } else {
+                    return optional;
+                }
+            }
+        }
+    }
+
+    protected boolean b(SectionPosition sectionposition) {
+        return World.b(SectionPosition.c(sectionposition.b()));
+    }
+
+    protected R e(long i) {
+        Optional<R> optional = this.d(i);
+
+        if (optional.isPresent()) {
+            return optional.get();
+        } else {
+            R r0 = this.f.apply(() -> {
+                this.a(i);
+            });
+
+            this.c.put(i, Optional.of(r0));
+            return r0;
+        }
+    }
+
+    private void b(ChunkCoordIntPair chunkcoordintpair) {
+        this.a(chunkcoordintpair, DynamicOpsNBT.a, this.c(chunkcoordintpair));
+    }
+
+    @Nullable
+    private NBTTagCompound c(ChunkCoordIntPair chunkcoordintpair) {
+        try {
+            return this.b.a(chunkcoordintpair);
+        } catch (IOException ioexception) {
+            RegionFileSection.LOGGER.error("Error reading chunk {} data from disk", chunkcoordintpair, ioexception);
+            return null;
+        }
+    }
+
+    private <T> void a(ChunkCoordIntPair chunkcoordintpair, DynamicOps<T> dynamicops, @Nullable T t0) {
+        if (t0 == null) {
+            for (int i = 0; i < 16; ++i) {
+                this.c.put(SectionPosition.a(chunkcoordintpair, i).s(), Optional.empty());
+            }
+        } else {
+            Dynamic<T> dynamic = new Dynamic(dynamicops, t0);
+            int j = a(dynamic);
+            int k = SharedConstants.getGameVersion().getWorldVersion();
+            boolean flag = j != k;
+            Dynamic<T> dynamic1 = this.g.update(this.h.a(), dynamic, j, k);
+            OptionalDynamic<T> optionaldynamic = dynamic1.get("Sections");
+
+            for (int l = 0; l < 16; ++l) {
+                long i1 = SectionPosition.a(chunkcoordintpair, l).s();
+                Optional<R> optional = optionaldynamic.get(Integer.toString(l)).result().flatMap((dynamic2) -> {
+                    DataResult dataresult = ((Codec) this.e.apply(() -> {
+                        this.a(i1);
+                    })).parse(dynamic2);
+                    Logger logger = RegionFileSection.LOGGER;
+
+                    logger.getClass();
+                    return dataresult.resultOrPartial(logger::error);
+                });
+
+                this.c.put(i1, optional);
+                optional.ifPresent((object) -> {
+                    this.b(i1);
+                    if (flag) {
+                        this.a(i1);
+                    }
+
+                });
+            }
+        }
+
+    }
+
+    private void d(ChunkCoordIntPair chunkcoordintpair) {
+        Dynamic<NBTBase> dynamic = this.a(chunkcoordintpair, DynamicOpsNBT.a);
+        NBTBase nbtbase = (NBTBase) dynamic.getValue();
+
+        if (nbtbase instanceof NBTTagCompound) {
+            this.b.a(chunkcoordintpair, (NBTTagCompound) nbtbase);
+        } else {
+            RegionFileSection.LOGGER.error("Expected compound tag, got {}", nbtbase);
+        }
+
+    }
+
+    private <T> Dynamic<T> a(ChunkCoordIntPair chunkcoordintpair, DynamicOps<T> dynamicops) {
+        Map<T, T> map = Maps.newHashMap();
+
+        for (int i = 0; i < 16; ++i) {
+            long j = SectionPosition.a(chunkcoordintpair, i).s();
+
+            this.d.remove(j);
+            Optional<R> optional = (Optional) this.c.get(j);
+
+            if (optional != null && optional.isPresent()) {
+                DataResult<T> dataresult = ((Codec) this.e.apply(() -> {
+                    this.a(j);
+                })).encodeStart(dynamicops, optional.get());
+                String s = Integer.toString(i);
+                Logger logger = RegionFileSection.LOGGER;
+
+                logger.getClass();
+                dataresult.resultOrPartial(logger::error).ifPresent((object) -> {
+                    map.put(dynamicops.createString(s), object);
+                });
+            }
+        }
+
+        return new Dynamic(dynamicops, dynamicops.createMap(ImmutableMap.of(dynamicops.createString("Sections"), dynamicops.createMap(map), dynamicops.createString("DataVersion"), dynamicops.createInt(SharedConstants.getGameVersion().getWorldVersion()))));
+    }
+
+    protected void b(long i) {}
+
+    protected void a(long i) {
+        Optional<R> optional = (Optional) this.c.get(i);
+
+        if (optional != null && optional.isPresent()) {
+            this.d.add(i);
+        } else {
+            RegionFileSection.LOGGER.warn("No data for position: {}", SectionPosition.a(i));
+        }
+    }
+
+    private static int a(Dynamic<?> dynamic) {
+        return dynamic.get("DataVersion").asInt(1945);
+    }
+
+    public void a(ChunkCoordIntPair chunkcoordintpair) {
+        if (!this.d.isEmpty()) {
+            for (int i = 0; i < 16; ++i) {
+                long j = SectionPosition.a(chunkcoordintpair, i).s();
+
+                if (this.d.contains(j)) {
+                    this.d(chunkcoordintpair);
+                    return;
+                }
+            }
+        }
+
+    }
+
+    public void close() throws IOException {
+        this.b.close();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/dimension/DimensionManager.java b/src/main/java/net/minecraft/world/level/dimension/DimensionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..72bc1a1e1c2153550313e93cf7df901a514a9bef
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/dimension/DimensionManager.java
@@ -0,0 +1,268 @@
+package net.minecraft.world.level.dimension;
+
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Dynamic;
+import com.mojang.serialization.Lifecycle;
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import java.io.File;
+import java.util.Optional;
+import java.util.OptionalLong;
+import java.util.function.Supplier;
+import net.minecraft.core.IRegistry;
+import net.minecraft.core.IRegistryCustom;
+import net.minecraft.core.IRegistryWritable;
+import net.minecraft.core.RegistryMaterials;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.resources.RegistryFileCodec;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsBlock;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.biome.GenLayerZoomVoronoi;
+import net.minecraft.world.level.biome.GenLayerZoomVoronoiFixed;
+import net.minecraft.world.level.biome.GenLayerZoomer;
+import net.minecraft.world.level.biome.WorldChunkManagerMultiNoise;
+import net.minecraft.world.level.biome.WorldChunkManagerTheEnd;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.ChunkGeneratorAbstract;
+import net.minecraft.world.level.levelgen.GeneratorSettingBase;
+
+public class DimensionManager {
+
+    public static final MinecraftKey OVERWORLD_KEY = new MinecraftKey("overworld");
+    public static final MinecraftKey THE_NETHER_KEY = new MinecraftKey("the_nether");
+    public static final MinecraftKey THE_END_KEY = new MinecraftKey("the_end");
+    public static final Codec<DimensionManager> d = RecordCodecBuilder.create((instance) -> {
+        return instance.group(Codec.LONG.optionalFieldOf("fixed_time").xmap((optional) -> {
+            return (OptionalLong) optional.map(OptionalLong::of).orElseGet(OptionalLong::empty);
+        }, (optionallong) -> {
+            return optionallong.isPresent() ? Optional.of(optionallong.getAsLong()) : Optional.empty();
+        }).forGetter((dimensionmanager) -> {
+            return dimensionmanager.fixedTime;
+        }), Codec.BOOL.fieldOf("has_skylight").forGetter(DimensionManager::hasSkyLight), Codec.BOOL.fieldOf("has_ceiling").forGetter(DimensionManager::hasCeiling), Codec.BOOL.fieldOf("ultrawarm").forGetter(DimensionManager::isNether), Codec.BOOL.fieldOf("natural").forGetter(DimensionManager::isNatural), Codec.doubleRange(9.999999747378752E-6D, 3.0E7D).fieldOf("coordinate_scale").forGetter(DimensionManager::getCoordinateScale), Codec.BOOL.fieldOf("piglin_safe").forGetter(DimensionManager::isPiglinSafe), Codec.BOOL.fieldOf("bed_works").forGetter(DimensionManager::isBedWorks), Codec.BOOL.fieldOf("respawn_anchor_works").forGetter(DimensionManager::isRespawnAnchorWorks), Codec.BOOL.fieldOf("has_raids").forGetter(DimensionManager::hasRaids), Codec.intRange(0, 256).fieldOf("logical_height").forGetter(DimensionManager::getLogicalHeight), MinecraftKey.a.fieldOf("infiniburn").forGetter((dimensionmanager) -> {
+            return dimensionmanager.infiniburn;
+        }), MinecraftKey.a.fieldOf("effects").orElse(DimensionManager.OVERWORLD_KEY).forGetter((dimensionmanager) -> {
+            return dimensionmanager.effects;
+        }), Codec.FLOAT.fieldOf("ambient_light").forGetter((dimensionmanager) -> {
+            return dimensionmanager.ambientLight;
+        })).apply(instance, DimensionManager::new);
+    });
+    public static final float[] e = new float[]{1.0F, 0.75F, 0.5F, 0.25F, 0.0F, 0.25F, 0.5F, 0.75F};
+    public static final ResourceKey<DimensionManager> OVERWORLD = ResourceKey.a(IRegistry.K, new MinecraftKey("overworld"));
+    public static final ResourceKey<DimensionManager> THE_NETHER = ResourceKey.a(IRegistry.K, new MinecraftKey("the_nether"));
+    public static final ResourceKey<DimensionManager> THE_END = ResourceKey.a(IRegistry.K, new MinecraftKey("the_end"));
+    protected static final DimensionManager OVERWORLD_IMPL = new DimensionManager(OptionalLong.empty(), true, false, false, true, 1.0D, false, false, true, false, true, 256, GenLayerZoomVoronoiFixed.INSTANCE, TagsBlock.aE.a(), DimensionManager.OVERWORLD_KEY, 0.0F);
+    protected static final DimensionManager THE_NETHER_IMPL = new DimensionManager(OptionalLong.of(18000L), false, true, true, false, 8.0D, false, true, false, true, false, 128, GenLayerZoomVoronoi.INSTANCE, TagsBlock.aF.a(), DimensionManager.THE_NETHER_KEY, 0.1F);
+    protected static final DimensionManager THE_END_IMPL = new DimensionManager(OptionalLong.of(6000L), false, false, false, false, 1.0D, true, false, false, false, true, 256, GenLayerZoomVoronoi.INSTANCE, TagsBlock.aG.a(), DimensionManager.THE_END_KEY, 0.0F);
+    public static final ResourceKey<DimensionManager> l = ResourceKey.a(IRegistry.K, new MinecraftKey("overworld_caves"));
+    protected static final DimensionManager m = new DimensionManager(OptionalLong.empty(), true, true, false, true, 1.0D, false, false, true, false, true, 256, GenLayerZoomVoronoiFixed.INSTANCE, TagsBlock.aE.a(), DimensionManager.OVERWORLD_KEY, 0.0F);
+    public static final Codec<Supplier<DimensionManager>> n = RegistryFileCodec.a(IRegistry.K, DimensionManager.d);
+    private final OptionalLong fixedTime;
+    private final boolean hasSkylight;
+    private final boolean hasCeiling;
+    private final boolean ultraWarm;
+    private final boolean natural;
+    private final double coordinateScale;
+    private final boolean createDragonBattle;
+    private final boolean piglinSafe;
+    private final boolean bedWorks;
+    private final boolean respawnAnchorWorks;
+    private final boolean hasRaids;
+    private final int logicalHeight;
+    private final GenLayerZoomer genLayerZoomer;
+    private final MinecraftKey infiniburn;
+    private final MinecraftKey effects;
+    private final float ambientLight;
+    private final transient float[] E;
+
+    protected DimensionManager(OptionalLong optionallong, boolean flag, boolean flag1, boolean flag2, boolean flag3, double d0, boolean flag4, boolean flag5, boolean flag6, boolean flag7, int i, MinecraftKey minecraftkey, MinecraftKey minecraftkey1, float f) {
+        this(optionallong, flag, flag1, flag2, flag3, d0, false, flag4, flag5, flag6, flag7, i, GenLayerZoomVoronoi.INSTANCE, minecraftkey, minecraftkey1, f);
+    }
+
+    protected DimensionManager(OptionalLong optionallong, boolean flag, boolean flag1, boolean flag2, boolean flag3, double d0, boolean flag4, boolean flag5, boolean flag6, boolean flag7, boolean flag8, int i, GenLayerZoomer genlayerzoomer, MinecraftKey minecraftkey, MinecraftKey minecraftkey1, float f) {
+        this.fixedTime = optionallong;
+        this.hasSkylight = flag;
+        this.hasCeiling = flag1;
+        this.ultraWarm = flag2;
+        this.natural = flag3;
+        this.coordinateScale = d0;
+        this.createDragonBattle = flag4;
+        this.piglinSafe = flag5;
+        this.bedWorks = flag6;
+        this.respawnAnchorWorks = flag7;
+        this.hasRaids = flag8;
+        this.logicalHeight = i;
+        this.genLayerZoomer = genlayerzoomer;
+        this.infiniburn = minecraftkey;
+        this.effects = minecraftkey1;
+        this.ambientLight = f;
+        this.E = a(f);
+    }
+
+    private static float[] a(float f) {
+        float[] afloat = new float[16];
+
+        for (int i = 0; i <= 15; ++i) {
+            float f1 = (float) i / 15.0F;
+            float f2 = f1 / (4.0F - 3.0F * f1);
+
+            afloat[i] = MathHelper.g(f, f2, 1.0F);
+        }
+
+        return afloat;
+    }
+
+    @Deprecated
+    public static DataResult<ResourceKey<World>> a(Dynamic<?> dynamic) {
+        Optional<Number> optional = dynamic.asNumber().result();
+
+        if (optional.isPresent()) {
+            int i = ((Number) optional.get()).intValue();
+
+            if (i == -1) {
+                return DataResult.success(World.THE_NETHER);
+            }
+
+            if (i == 0) {
+                return DataResult.success(World.OVERWORLD);
+            }
+
+            if (i == 1) {
+                return DataResult.success(World.THE_END);
+            }
+        }
+
+        return World.f.parse(dynamic);
+    }
+
+    public static IRegistryCustom.Dimension a(IRegistryCustom.Dimension iregistrycustom_dimension) {
+        IRegistryWritable<DimensionManager> iregistrywritable = iregistrycustom_dimension.b(IRegistry.K);
+
+        iregistrywritable.a(DimensionManager.OVERWORLD, (Object) DimensionManager.OVERWORLD_IMPL, Lifecycle.stable());
+        iregistrywritable.a(DimensionManager.l, (Object) DimensionManager.m, Lifecycle.stable());
+        iregistrywritable.a(DimensionManager.THE_NETHER, (Object) DimensionManager.THE_NETHER_IMPL, Lifecycle.stable());
+        iregistrywritable.a(DimensionManager.THE_END, (Object) DimensionManager.THE_END_IMPL, Lifecycle.stable());
+        return iregistrycustom_dimension;
+    }
+
+    private static ChunkGenerator a(IRegistry<BiomeBase> iregistry, IRegistry<GeneratorSettingBase> iregistry1, long i) {
+        return new ChunkGeneratorAbstract(new WorldChunkManagerTheEnd(iregistry, i), i, () -> {
+            return (GeneratorSettingBase) iregistry1.d(GeneratorSettingBase.f);
+        });
+    }
+
+    private static ChunkGenerator b(IRegistry<BiomeBase> iregistry, IRegistry<GeneratorSettingBase> iregistry1, long i) {
+        return new ChunkGeneratorAbstract(WorldChunkManagerMultiNoise.b.a.a(iregistry, i), i, () -> {
+            return (GeneratorSettingBase) iregistry1.d(GeneratorSettingBase.e);
+        });
+    }
+
+    public static RegistryMaterials<WorldDimension> a(IRegistry<DimensionManager> iregistry, IRegistry<BiomeBase> iregistry1, IRegistry<GeneratorSettingBase> iregistry2, long i) {
+        RegistryMaterials<WorldDimension> registrymaterials = new RegistryMaterials<>(IRegistry.M, Lifecycle.experimental());
+
+        registrymaterials.a(WorldDimension.THE_NETHER, (Object) (new WorldDimension(() -> {
+            return (DimensionManager) iregistry.d(DimensionManager.THE_NETHER);
+        }, b(iregistry1, iregistry2, i))), Lifecycle.stable());
+        registrymaterials.a(WorldDimension.THE_END, (Object) (new WorldDimension(() -> {
+            return (DimensionManager) iregistry.d(DimensionManager.THE_END);
+        }, a(iregistry1, iregistry2, i))), Lifecycle.stable());
+        return registrymaterials;
+    }
+
+    public static double a(DimensionManager dimensionmanager, DimensionManager dimensionmanager1) {
+        double d0 = dimensionmanager.getCoordinateScale();
+        double d1 = dimensionmanager1.getCoordinateScale();
+
+        return d0 / d1;
+    }
+
+    @Deprecated
+    public String getSuffix() {
+        return this.a(DimensionManager.THE_END_IMPL) ? "_end" : "";
+    }
+
+    public static File a(ResourceKey<World> resourcekey, File file) {
+        return resourcekey == World.OVERWORLD ? file : (resourcekey == World.THE_END ? new File(file, "DIM1") : (resourcekey == World.THE_NETHER ? new File(file, "DIM-1") : new File(file, "dimensions/" + resourcekey.a().getNamespace() + "/" + resourcekey.a().getKey())));
+    }
+
+    public boolean hasSkyLight() {
+        return this.hasSkylight;
+    }
+
+    public boolean hasCeiling() {
+        return this.hasCeiling;
+    }
+
+    public boolean isNether() {
+        return this.ultraWarm;
+    }
+
+    public boolean isNatural() {
+        return this.natural;
+    }
+
+    public double getCoordinateScale() {
+        return this.coordinateScale;
+    }
+
+    public boolean isPiglinSafe() {
+        return this.piglinSafe;
+    }
+
+    public boolean isBedWorks() {
+        return this.bedWorks;
+    }
+
+    public boolean isRespawnAnchorWorks() {
+        return this.respawnAnchorWorks;
+    }
+
+    public boolean hasRaids() {
+        return this.hasRaids;
+    }
+
+    public int getLogicalHeight() {
+        return this.logicalHeight;
+    }
+
+    public boolean isCreateDragonBattle() {
+        return this.createDragonBattle;
+    }
+
+    public GenLayerZoomer getGenLayerZoomer() {
+        return this.genLayerZoomer;
+    }
+
+    public boolean isFixedTime() {
+        return this.fixedTime.isPresent();
+    }
+
+    public float a(long i) {
+        double d0 = MathHelper.h((double) this.fixedTime.orElse(i) / 24000.0D - 0.25D);
+        double d1 = 0.5D - Math.cos(d0 * 3.141592653589793D) / 2.0D;
+
+        return (float) (d0 * 2.0D + d1) / 3.0F;
+    }
+
+    public int b(long i) {
+        return (int) (i / 24000L % 8L + 8L) % 8;
+    }
+
+    public float a(int i) {
+        return this.E[i];
+    }
+
+    public Tag<Block> o() {
+        Tag<Block> tag = TagsBlock.a().a(this.infiniburn);
+
+        return (Tag) (tag != null ? tag : TagsBlock.aE);
+    }
+
+    public boolean a(DimensionManager dimensionmanager) {
+        return this == dimensionmanager ? true : this.hasSkylight == dimensionmanager.hasSkylight && this.hasCeiling == dimensionmanager.hasCeiling && this.ultraWarm == dimensionmanager.ultraWarm && this.natural == dimensionmanager.natural && this.coordinateScale == dimensionmanager.coordinateScale && this.createDragonBattle == dimensionmanager.createDragonBattle && this.piglinSafe == dimensionmanager.piglinSafe && this.bedWorks == dimensionmanager.bedWorks && this.respawnAnchorWorks == dimensionmanager.respawnAnchorWorks && this.hasRaids == dimensionmanager.hasRaids && this.logicalHeight == dimensionmanager.logicalHeight && Float.compare(dimensionmanager.ambientLight, this.ambientLight) == 0 && this.fixedTime.equals(dimensionmanager.fixedTime) && this.genLayerZoomer.equals(dimensionmanager.genLayerZoomer) && this.infiniburn.equals(dimensionmanager.infiniburn) && this.effects.equals(dimensionmanager.effects);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/dimension/end/EnderDragonBattle.java b/src/main/java/net/minecraft/world/level/dimension/end/EnderDragonBattle.java
new file mode 100644
index 0000000000000000000000000000000000000000..38c20c4a8521560eac52e06f848ef835103f107f
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/dimension/end/EnderDragonBattle.java
@@ -0,0 +1,564 @@
+package net.minecraft.world.level.dimension.end;
+
+import com.google.common.collect.ContiguousSet;
+import com.google.common.collect.DiscreteDomain;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Range;
+import com.google.common.collect.Sets;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+import java.util.UUID;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.advancements.CriterionTriggers;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.data.worldgen.BiomeDecoratorGroups;
+import net.minecraft.nbt.GameProfileSerializer;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagInt;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.server.level.BossBattleServer;
+import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.server.level.PlayerChunk;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.util.MathHelper;
+import net.minecraft.util.Unit;
+import net.minecraft.world.BossBattle;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityTypes;
+import net.minecraft.world.entity.IEntitySelector;
+import net.minecraft.world.entity.boss.enderdragon.EntityEnderCrystal;
+import net.minecraft.world.entity.boss.enderdragon.EntityEnderDragon;
+import net.minecraft.world.entity.boss.enderdragon.phases.DragonControllerPhase;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.GeneratorAccessSeed;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.block.entity.TileEntityEnderPortal;
+import net.minecraft.world.level.block.state.pattern.ShapeDetector;
+import net.minecraft.world.level.block.state.pattern.ShapeDetectorBlock;
+import net.minecraft.world.level.block.state.pattern.ShapeDetectorBuilder;
+import net.minecraft.world.level.block.state.predicate.BlockPredicate;
+import net.minecraft.world.level.chunk.Chunk;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.levelgen.HeightMap;
+import net.minecraft.world.level.levelgen.feature.WorldGenEndTrophy;
+import net.minecraft.world.level.levelgen.feature.WorldGenEnder;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureConfiguration;
+import net.minecraft.world.phys.AxisAlignedBB;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class EnderDragonBattle {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final Predicate<Entity> b = IEntitySelector.a.and(IEntitySelector.a(0.0D, 128.0D, 0.0D, 192.0D));
+    public final BossBattleServer bossBattle;
+    public final WorldServer world;
+    private final List<Integer> gateways;
+    private final ShapeDetector f;
+    private int g;
+    private int h;
+    private int i;
+    private int j;
+    private boolean dragonKilled;
+    private boolean previouslyKilled;
+    public UUID dragonUUID;
+    private boolean n;
+    public BlockPosition exitPortalLocation;
+    public EnumDragonRespawn respawnPhase;
+    private int q;
+    private List<EntityEnderCrystal> r;
+
+    public EnderDragonBattle(WorldServer worldserver, long i, NBTTagCompound nbttagcompound) {
+        this.bossBattle = (BossBattleServer) (new BossBattleServer(new ChatMessage("entity.minecraft.ender_dragon"), BossBattle.BarColor.PINK, BossBattle.BarStyle.PROGRESS)).setPlayMusic(true).setCreateFog(true);
+        this.gateways = Lists.newArrayList();
+        this.n = true;
+        this.world = worldserver;
+        if (nbttagcompound.hasKeyOfType("DragonKilled", 99)) {
+            if (nbttagcompound.b("Dragon")) {
+                this.dragonUUID = nbttagcompound.a("Dragon");
+            }
+
+            this.dragonKilled = nbttagcompound.getBoolean("DragonKilled");
+            this.previouslyKilled = nbttagcompound.getBoolean("PreviouslyKilled");
+            if (nbttagcompound.getBoolean("IsRespawning")) {
+                this.respawnPhase = EnumDragonRespawn.START;
+            }
+
+            if (nbttagcompound.hasKeyOfType("ExitPortalLocation", 10)) {
+                this.exitPortalLocation = GameProfileSerializer.b(nbttagcompound.getCompound("ExitPortalLocation"));
+            }
+        } else {
+            this.dragonKilled = true;
+            this.previouslyKilled = true;
+        }
+
+        if (nbttagcompound.hasKeyOfType("Gateways", 9)) {
+            NBTTagList nbttaglist = nbttagcompound.getList("Gateways", 3);
+
+            for (int j = 0; j < nbttaglist.size(); ++j) {
+                this.gateways.add(nbttaglist.e(j));
+            }
+        } else {
+            this.gateways.addAll(ContiguousSet.create(Range.closedOpen(0, 20), DiscreteDomain.integers()));
+            Collections.shuffle(this.gateways, new Random(i));
+        }
+
+        this.f = ShapeDetectorBuilder.a().a("       ", "       ", "       ", "   #   ", "       ", "       ", "       ").a("       ", "       ", "       ", "   #   ", "       ", "       ", "       ").a("       ", "       ", "       ", "   #   ", "       ", "       ", "       ").a("  ###  ", " #   # ", "#     #", "#  #  #", "#     #", " #   # ", "  ###  ").a("       ", "  ###  ", " ##### ", " ##### ", " ##### ", "  ###  ", "       ").a('#', ShapeDetectorBlock.a(BlockPredicate.a(Blocks.BEDROCK))).b();
+    }
+
+    public NBTTagCompound a() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        if (this.dragonUUID != null) {
+            nbttagcompound.a("Dragon", this.dragonUUID);
+        }
+
+        nbttagcompound.setBoolean("DragonKilled", this.dragonKilled);
+        nbttagcompound.setBoolean("PreviouslyKilled", this.previouslyKilled);
+        if (this.exitPortalLocation != null) {
+            nbttagcompound.set("ExitPortalLocation", GameProfileSerializer.a(this.exitPortalLocation));
+        }
+
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.gateways.iterator();
+
+        while (iterator.hasNext()) {
+            int i = (Integer) iterator.next();
+
+            nbttaglist.add(NBTTagInt.a(i));
+        }
+
+        nbttagcompound.set("Gateways", nbttaglist);
+        return nbttagcompound;
+    }
+
+    public void b() {
+        this.bossBattle.setVisible(!this.dragonKilled);
+        if (++this.j >= 20) {
+            this.l();
+            this.j = 0;
+        }
+
+        if (!this.bossBattle.getPlayers().isEmpty()) {
+            this.world.getChunkProvider().addTicket(TicketType.DRAGON, new ChunkCoordIntPair(0, 0), 9, Unit.INSTANCE);
+            boolean flag = this.k();
+
+            if (this.n && flag) {
+                this.g();
+                this.n = false;
+            }
+
+            if (this.respawnPhase != null) {
+                if (this.r == null && flag) {
+                    this.respawnPhase = null;
+                    this.initiateRespawn();
+                }
+
+                this.respawnPhase.a(this.world, this, this.r, this.q++, this.exitPortalLocation);
+            }
+
+            if (!this.dragonKilled) {
+                if ((this.dragonUUID == null || ++this.g >= 1200) && flag) {
+                    this.h();
+                    this.g = 0;
+                }
+
+                if (++this.i >= 100 && flag) {
+                    this.m();
+                    this.i = 0;
+                }
+            }
+        } else {
+            this.world.getChunkProvider().removeTicket(TicketType.DRAGON, new ChunkCoordIntPair(0, 0), 9, Unit.INSTANCE);
+        }
+
+    }
+
+    private void g() {
+        EnderDragonBattle.LOGGER.info("Scanning for legacy world dragon fight...");
+        boolean flag = this.i();
+
+        if (flag) {
+            EnderDragonBattle.LOGGER.info("Found that the dragon has been killed in this world already.");
+            this.previouslyKilled = true;
+        } else {
+            EnderDragonBattle.LOGGER.info("Found that the dragon has not yet been killed in this world.");
+            this.previouslyKilled = false;
+            if (this.getExitPortalShape() == null) {
+                this.generateExitPortal(false);
+            }
+        }
+
+        List<EntityEnderDragon> list = this.world.g();
+
+        if (list.isEmpty()) {
+            this.dragonKilled = true;
+        } else {
+            EntityEnderDragon entityenderdragon = (EntityEnderDragon) list.get(0);
+
+            this.dragonUUID = entityenderdragon.getUniqueID();
+            EnderDragonBattle.LOGGER.info("Found that there's a dragon still alive ({})", entityenderdragon);
+            this.dragonKilled = false;
+            if (!flag) {
+                EnderDragonBattle.LOGGER.info("But we didn't have a portal, let's remove it.");
+                entityenderdragon.die();
+                this.dragonUUID = null;
+            }
+        }
+
+        if (!this.previouslyKilled && this.dragonKilled) {
+            this.dragonKilled = false;
+        }
+
+    }
+
+    private void h() {
+        List<EntityEnderDragon> list = this.world.g();
+
+        if (list.isEmpty()) {
+            EnderDragonBattle.LOGGER.debug("Haven't seen the dragon, respawning it");
+            this.o();
+        } else {
+            EnderDragonBattle.LOGGER.debug("Haven't seen our dragon, but found another one to use.");
+            this.dragonUUID = ((EntityEnderDragon) list.get(0)).getUniqueID();
+        }
+
+    }
+
+    public void setRespawnPhase(EnumDragonRespawn enumdragonrespawn) {
+        if (this.respawnPhase == null) {
+            throw new IllegalStateException("Dragon respawn isn't in progress, can't skip ahead in the animation.");
+        } else {
+            this.q = 0;
+            if (enumdragonrespawn == EnumDragonRespawn.END) {
+                this.respawnPhase = null;
+                this.dragonKilled = false;
+                EntityEnderDragon entityenderdragon = this.o();
+                Iterator iterator = this.bossBattle.getPlayers().iterator();
+
+                while (iterator.hasNext()) {
+                    EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+                    CriterionTriggers.n.a(entityplayer, (Entity) entityenderdragon);
+                }
+            } else {
+                this.respawnPhase = enumdragonrespawn;
+            }
+
+        }
+    }
+
+    private boolean i() {
+        for (int i = -8; i <= 8; ++i) {
+            int j = -8;
+
+            label27:
+            while (j <= 8) {
+                Chunk chunk = this.world.getChunkAt(i, j);
+                Iterator iterator = chunk.getTileEntities().values().iterator();
+
+                TileEntity tileentity;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        ++j;
+                        continue label27;
+                    }
+
+                    tileentity = (TileEntity) iterator.next();
+                } while (!(tileentity instanceof TileEntityEnderPortal));
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Nullable
+    public ShapeDetector.ShapeDetectorCollection getExitPortalShape() {
+        int i;
+        int j;
+
+        for (i = -8; i <= 8; ++i) {
+            for (j = -8; j <= 8; ++j) {
+                Chunk chunk = this.world.getChunkAt(i, j);
+                Iterator iterator = chunk.getTileEntities().values().iterator();
+
+                while (iterator.hasNext()) {
+                    TileEntity tileentity = (TileEntity) iterator.next();
+
+                    if (tileentity instanceof TileEntityEnderPortal) {
+                        ShapeDetector.ShapeDetectorCollection shapedetector_shapedetectorcollection = this.f.a(this.world, tileentity.getPosition());
+
+                        if (shapedetector_shapedetectorcollection != null) {
+                            BlockPosition blockposition = shapedetector_shapedetectorcollection.a(3, 3, 3).getPosition();
+
+                            if (this.exitPortalLocation == null && blockposition.getX() == 0 && blockposition.getZ() == 0) {
+                                this.exitPortalLocation = blockposition;
+                            }
+
+                            return shapedetector_shapedetectorcollection;
+                        }
+                    }
+                }
+            }
+        }
+
+        i = this.world.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, WorldGenEndTrophy.a).getY();
+
+        for (j = i; j >= 0; --j) {
+            ShapeDetector.ShapeDetectorCollection shapedetector_shapedetectorcollection1 = this.f.a(this.world, new BlockPosition(WorldGenEndTrophy.a.getX(), j, WorldGenEndTrophy.a.getZ()));
+
+            if (shapedetector_shapedetectorcollection1 != null) {
+                if (this.exitPortalLocation == null) {
+                    this.exitPortalLocation = shapedetector_shapedetectorcollection1.a(3, 3, 3).getPosition();
+                }
+
+                return shapedetector_shapedetectorcollection1;
+            }
+        }
+
+        return null;
+    }
+
+    private boolean k() {
+        for (int i = -8; i <= 8; ++i) {
+            for (int j = 8; j <= 8; ++j) {
+                IChunkAccess ichunkaccess = this.world.getChunkAt(i, j, ChunkStatus.FULL, false);
+
+                if (!(ichunkaccess instanceof Chunk)) {
+                    return false;
+                }
+
+                PlayerChunk.State playerchunk_state = ((Chunk) ichunkaccess).getState();
+
+                if (!playerchunk_state.isAtLeast(PlayerChunk.State.TICKING)) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    private void l() {
+        Set<EntityPlayer> set = Sets.newHashSet();
+        Iterator iterator = this.world.a(EnderDragonBattle.b).iterator();
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+            this.bossBattle.addPlayer(entityplayer);
+            set.add(entityplayer);
+        }
+
+        Set<EntityPlayer> set1 = Sets.newHashSet(this.bossBattle.getPlayers());
+
+        set1.removeAll(set);
+        Iterator iterator1 = set1.iterator();
+
+        while (iterator1.hasNext()) {
+            EntityPlayer entityplayer1 = (EntityPlayer) iterator1.next();
+
+            this.bossBattle.removePlayer(entityplayer1);
+        }
+
+    }
+
+    private void m() {
+        this.i = 0;
+        this.h = 0;
+
+        WorldGenEnder.Spike worldgenender_spike;
+
+        for (Iterator iterator = WorldGenEnder.a((GeneratorAccessSeed) this.world).iterator(); iterator.hasNext(); this.h += this.world.a(EntityEnderCrystal.class, worldgenender_spike.f()).size()) {
+            worldgenender_spike = (WorldGenEnder.Spike) iterator.next();
+        }
+
+        EnderDragonBattle.LOGGER.debug("Found {} end crystals still alive", this.h);
+    }
+
+    public void a(EntityEnderDragon entityenderdragon) {
+        if (entityenderdragon.getUniqueID().equals(this.dragonUUID)) {
+            this.bossBattle.setProgress(0.0F);
+            this.bossBattle.setVisible(false);
+            this.generateExitPortal(true);
+            this.n();
+            if (!this.previouslyKilled) {
+                this.world.setTypeUpdate(this.world.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, WorldGenEndTrophy.a), Blocks.DRAGON_EGG.getBlockData());
+            }
+
+            this.previouslyKilled = true;
+            this.dragonKilled = true;
+        }
+
+    }
+
+    private void n() {
+        if (!this.gateways.isEmpty()) {
+            int i = (Integer) this.gateways.remove(this.gateways.size() - 1);
+            int j = MathHelper.floor(96.0D * Math.cos(2.0D * (-3.141592653589793D + 0.15707963267948966D * (double) i)));
+            int k = MathHelper.floor(96.0D * Math.sin(2.0D * (-3.141592653589793D + 0.15707963267948966D * (double) i)));
+
+            this.a(new BlockPosition(j, 75, k));
+        }
+    }
+
+    private void a(BlockPosition blockposition) {
+        this.world.triggerEffect(3000, blockposition, 0);
+        BiomeDecoratorGroups.END_GATEWAY_DELAYED.a(this.world, this.world.getChunkProvider().getChunkGenerator(), new Random(), blockposition);
+    }
+
+    public void generateExitPortal(boolean flag) {
+        WorldGenEndTrophy worldgenendtrophy = new WorldGenEndTrophy(flag);
+
+        if (this.exitPortalLocation == null) {
+            for (this.exitPortalLocation = this.world.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING_NO_LEAVES, WorldGenEndTrophy.a).down(); this.world.getType(this.exitPortalLocation).a(Blocks.BEDROCK) && this.exitPortalLocation.getY() > this.world.getSeaLevel(); this.exitPortalLocation = this.exitPortalLocation.down()) {
+                ;
+            }
+        }
+
+        worldgenendtrophy.b((WorldGenFeatureConfiguration) WorldGenFeatureConfiguration.k).a(this.world, this.world.getChunkProvider().getChunkGenerator(), new Random(), this.exitPortalLocation);
+    }
+
+    private EntityEnderDragon o() {
+        this.world.getChunkAtWorldCoords(new BlockPosition(0, 128, 0));
+        EntityEnderDragon entityenderdragon = (EntityEnderDragon) EntityTypes.ENDER_DRAGON.a((World) this.world);
+
+        entityenderdragon.getDragonControllerManager().setControllerPhase(DragonControllerPhase.HOLDING_PATTERN);
+        entityenderdragon.setPositionRotation(0.0D, 128.0D, 0.0D, this.world.random.nextFloat() * 360.0F, 0.0F);
+        this.world.addEntity(entityenderdragon);
+        this.dragonUUID = entityenderdragon.getUniqueID();
+        return entityenderdragon;
+    }
+
+    public void b(EntityEnderDragon entityenderdragon) {
+        if (entityenderdragon.getUniqueID().equals(this.dragonUUID)) {
+            this.bossBattle.setProgress(entityenderdragon.getHealth() / entityenderdragon.getMaxHealth());
+            this.g = 0;
+            if (entityenderdragon.hasCustomName()) {
+                this.bossBattle.a(entityenderdragon.getScoreboardDisplayName());
+            }
+        }
+
+    }
+
+    public int c() {
+        return this.h;
+    }
+
+    public void a(EntityEnderCrystal entityendercrystal, DamageSource damagesource) {
+        if (this.respawnPhase != null && this.r.contains(entityendercrystal)) {
+            EnderDragonBattle.LOGGER.debug("Aborting respawn sequence");
+            this.respawnPhase = null;
+            this.q = 0;
+            this.resetCrystals();
+            this.generateExitPortal(true);
+        } else {
+            this.m();
+            Entity entity = this.world.getEntity(this.dragonUUID);
+
+            if (entity instanceof EntityEnderDragon) {
+                ((EntityEnderDragon) entity).a(entityendercrystal, entityendercrystal.getChunkCoordinates(), damagesource);
+            }
+        }
+
+    }
+
+    public boolean isPreviouslyKilled() {
+        return this.previouslyKilled;
+    }
+
+    public void initiateRespawn() {
+        if (this.dragonKilled && this.respawnPhase == null) {
+            BlockPosition blockposition = this.exitPortalLocation;
+
+            if (blockposition == null) {
+                EnderDragonBattle.LOGGER.debug("Tried to respawn, but need to find the portal first.");
+                ShapeDetector.ShapeDetectorCollection shapedetector_shapedetectorcollection = this.getExitPortalShape();
+
+                if (shapedetector_shapedetectorcollection == null) {
+                    EnderDragonBattle.LOGGER.debug("Couldn't find a portal, so we made one.");
+                    this.generateExitPortal(true);
+                } else {
+                    EnderDragonBattle.LOGGER.debug("Found the exit portal & temporarily using it.");
+                }
+
+                blockposition = this.exitPortalLocation;
+            }
+
+            List<EntityEnderCrystal> list = Lists.newArrayList();
+            BlockPosition blockposition1 = blockposition.up(1);
+            Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+            while (iterator.hasNext()) {
+                EnumDirection enumdirection = (EnumDirection) iterator.next();
+                List<EntityEnderCrystal> list1 = this.world.a(EntityEnderCrystal.class, new AxisAlignedBB(blockposition1.shift(enumdirection, 2)));
+
+                if (list1.isEmpty()) {
+                    return;
+                }
+
+                list.addAll(list1);
+            }
+
+            EnderDragonBattle.LOGGER.debug("Found all crystals, respawning dragon.");
+            this.a((List) list);
+        }
+
+    }
+
+    private void a(List<EntityEnderCrystal> list) {
+        if (this.dragonKilled && this.respawnPhase == null) {
+            for (ShapeDetector.ShapeDetectorCollection shapedetector_shapedetectorcollection = this.getExitPortalShape(); shapedetector_shapedetectorcollection != null; shapedetector_shapedetectorcollection = this.getExitPortalShape()) {
+                for (int i = 0; i < this.f.c(); ++i) {
+                    for (int j = 0; j < this.f.b(); ++j) {
+                        for (int k = 0; k < this.f.a(); ++k) {
+                            ShapeDetectorBlock shapedetectorblock = shapedetector_shapedetectorcollection.a(i, j, k);
+
+                            if (shapedetectorblock.a().a(Blocks.BEDROCK) || shapedetectorblock.a().a(Blocks.END_PORTAL)) {
+                                this.world.setTypeUpdate(shapedetectorblock.getPosition(), Blocks.END_STONE.getBlockData());
+                            }
+                        }
+                    }
+                }
+            }
+
+            this.respawnPhase = EnumDragonRespawn.START;
+            this.q = 0;
+            this.generateExitPortal(false);
+            this.r = list;
+        }
+
+    }
+
+    public void resetCrystals() {
+        Iterator iterator = WorldGenEnder.a((GeneratorAccessSeed) this.world).iterator();
+
+        while (iterator.hasNext()) {
+            WorldGenEnder.Spike worldgenender_spike = (WorldGenEnder.Spike) iterator.next();
+            List<EntityEnderCrystal> list = this.world.a(EntityEnderCrystal.class, worldgenender_spike.f());
+            Iterator iterator1 = list.iterator();
+
+            while (iterator1.hasNext()) {
+                EntityEnderCrystal entityendercrystal = (EntityEnderCrystal) iterator1.next();
+
+                entityendercrystal.setInvulnerable(false);
+                entityendercrystal.setBeamTarget((BlockPosition) null);
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/levelgen/HeightMap.java b/src/main/java/net/minecraft/world/level/levelgen/HeightMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..bcb620e9b7f47341f51af0f3bb7fbd6a348f9739
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/HeightMap.java
@@ -0,0 +1,195 @@
+package net.minecraft.world.level.levelgen;
+
+import com.google.common.collect.Maps;
+import com.mojang.serialization.Codec;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectList;
+import it.unimi.dsi.fastutil.objects.ObjectListIterator;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.util.DataBits;
+import net.minecraft.util.INamable;
+import net.minecraft.world.level.block.BlockLeaves;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.IChunkAccess;
+
+public class HeightMap {
+
+    private static final Predicate<IBlockData> a = (iblockdata) -> {
+        return !iblockdata.isAir();
+    };
+    private static final Predicate<IBlockData> b = (iblockdata) -> {
+        return iblockdata.getMaterial().isSolid();
+    };
+    private final DataBits c = new DataBits(9, 256);
+    private final Predicate<IBlockData> d;
+    private final IChunkAccess e;
+
+    public HeightMap(IChunkAccess ichunkaccess, HeightMap.Type heightmap_type) {
+        this.d = heightmap_type.e();
+        this.e = ichunkaccess;
+    }
+
+    public static void a(IChunkAccess ichunkaccess, Set<HeightMap.Type> set) {
+        int i = set.size();
+        ObjectList<HeightMap> objectlist = new ObjectArrayList(i);
+        ObjectListIterator<HeightMap> objectlistiterator = objectlist.iterator();
+        int j = ichunkaccess.b() + 16;
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                Iterator iterator = set.iterator();
+
+                while (iterator.hasNext()) {
+                    HeightMap.Type heightmap_type = (HeightMap.Type) iterator.next();
+
+                    objectlist.add(ichunkaccess.a(heightmap_type));
+                }
+
+                for (int i1 = j - 1; i1 >= 0; --i1) {
+                    blockposition_mutableblockposition.d(k, i1, l);
+                    IBlockData iblockdata = ichunkaccess.getType(blockposition_mutableblockposition);
+
+                    if (!iblockdata.a(Blocks.AIR)) {
+                        while (objectlistiterator.hasNext()) {
+                            HeightMap heightmap = (HeightMap) objectlistiterator.next();
+
+                            if (heightmap.d.test(iblockdata)) {
+                                heightmap.a(k, l, i1 + 1);
+                                objectlistiterator.remove();
+                            }
+                        }
+
+                        if (objectlist.isEmpty()) {
+                            break;
+                        }
+
+                        objectlistiterator.back(i);
+                    }
+                }
+            }
+        }
+
+    }
+
+    public boolean a(int i, int j, int k, IBlockData iblockdata) {
+        int l = this.a(i, k);
+
+        if (j <= l - 2) {
+            return false;
+        } else {
+            if (this.d.test(iblockdata)) {
+                if (j >= l) {
+                    this.a(i, k, j + 1);
+                    return true;
+                }
+            } else if (l - 1 == j) {
+                BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+                for (int i1 = j - 1; i1 >= 0; --i1) {
+                    blockposition_mutableblockposition.d(i, i1, k);
+                    if (this.d.test(this.e.getType(blockposition_mutableblockposition))) {
+                        this.a(i, k, i1 + 1);
+                        return true;
+                    }
+                }
+
+                this.a(i, k, 0);
+                return true;
+            }
+
+            return false;
+        }
+    }
+
+    public int a(int i, int j) {
+        return this.a(c(i, j));
+    }
+
+    private int a(int i) {
+        return this.c.a(i);
+    }
+
+    private void a(int i, int j, int k) {
+        this.c.b(c(i, j), k);
+    }
+
+    public void a(long[] along) {
+        System.arraycopy(along, 0, this.c.a(), 0, along.length);
+    }
+
+    public long[] a() {
+        return this.c.a();
+    }
+
+    private static int c(int i, int j) {
+        return i + j * 16;
+    }
+
+    public static enum Type implements INamable {
+
+        WORLD_SURFACE_WG("WORLD_SURFACE_WG", HeightMap.Use.WORLDGEN, HeightMap.a), WORLD_SURFACE("WORLD_SURFACE", HeightMap.Use.CLIENT, HeightMap.a), OCEAN_FLOOR_WG("OCEAN_FLOOR_WG", HeightMap.Use.WORLDGEN, HeightMap.b), OCEAN_FLOOR("OCEAN_FLOOR", HeightMap.Use.LIVE_WORLD, HeightMap.b), MOTION_BLOCKING("MOTION_BLOCKING", HeightMap.Use.CLIENT, (iblockdata) -> {
+            return iblockdata.getMaterial().isSolid() || !iblockdata.getFluid().isEmpty();
+        }), MOTION_BLOCKING_NO_LEAVES("MOTION_BLOCKING_NO_LEAVES", HeightMap.Use.LIVE_WORLD, (iblockdata) -> {
+            return (iblockdata.getMaterial().isSolid() || !iblockdata.getFluid().isEmpty()) && !(iblockdata.getBlock() instanceof BlockLeaves);
+        });
+
+        public static final Codec<HeightMap.Type> g = INamable.a(HeightMap.Type::values, HeightMap.Type::a);
+        private final String h;
+        private final HeightMap.Use i;
+        private final Predicate<IBlockData> j;
+        private static final Map<String, HeightMap.Type> k = (Map) SystemUtils.a((Object) Maps.newHashMap(), (hashmap) -> {
+            HeightMap.Type[] aheightmap_type = values();
+            int i = aheightmap_type.length;
+
+            for (int j = 0; j < i; ++j) {
+                HeightMap.Type heightmap_type = aheightmap_type[j];
+
+                hashmap.put(heightmap_type.h, heightmap_type);
+            }
+
+        });
+
+        private Type(String s, HeightMap.Use heightmap_use, Predicate predicate) {
+            this.h = s;
+            this.i = heightmap_use;
+            this.j = predicate;
+        }
+
+        public String b() {
+            return this.h;
+        }
+
+        public boolean c() {
+            return this.i == HeightMap.Use.CLIENT;
+        }
+
+        @Nullable
+        public static HeightMap.Type a(String s) {
+            return (HeightMap.Type) HeightMap.Type.k.get(s);
+        }
+
+        public Predicate<IBlockData> e() {
+            return this.j;
+        }
+
+        @Override
+        public String getName() {
+            return this.h;
+        }
+    }
+
+    public static enum Use {
+
+        WORLDGEN, LIVE_WORLD, CLIENT;
+
+        private Use() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/StructureGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/feature/StructureGenerator.java
new file mode 100644
index 0000000000000000000000000000000000000000..44ad3fb2551f681b58b82e7c4f56bbc5a3b4486e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/StructureGenerator.java
@@ -0,0 +1,278 @@
+package net.minecraft.world.level.levelgen.feature;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.mojang.serialization.Codec;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.IRegistry;
+import net.minecraft.core.IRegistryCustom;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.resources.MinecraftKey;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.IWorldReader;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.biome.BiomeSettingsMobs;
+import net.minecraft.world.level.biome.WorldChunkManager;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.levelgen.SeededRandom;
+import net.minecraft.world.level.levelgen.WorldGenStage;
+import net.minecraft.world.level.levelgen.feature.configurations.StructureSettingsFeature;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureConfiguration;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureConfigurationChance;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureEmptyConfiguration;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureOceanRuinConfiguration;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureRuinedPortalConfiguration;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureShipwreckConfiguration;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureVillageConfiguration;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenMineshaftConfiguration;
+import net.minecraft.world.level.levelgen.structure.StructureBoundingBox;
+import net.minecraft.world.level.levelgen.structure.StructurePiece;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import net.minecraft.world.level.levelgen.structure.WorldGenFeatureNetherFossil;
+import net.minecraft.world.level.levelgen.structure.WorldGenFeatureOceanRuin;
+import net.minecraft.world.level.levelgen.structure.templatesystem.DefinedStructureManager;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public abstract class StructureGenerator<C extends WorldGenFeatureConfiguration> {
+
+    public static final BiMap<String, StructureGenerator<?>> a = HashBiMap.create();
+    private static final Map<StructureGenerator<?>, WorldGenStage.Decoration> u = Maps.newHashMap();
+    private static final Logger LOGGER = LogManager.getLogger();
+    public static final StructureGenerator<WorldGenFeatureVillageConfiguration> PILLAGER_OUTPOST = a("Pillager_Outpost", new WorldGenFeaturePillagerOutpost(WorldGenFeatureVillageConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenMineshaftConfiguration> MINESHAFT = a("Mineshaft", new WorldGenMineshaft(WorldGenMineshaftConfiguration.a), WorldGenStage.Decoration.UNDERGROUND_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> MANSION = a("Mansion", new WorldGenWoodlandMansion(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> JUNGLE_PYRAMID = a("Jungle_Pyramid", new WorldGenFeatureJunglePyramid(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> DESERT_PYRAMID = a("Desert_Pyramid", new WorldGenFeatureDesertPyramid(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> IGLOO = a("Igloo", new WorldGenFeatureIgloo(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureRuinedPortalConfiguration> RUINED_PORTAL = a("Ruined_Portal", new WorldGenFeatureRuinedPortal(WorldGenFeatureRuinedPortalConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureShipwreckConfiguration> SHIPWRECK = a("Shipwreck", new WorldGenFeatureShipwreck(WorldGenFeatureShipwreckConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final WorldGenFeatureSwampHut SWAMP_HUT = (WorldGenFeatureSwampHut) a("Swamp_Hut", new WorldGenFeatureSwampHut(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> STRONGHOLD = a("Stronghold", new WorldGenStronghold(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.STRONGHOLDS);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> MONUMENT = a("Monument", new WorldGenMonument(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureOceanRuinConfiguration> OCEAN_RUIN = a("Ocean_Ruin", new WorldGenFeatureOceanRuin(WorldGenFeatureOceanRuinConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> FORTRESS = a("Fortress", new WorldGenNether(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.UNDERGROUND_DECORATION);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> ENDCITY = a("EndCity", new WorldGenEndCity(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureConfigurationChance> BURIED_TREASURE = a("Buried_Treasure", new WorldGenBuriedTreasure(WorldGenFeatureConfigurationChance.b), WorldGenStage.Decoration.UNDERGROUND_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureVillageConfiguration> VILLAGE = a("Village", new WorldGenVillage(WorldGenFeatureVillageConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final StructureGenerator<WorldGenFeatureEmptyConfiguration> NETHER_FOSSIL = a("Nether_Fossil", new WorldGenFeatureNetherFossil(WorldGenFeatureEmptyConfiguration.a), WorldGenStage.Decoration.UNDERGROUND_DECORATION);
+    public static final StructureGenerator<WorldGenFeatureVillageConfiguration> BASTION_REMNANT = a("Bastion_Remnant", new WorldGenFeatureBastionRemnant(WorldGenFeatureVillageConfiguration.a), WorldGenStage.Decoration.SURFACE_STRUCTURES);
+    public static final List<StructureGenerator<?>> t = ImmutableList.of(StructureGenerator.PILLAGER_OUTPOST, StructureGenerator.VILLAGE, StructureGenerator.NETHER_FOSSIL);
+    private static final MinecraftKey w = new MinecraftKey("jigsaw");
+    private static final Map<MinecraftKey, MinecraftKey> x = ImmutableMap.builder().put(new MinecraftKey("nvi"), StructureGenerator.w).put(new MinecraftKey("pcp"), StructureGenerator.w).put(new MinecraftKey("bastionremnant"), StructureGenerator.w).put(new MinecraftKey("runtime"), StructureGenerator.w).build();
+    private final Codec<StructureFeature<C, StructureGenerator<C>>> y;
+
+    private static <F extends StructureGenerator<?>> F a(String s, F f0, WorldGenStage.Decoration worldgenstage_decoration) {
+        StructureGenerator.a.put(s.toLowerCase(Locale.ROOT), f0);
+        StructureGenerator.u.put(f0, worldgenstage_decoration);
+        return (StructureGenerator) IRegistry.a(IRegistry.STRUCTURE_FEATURE, s.toLowerCase(Locale.ROOT), (Object) f0);
+    }
+
+    public StructureGenerator(Codec<C> codec) {
+        this.y = codec.fieldOf("config").xmap((worldgenfeatureconfiguration) -> {
+            return new StructureFeature<>(this, worldgenfeatureconfiguration);
+        }, (structurefeature) -> {
+            return structurefeature.e;
+        }).codec();
+    }
+
+    public WorldGenStage.Decoration f() {
+        return (WorldGenStage.Decoration) StructureGenerator.u.get(this);
+    }
+
+    public static void g() {}
+
+    @Nullable
+    public static StructureStart<?> a(DefinedStructureManager definedstructuremanager, NBTTagCompound nbttagcompound, long i) {
+        String s = nbttagcompound.getString("id");
+
+        if ("INVALID".equals(s)) {
+            return StructureStart.a;
+        } else {
+            StructureGenerator<?> structuregenerator = (StructureGenerator) IRegistry.STRUCTURE_FEATURE.get(new MinecraftKey(s.toLowerCase(Locale.ROOT)));
+
+            if (structuregenerator == null) {
+                StructureGenerator.LOGGER.error("Unknown feature id: {}", s);
+                return null;
+            } else {
+                int j = nbttagcompound.getInt("ChunkX");
+                int k = nbttagcompound.getInt("ChunkZ");
+                int l = nbttagcompound.getInt("references");
+                StructureBoundingBox structureboundingbox = nbttagcompound.hasKey("BB") ? new StructureBoundingBox(nbttagcompound.getIntArray("BB")) : StructureBoundingBox.a();
+                NBTTagList nbttaglist = nbttagcompound.getList("Children", 10);
+
+                try {
+                    StructureStart<?> structurestart = structuregenerator.a(j, k, structureboundingbox, l, i);
+
+                    for (int i1 = 0; i1 < nbttaglist.size(); ++i1) {
+                        NBTTagCompound nbttagcompound1 = nbttaglist.getCompound(i1);
+                        String s1 = nbttagcompound1.getString("id").toLowerCase(Locale.ROOT);
+                        MinecraftKey minecraftkey = new MinecraftKey(s1);
+                        MinecraftKey minecraftkey1 = (MinecraftKey) StructureGenerator.x.getOrDefault(minecraftkey, minecraftkey);
+                        WorldGenFeatureStructurePieceType worldgenfeaturestructurepiecetype = (WorldGenFeatureStructurePieceType) IRegistry.STRUCTURE_PIECE.get(minecraftkey1);
+
+                        if (worldgenfeaturestructurepiecetype == null) {
+                            StructureGenerator.LOGGER.error("Unknown structure piece id: {}", minecraftkey1);
+                        } else {
+                            try {
+                                StructurePiece structurepiece = worldgenfeaturestructurepiecetype.load(definedstructuremanager, nbttagcompound1);
+
+                                structurestart.d().add(structurepiece);
+                            } catch (Exception exception) {
+                                StructureGenerator.LOGGER.error("Exception loading structure piece with id {}", minecraftkey1, exception);
+                            }
+                        }
+                    }
+
+                    return structurestart;
+                } catch (Exception exception1) {
+                    StructureGenerator.LOGGER.error("Failed Start with id {}", s, exception1);
+                    return null;
+                }
+            }
+        }
+    }
+
+    public Codec<StructureFeature<C, StructureGenerator<C>>> h() {
+        return this.y;
+    }
+
+    public StructureFeature<C, ? extends StructureGenerator<C>> a(C c0) {
+        return new StructureFeature<>(this, c0);
+    }
+
+    @Nullable
+    public BlockPosition getNearestGeneratedFeature(IWorldReader iworldreader, StructureManager structuremanager, BlockPosition blockposition, int i, boolean flag, long j, StructureSettingsFeature structuresettingsfeature) {
+        int k = structuresettingsfeature.a();
+        int l = blockposition.getX() >> 4;
+        int i1 = blockposition.getZ() >> 4;
+        int j1 = 0;
+        SeededRandom seededrandom = new SeededRandom();
+
+        while (j1 <= i) {
+            int k1 = -j1;
+
+            while (true) {
+                if (k1 <= j1) {
+                    boolean flag1 = k1 == -j1 || k1 == j1;
+
+                    for (int l1 = -j1; l1 <= j1; ++l1) {
+                        boolean flag2 = l1 == -j1 || l1 == j1;
+
+                        if (flag1 || flag2) {
+                            int i2 = l + k * k1;
+                            int j2 = i1 + k * l1;
+                            ChunkCoordIntPair chunkcoordintpair = this.a(structuresettingsfeature, j, seededrandom, i2, j2);
+                            IChunkAccess ichunkaccess = iworldreader.getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z, ChunkStatus.STRUCTURE_STARTS);
+                            StructureStart<?> structurestart = structuremanager.a(SectionPosition.a(ichunkaccess.getPos(), 0), this, ichunkaccess);
+
+                            if (structurestart != null && structurestart.e()) {
+                                if (flag && structurestart.h()) {
+                                    structurestart.i();
+                                    return structurestart.a();
+                                }
+
+                                if (!flag) {
+                                    return structurestart.a();
+                                }
+                            }
+
+                            if (j1 == 0) {
+                                break;
+                            }
+                        }
+                    }
+
+                    if (j1 != 0) {
+                        ++k1;
+                        continue;
+                    }
+                }
+
+                ++j1;
+                break;
+            }
+        }
+
+        return null;
+    }
+
+    protected boolean b() {
+        return true;
+    }
+
+    public final ChunkCoordIntPair a(StructureSettingsFeature structuresettingsfeature, long i, SeededRandom seededrandom, int j, int k) {
+        int l = structuresettingsfeature.a();
+        int i1 = structuresettingsfeature.b();
+        int j1 = Math.floorDiv(j, l);
+        int k1 = Math.floorDiv(k, l);
+
+        seededrandom.a(i, j1, k1, structuresettingsfeature.c());
+        int l1;
+        int i2;
+
+        if (this.b()) {
+            l1 = seededrandom.nextInt(l - i1);
+            i2 = seededrandom.nextInt(l - i1);
+        } else {
+            l1 = (seededrandom.nextInt(l - i1) + seededrandom.nextInt(l - i1)) / 2;
+            i2 = (seededrandom.nextInt(l - i1) + seededrandom.nextInt(l - i1)) / 2;
+        }
+
+        return new ChunkCoordIntPair(j1 * l + l1, k1 * l + i2);
+    }
+
+    protected boolean a(ChunkGenerator chunkgenerator, WorldChunkManager worldchunkmanager, long i, SeededRandom seededrandom, int j, int k, BiomeBase biomebase, ChunkCoordIntPair chunkcoordintpair, C c0) {
+        return true;
+    }
+
+    private StructureStart<C> a(int i, int j, StructureBoundingBox structureboundingbox, int k, long l) {
+        return this.a().create(this, i, j, structureboundingbox, k, l);
+    }
+
+    public StructureStart<?> a(IRegistryCustom iregistrycustom, ChunkGenerator chunkgenerator, WorldChunkManager worldchunkmanager, DefinedStructureManager definedstructuremanager, long i, ChunkCoordIntPair chunkcoordintpair, BiomeBase biomebase, int j, SeededRandom seededrandom, StructureSettingsFeature structuresettingsfeature, C c0) {
+        ChunkCoordIntPair chunkcoordintpair1 = this.a(structuresettingsfeature, i, seededrandom, chunkcoordintpair.x, chunkcoordintpair.z);
+
+        if (chunkcoordintpair.x == chunkcoordintpair1.x && chunkcoordintpair.z == chunkcoordintpair1.z && this.a(chunkgenerator, worldchunkmanager, i, seededrandom, chunkcoordintpair.x, chunkcoordintpair.z, biomebase, chunkcoordintpair1, c0)) {
+            StructureStart<C> structurestart = this.a(chunkcoordintpair.x, chunkcoordintpair.z, StructureBoundingBox.a(), j, i);
+
+            structurestart.a(iregistrycustom, chunkgenerator, definedstructuremanager, chunkcoordintpair.x, chunkcoordintpair.z, biomebase, c0);
+            if (structurestart.e()) {
+                return structurestart;
+            }
+        }
+
+        return StructureStart.a;
+    }
+
+    public abstract StructureGenerator.a<C> a();
+
+    public String i() {
+        return (String) StructureGenerator.a.inverse().get(this);
+    }
+
+    public List<BiomeSettingsMobs.c> c() {
+        return ImmutableList.of();
+    }
+
+    public List<BiomeSettingsMobs.c> j() {
+        return ImmutableList.of();
+    }
+
+    public interface a<C extends WorldGenFeatureConfiguration> {
+
+        StructureStart<C> create(StructureGenerator<C> structuregenerator, int i, int j, StructureBoundingBox structureboundingbox, int k, long l);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/WorldGenEndTrophy.java b/src/main/java/net/minecraft/world/level/levelgen/feature/WorldGenEndTrophy.java
new file mode 100644
index 0000000000000000000000000000000000000000..18395a3b4a7df1c99e952b9c8e738f165648eba5
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/WorldGenEndTrophy.java
@@ -0,0 +1,66 @@
+package net.minecraft.world.level.levelgen.feature;
+
+import java.util.Iterator;
+import java.util.Random;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.world.level.GeneratorAccessSeed;
+import net.minecraft.world.level.block.BlockTorchWall;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.feature.configurations.WorldGenFeatureEmptyConfiguration;
+
+public class WorldGenEndTrophy extends WorldGenerator<WorldGenFeatureEmptyConfiguration> {
+
+    public static final BlockPosition a = BlockPosition.ZERO;
+    private final boolean ab;
+
+    public WorldGenEndTrophy(boolean flag) {
+        super(WorldGenFeatureEmptyConfiguration.a);
+        this.ab = flag;
+    }
+
+    public boolean a(GeneratorAccessSeed generatoraccessseed, ChunkGenerator chunkgenerator, Random random, BlockPosition blockposition, WorldGenFeatureEmptyConfiguration worldgenfeatureemptyconfiguration) {
+        Iterator iterator = BlockPosition.a(new BlockPosition(blockposition.getX() - 4, blockposition.getY() - 1, blockposition.getZ() - 4), new BlockPosition(blockposition.getX() + 4, blockposition.getY() + 32, blockposition.getZ() + 4)).iterator();
+
+        while (iterator.hasNext()) {
+            BlockPosition blockposition1 = (BlockPosition) iterator.next();
+            boolean flag = blockposition1.a((BaseBlockPosition) blockposition, 2.5D);
+
+            if (flag || blockposition1.a((BaseBlockPosition) blockposition, 3.5D)) {
+                if (blockposition1.getY() < blockposition.getY()) {
+                    if (flag) {
+                        this.a(generatoraccessseed, blockposition1, Blocks.BEDROCK.getBlockData());
+                    } else if (blockposition1.getY() < blockposition.getY()) {
+                        this.a(generatoraccessseed, blockposition1, Blocks.END_STONE.getBlockData());
+                    }
+                } else if (blockposition1.getY() > blockposition.getY()) {
+                    this.a(generatoraccessseed, blockposition1, Blocks.AIR.getBlockData());
+                } else if (!flag) {
+                    this.a(generatoraccessseed, blockposition1, Blocks.BEDROCK.getBlockData());
+                } else if (this.ab) {
+                    this.a(generatoraccessseed, new BlockPosition(blockposition1), Blocks.END_PORTAL.getBlockData());
+                } else {
+                    this.a(generatoraccessseed, new BlockPosition(blockposition1), Blocks.AIR.getBlockData());
+                }
+            }
+        }
+
+        for (int i = 0; i < 4; ++i) {
+            this.a(generatoraccessseed, blockposition.up(i), Blocks.BEDROCK.getBlockData());
+        }
+
+        BlockPosition blockposition2 = blockposition.up(2);
+        Iterator iterator1 = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+        while (iterator1.hasNext()) {
+            EnumDirection enumdirection = (EnumDirection) iterator1.next();
+
+            this.a(generatoraccessseed, blockposition2.shift(enumdirection), (IBlockData) Blocks.WALL_TORCH.getBlockData().set(BlockTorchWall.a, enumdirection));
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/StructureBoundingBox.java b/src/main/java/net/minecraft/world/level/levelgen/structure/StructureBoundingBox.java
new file mode 100644
index 0000000000000000000000000000000000000000..b5d6c8163c686c31375fb645d7721af06c01df40
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/StructureBoundingBox.java
@@ -0,0 +1,160 @@
+package net.minecraft.world.level.levelgen.structure;
+
+import com.google.common.base.MoreObjects;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.nbt.NBTTagIntArray;
+
+public class StructureBoundingBox {
+
+    public int a;
+    public int b;
+    public int c;
+    public int d;
+    public int e;
+    public int f;
+
+    public StructureBoundingBox() {}
+
+    public StructureBoundingBox(int[] aint) {
+        if (aint.length == 6) {
+            this.a = aint[0];
+            this.b = aint[1];
+            this.c = aint[2];
+            this.d = aint[3];
+            this.e = aint[4];
+            this.f = aint[5];
+        }
+
+    }
+
+    public static StructureBoundingBox a() {
+        return new StructureBoundingBox(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);
+    }
+
+    public static StructureBoundingBox b() {
+        return new StructureBoundingBox(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);
+    }
+
+    public static StructureBoundingBox a(int i, int j, int k, int l, int i1, int j1, int k1, int l1, int i2, EnumDirection enumdirection) {
+        switch (enumdirection) {
+            case NORTH:
+                return new StructureBoundingBox(i + l, j + i1, k - i2 + 1 + j1, i + k1 - 1 + l, j + l1 - 1 + i1, k + j1);
+            case SOUTH:
+                return new StructureBoundingBox(i + l, j + i1, k + j1, i + k1 - 1 + l, j + l1 - 1 + i1, k + i2 - 1 + j1);
+            case WEST:
+                return new StructureBoundingBox(i - i2 + 1 + j1, j + i1, k + l, i + j1, j + l1 - 1 + i1, k + k1 - 1 + l);
+            case EAST:
+                return new StructureBoundingBox(i + j1, j + i1, k + l, i + i2 - 1 + j1, j + l1 - 1 + i1, k + k1 - 1 + l);
+            default:
+                return new StructureBoundingBox(i + l, j + i1, k + j1, i + k1 - 1 + l, j + l1 - 1 + i1, k + i2 - 1 + j1);
+        }
+    }
+
+    public static StructureBoundingBox a(int i, int j, int k, int l, int i1, int j1) {
+        return new StructureBoundingBox(Math.min(i, l), Math.min(j, i1), Math.min(k, j1), Math.max(i, l), Math.max(j, i1), Math.max(k, j1));
+    }
+
+    public StructureBoundingBox(StructureBoundingBox structureboundingbox) {
+        this.a = structureboundingbox.a;
+        this.b = structureboundingbox.b;
+        this.c = structureboundingbox.c;
+        this.d = structureboundingbox.d;
+        this.e = structureboundingbox.e;
+        this.f = structureboundingbox.f;
+    }
+
+    public StructureBoundingBox(int i, int j, int k, int l, int i1, int j1) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.d = l;
+        this.e = i1;
+        this.f = j1;
+    }
+
+    public StructureBoundingBox(BaseBlockPosition baseblockposition, BaseBlockPosition baseblockposition1) {
+        this.a = Math.min(baseblockposition.getX(), baseblockposition1.getX());
+        this.b = Math.min(baseblockposition.getY(), baseblockposition1.getY());
+        this.c = Math.min(baseblockposition.getZ(), baseblockposition1.getZ());
+        this.d = Math.max(baseblockposition.getX(), baseblockposition1.getX());
+        this.e = Math.max(baseblockposition.getY(), baseblockposition1.getY());
+        this.f = Math.max(baseblockposition.getZ(), baseblockposition1.getZ());
+    }
+
+    public StructureBoundingBox(int i, int j, int k, int l) {
+        this.a = i;
+        this.c = j;
+        this.d = k;
+        this.f = l;
+        this.b = 1;
+        this.e = 512;
+    }
+
+    public boolean b(StructureBoundingBox structureboundingbox) {
+        return this.d >= structureboundingbox.a && this.a <= structureboundingbox.d && this.f >= structureboundingbox.c && this.c <= structureboundingbox.f && this.e >= structureboundingbox.b && this.b <= structureboundingbox.e;
+    }
+
+    public boolean a(int i, int j, int k, int l) {
+        return this.d >= i && this.a <= k && this.f >= j && this.c <= l;
+    }
+
+    public void c(StructureBoundingBox structureboundingbox) {
+        this.a = Math.min(this.a, structureboundingbox.a);
+        this.b = Math.min(this.b, structureboundingbox.b);
+        this.c = Math.min(this.c, structureboundingbox.c);
+        this.d = Math.max(this.d, structureboundingbox.d);
+        this.e = Math.max(this.e, structureboundingbox.e);
+        this.f = Math.max(this.f, structureboundingbox.f);
+    }
+
+    public void a(int i, int j, int k) {
+        this.a += i;
+        this.b += j;
+        this.c += k;
+        this.d += i;
+        this.e += j;
+        this.f += k;
+    }
+
+    public StructureBoundingBox b(int i, int j, int k) {
+        return new StructureBoundingBox(this.a + i, this.b + j, this.c + k, this.d + i, this.e + j, this.f + k);
+    }
+
+    public void a(BaseBlockPosition baseblockposition) {
+        this.a(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public boolean b(BaseBlockPosition baseblockposition) {
+        return baseblockposition.getX() >= this.a && baseblockposition.getX() <= this.d && baseblockposition.getZ() >= this.c && baseblockposition.getZ() <= this.f && baseblockposition.getY() >= this.b && baseblockposition.getY() <= this.e;
+    }
+
+    public BaseBlockPosition c() {
+        return new BaseBlockPosition(this.d - this.a, this.e - this.b, this.f - this.c);
+    }
+
+    public int d() {
+        return this.d - this.a + 1;
+    }
+
+    public int e() {
+        return this.e - this.b + 1;
+    }
+
+    public int f() {
+        return this.f - this.c + 1;
+    }
+
+    public BaseBlockPosition g() {
+        return new BlockPosition(this.a + (this.d - this.a + 1) / 2, this.b + (this.e - this.b + 1) / 2, this.c + (this.f - this.c + 1) / 2);
+    }
+
+    public String toString() {
+        return MoreObjects.toStringHelper(this).add("x0", this.a).add("y0", this.b).add("z0", this.c).add("x1", this.d).add("y1", this.e).add("z1", this.f).toString();
+    }
+
+    public NBTTagIntArray h() {
+        return new NBTTagIntArray(new int[]{this.a, this.b, this.c, this.d, this.e, this.f});
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNether.java b/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNether.java
new file mode 100644
index 0000000000000000000000000000000000000000..9efe3a1dc5da760f0d8b0b39a10e642a53321aa5
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNether.java
@@ -0,0 +1,93 @@
+package net.minecraft.world.level.levelgen.surfacebuilders;
+
+import com.mojang.serialization.Codec;
+import java.util.Random;
+import java.util.stream.IntStream;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.levelgen.SeededRandom;
+import net.minecraft.world.level.levelgen.synth.NoiseGeneratorOctaves;
+
+public class WorldGenSurfaceNether extends WorldGenSurface<WorldGenSurfaceConfigurationBase> {
+
+    private static final IBlockData c = Blocks.CAVE_AIR.getBlockData();
+    private static final IBlockData d = Blocks.GRAVEL.getBlockData();
+    private static final IBlockData e = Blocks.SOUL_SAND.getBlockData();
+    protected long a;
+    protected NoiseGeneratorOctaves b;
+
+    public WorldGenSurfaceNether(Codec<WorldGenSurfaceConfigurationBase> codec) {
+        super(codec);
+    }
+
+    public void a(Random random, IChunkAccess ichunkaccess, BiomeBase biomebase, int i, int j, int k, double d0, IBlockData iblockdata, IBlockData iblockdata1, int l, long i1, WorldGenSurfaceConfigurationBase worldgensurfaceconfigurationbase) {
+        int j1 = l;
+        int k1 = i & 15;
+        int l1 = j & 15;
+        double d1 = 0.03125D;
+        boolean flag = this.b.a((double) i * 0.03125D, (double) j * 0.03125D, 0.0D) * 75.0D + random.nextDouble() > 0.0D;
+        boolean flag1 = this.b.a((double) i * 0.03125D, 109.0D, (double) j * 0.03125D) * 75.0D + random.nextDouble() > 0.0D;
+        int i2 = (int) (d0 / 3.0D + 3.0D + random.nextDouble() * 0.25D);
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        int j2 = -1;
+        IBlockData iblockdata2 = worldgensurfaceconfigurationbase.a();
+        IBlockData iblockdata3 = worldgensurfaceconfigurationbase.b();
+
+        for (int k2 = 127; k2 >= 0; --k2) {
+            blockposition_mutableblockposition.d(k1, k2, l1);
+            IBlockData iblockdata4 = ichunkaccess.getType(blockposition_mutableblockposition);
+
+            if (iblockdata4.isAir()) {
+                j2 = -1;
+            } else if (iblockdata4.a(iblockdata.getBlock())) {
+                if (j2 == -1) {
+                    boolean flag2 = false;
+
+                    if (i2 <= 0) {
+                        flag2 = true;
+                        iblockdata3 = worldgensurfaceconfigurationbase.b();
+                    } else if (k2 >= j1 - 4 && k2 <= j1 + 1) {
+                        iblockdata2 = worldgensurfaceconfigurationbase.a();
+                        iblockdata3 = worldgensurfaceconfigurationbase.b();
+                        if (flag1) {
+                            iblockdata2 = WorldGenSurfaceNether.d;
+                            iblockdata3 = worldgensurfaceconfigurationbase.b();
+                        }
+
+                        if (flag) {
+                            iblockdata2 = WorldGenSurfaceNether.e;
+                            iblockdata3 = WorldGenSurfaceNether.e;
+                        }
+                    }
+
+                    if (k2 < j1 && flag2) {
+                        iblockdata2 = iblockdata1;
+                    }
+
+                    j2 = i2;
+                    if (k2 >= j1 - 1) {
+                        ichunkaccess.setType(blockposition_mutableblockposition, iblockdata2, false);
+                    } else {
+                        ichunkaccess.setType(blockposition_mutableblockposition, iblockdata3, false);
+                    }
+                } else if (j2 > 0) {
+                    --j2;
+                    ichunkaccess.setType(blockposition_mutableblockposition, iblockdata3, false);
+                }
+            }
+        }
+
+    }
+
+    @Override
+    public void a(long i) {
+        if (this.a != i || this.b == null) {
+            this.b = new NoiseGeneratorOctaves(new SeededRandom(i), IntStream.rangeClosed(-3, 0));
+        }
+
+        this.a = i;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNetherAbstract.java b/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNetherAbstract.java
new file mode 100644
index 0000000000000000000000000000000000000000..22926296e66866c7fca13466004c20a16e94dc47
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNetherAbstract.java
@@ -0,0 +1,110 @@
+package net.minecraft.world.level.levelgen.surfacebuilders;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableMap.Builder;
+import com.google.common.collect.UnmodifiableIterator;
+import com.mojang.serialization.Codec;
+import java.util.Comparator;
+import java.util.Map.Entry;
+import java.util.Random;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.levelgen.SeededRandom;
+import net.minecraft.world.level.levelgen.synth.NoiseGeneratorOctaves;
+
+public abstract class WorldGenSurfaceNetherAbstract extends WorldGenSurface<WorldGenSurfaceConfigurationBase> {
+
+    private long a;
+    private ImmutableMap<IBlockData, NoiseGeneratorOctaves> b = ImmutableMap.of();
+    private ImmutableMap<IBlockData, NoiseGeneratorOctaves> c = ImmutableMap.of();
+    private NoiseGeneratorOctaves d;
+
+    public WorldGenSurfaceNetherAbstract(Codec<WorldGenSurfaceConfigurationBase> codec) {
+        super(codec);
+    }
+
+    public void a(Random random, IChunkAccess ichunkaccess, BiomeBase biomebase, int i, int j, int k, double d0, IBlockData iblockdata, IBlockData iblockdata1, int l, long i1, WorldGenSurfaceConfigurationBase worldgensurfaceconfigurationbase) {
+        int j1 = l + 1;
+        int k1 = i & 15;
+        int l1 = j & 15;
+        int i2 = (int) (d0 / 3.0D + 3.0D + random.nextDouble() * 0.25D);
+        int j2 = (int) (d0 / 3.0D + 3.0D + random.nextDouble() * 0.25D);
+        double d1 = 0.03125D;
+        boolean flag = this.d.a((double) i * 0.03125D, 109.0D, (double) j * 0.03125D) * 75.0D + random.nextDouble() > 0.0D;
+        IBlockData iblockdata2 = (IBlockData) ((Entry) this.c.entrySet().stream().max(Comparator.comparing((entry) -> {
+            return ((NoiseGeneratorOctaves) entry.getValue()).a((double) i, (double) l, (double) j);
+        })).get()).getKey();
+        IBlockData iblockdata3 = (IBlockData) ((Entry) this.b.entrySet().stream().max(Comparator.comparing((entry) -> {
+            return ((NoiseGeneratorOctaves) entry.getValue()).a((double) i, (double) l, (double) j);
+        })).get()).getKey();
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        IBlockData iblockdata4 = ichunkaccess.getType(blockposition_mutableblockposition.d(k1, 128, l1));
+
+        for (int k2 = 127; k2 >= 0; --k2) {
+            blockposition_mutableblockposition.d(k1, k2, l1);
+            IBlockData iblockdata5 = ichunkaccess.getType(blockposition_mutableblockposition);
+            int l2;
+
+            if (iblockdata4.a(iblockdata.getBlock()) && (iblockdata5.isAir() || iblockdata5 == iblockdata1)) {
+                for (l2 = 0; l2 < i2; ++l2) {
+                    blockposition_mutableblockposition.c(EnumDirection.UP);
+                    if (!ichunkaccess.getType(blockposition_mutableblockposition).a(iblockdata.getBlock())) {
+                        break;
+                    }
+
+                    ichunkaccess.setType(blockposition_mutableblockposition, iblockdata2, false);
+                }
+
+                blockposition_mutableblockposition.d(k1, k2, l1);
+            }
+
+            if ((iblockdata4.isAir() || iblockdata4 == iblockdata1) && iblockdata5.a(iblockdata.getBlock())) {
+                for (l2 = 0; l2 < j2 && ichunkaccess.getType(blockposition_mutableblockposition).a(iblockdata.getBlock()); ++l2) {
+                    if (flag && k2 >= j1 - 4 && k2 <= j1 + 1) {
+                        ichunkaccess.setType(blockposition_mutableblockposition, this.c(), false);
+                    } else {
+                        ichunkaccess.setType(blockposition_mutableblockposition, iblockdata3, false);
+                    }
+
+                    blockposition_mutableblockposition.c(EnumDirection.DOWN);
+                }
+            }
+
+            iblockdata4 = iblockdata5;
+        }
+
+    }
+
+    @Override
+    public void a(long i) {
+        if (this.a != i || this.d == null || this.b.isEmpty() || this.c.isEmpty()) {
+            this.b = a(this.a(), i);
+            this.c = a(this.b(), i + (long) this.b.size());
+            this.d = new NoiseGeneratorOctaves(new SeededRandom(i + (long) this.b.size() + (long) this.c.size()), ImmutableList.of(0));
+        }
+
+        this.a = i;
+    }
+
+    private static ImmutableMap<IBlockData, NoiseGeneratorOctaves> a(ImmutableList<IBlockData> immutablelist, long i) {
+        Builder<IBlockData, NoiseGeneratorOctaves> builder = new Builder();
+
+        for (UnmodifiableIterator unmodifiableiterator = immutablelist.iterator(); unmodifiableiterator.hasNext(); ++i) {
+            IBlockData iblockdata = (IBlockData) unmodifiableiterator.next();
+
+            builder.put(iblockdata, new NoiseGeneratorOctaves(new SeededRandom(i), ImmutableList.of(-4)));
+        }
+
+        return builder.build();
+    }
+
+    protected abstract ImmutableList<IBlockData> a();
+
+    protected abstract ImmutableList<IBlockData> b();
+
+    protected abstract IBlockData c();
+}
diff --git a/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNetherForest.java b/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNetherForest.java
new file mode 100644
index 0000000000000000000000000000000000000000..3bd78b0fc75a536e4e37f5ac67843ff778cd1b5f
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/surfacebuilders/WorldGenSurfaceNetherForest.java
@@ -0,0 +1,86 @@
+package net.minecraft.world.level.levelgen.surfacebuilders;
+
+import com.google.common.collect.ImmutableList;
+import com.mojang.serialization.Codec;
+import java.util.Random;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.world.level.biome.BiomeBase;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.levelgen.SeededRandom;
+import net.minecraft.world.level.levelgen.synth.NoiseGeneratorOctaves;
+
+public class WorldGenSurfaceNetherForest extends WorldGenSurface<WorldGenSurfaceConfigurationBase> {
+
+    private static final IBlockData b = Blocks.CAVE_AIR.getBlockData();
+    protected long a;
+    private NoiseGeneratorOctaves c;
+
+    public WorldGenSurfaceNetherForest(Codec<WorldGenSurfaceConfigurationBase> codec) {
+        super(codec);
+    }
+
+    public void a(Random random, IChunkAccess ichunkaccess, BiomeBase biomebase, int i, int j, int k, double d0, IBlockData iblockdata, IBlockData iblockdata1, int l, long i1, WorldGenSurfaceConfigurationBase worldgensurfaceconfigurationbase) {
+        int j1 = l;
+        int k1 = i & 15;
+        int l1 = j & 15;
+        double d1 = this.c.a((double) i * 0.1D, (double) l, (double) j * 0.1D);
+        boolean flag = d1 > 0.15D + random.nextDouble() * 0.35D;
+        double d2 = this.c.a((double) i * 0.1D, 109.0D, (double) j * 0.1D);
+        boolean flag1 = d2 > 0.25D + random.nextDouble() * 0.9D;
+        int i2 = (int) (d0 / 3.0D + 3.0D + random.nextDouble() * 0.25D);
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        int j2 = -1;
+        IBlockData iblockdata2 = worldgensurfaceconfigurationbase.b();
+
+        for (int k2 = 127; k2 >= 0; --k2) {
+            blockposition_mutableblockposition.d(k1, k2, l1);
+            IBlockData iblockdata3 = worldgensurfaceconfigurationbase.a();
+            IBlockData iblockdata4 = ichunkaccess.getType(blockposition_mutableblockposition);
+
+            if (iblockdata4.isAir()) {
+                j2 = -1;
+            } else if (iblockdata4.a(iblockdata.getBlock())) {
+                if (j2 == -1) {
+                    boolean flag2 = false;
+
+                    if (i2 <= 0) {
+                        flag2 = true;
+                        iblockdata2 = worldgensurfaceconfigurationbase.b();
+                    }
+
+                    if (flag) {
+                        iblockdata3 = worldgensurfaceconfigurationbase.b();
+                    } else if (flag1) {
+                        iblockdata3 = worldgensurfaceconfigurationbase.c();
+                    }
+
+                    if (k2 < j1 && flag2) {
+                        iblockdata3 = iblockdata1;
+                    }
+
+                    j2 = i2;
+                    if (k2 >= j1 - 1) {
+                        ichunkaccess.setType(blockposition_mutableblockposition, iblockdata3, false);
+                    } else {
+                        ichunkaccess.setType(blockposition_mutableblockposition, iblockdata2, false);
+                    }
+                } else if (j2 > 0) {
+                    --j2;
+                    ichunkaccess.setType(blockposition_mutableblockposition, iblockdata2, false);
+                }
+            }
+        }
+
+    }
+
+    @Override
+    public void a(long i) {
+        if (this.a != i || this.c == null) {
+            this.c = new NoiseGeneratorOctaves(new SeededRandom(i), ImmutableList.of(0));
+        }
+
+        this.a = i;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/lighting/LightEngineBlock.java b/src/main/java/net/minecraft/world/level/lighting/LightEngineBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a0a5a70c795ba33780c8db774eaf9769a85daa7
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/lighting/LightEngineBlock.java
@@ -0,0 +1,141 @@
+package net.minecraft.world.level.lighting;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.ILightAccess;
+import net.minecraft.world.level.chunk.NibbleArray;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+import org.apache.commons.lang3.mutable.MutableInt;
+
+public final class LightEngineBlock extends LightEngineLayer<LightEngineStorageBlock.a, LightEngineStorageBlock> {
+
+    private static final EnumDirection[] e = EnumDirection.values();
+    private final BlockPosition.MutableBlockPosition f = new BlockPosition.MutableBlockPosition();
+
+    public LightEngineBlock(ILightAccess ilightaccess) {
+        super(ilightaccess, EnumSkyBlock.BLOCK, new LightEngineStorageBlock(ilightaccess));
+    }
+
+    private int d(long i) {
+        int j = BlockPosition.b(i);
+        int k = BlockPosition.c(i);
+        int l = BlockPosition.d(i);
+        IBlockAccess iblockaccess = this.a.c(j >> 4, l >> 4);
+
+        return iblockaccess != null ? iblockaccess.g(this.f.d(j, k, l)) : 0;
+    }
+
+    @Override
+    protected int b(long i, long j, int k) {
+        if (j == Long.MAX_VALUE) {
+            return 15;
+        } else if (i == Long.MAX_VALUE) {
+            return k + 15 - this.d(j);
+        } else if (k >= 15) {
+            return k;
+        } else {
+            int l = Integer.signum(BlockPosition.b(j) - BlockPosition.b(i));
+            int i1 = Integer.signum(BlockPosition.c(j) - BlockPosition.c(i));
+            int j1 = Integer.signum(BlockPosition.d(j) - BlockPosition.d(i));
+            EnumDirection enumdirection = EnumDirection.a(l, i1, j1);
+
+            if (enumdirection == null) {
+                return 15;
+            } else {
+                MutableInt mutableint = new MutableInt();
+                IBlockData iblockdata = this.a(j, mutableint);
+
+                if (mutableint.getValue() >= 15) {
+                    return 15;
+                } else {
+                    IBlockData iblockdata1 = this.a(i, (MutableInt) null);
+                    VoxelShape voxelshape = this.a(iblockdata1, i, enumdirection);
+                    VoxelShape voxelshape1 = this.a(iblockdata, j, enumdirection.opposite());
+
+                    return VoxelShapes.b(voxelshape, voxelshape1) ? 15 : k + Math.max(1, mutableint.getValue());
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void a(long i, int j, boolean flag) {
+        long k = SectionPosition.e(i);
+        EnumDirection[] aenumdirection = LightEngineBlock.e;
+        int l = aenumdirection.length;
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            EnumDirection enumdirection = aenumdirection[i1];
+            long j1 = BlockPosition.a(i, enumdirection);
+            long k1 = SectionPosition.e(j1);
+
+            if (k == k1 || ((LightEngineStorageBlock) this.c).g(k1)) {
+                this.b(i, j1, j, flag);
+            }
+        }
+
+    }
+
+    @Override
+    protected int a(long i, long j, int k) {
+        int l = k;
+
+        if (Long.MAX_VALUE != j) {
+            int i1 = this.b(Long.MAX_VALUE, i, 0);
+
+            if (k > i1) {
+                l = i1;
+            }
+
+            if (l == 0) {
+                return l;
+            }
+        }
+
+        long j1 = SectionPosition.e(i);
+        NibbleArray nibblearray = ((LightEngineStorageBlock) this.c).a(j1, true);
+        EnumDirection[] aenumdirection = LightEngineBlock.e;
+        int k1 = aenumdirection.length;
+
+        for (int l1 = 0; l1 < k1; ++l1) {
+            EnumDirection enumdirection = aenumdirection[l1];
+            long i2 = BlockPosition.a(i, enumdirection);
+
+            if (i2 != j) {
+                long j2 = SectionPosition.e(i2);
+                NibbleArray nibblearray1;
+
+                if (j1 == j2) {
+                    nibblearray1 = nibblearray;
+                } else {
+                    nibblearray1 = ((LightEngineStorageBlock) this.c).a(j2, true);
+                }
+
+                if (nibblearray1 != null) {
+                    int k2 = this.b(i2, i, this.a(nibblearray1, i2));
+
+                    if (l > k2) {
+                        l = k2;
+                    }
+
+                    if (l == 0) {
+                        return l;
+                    }
+                }
+            }
+        }
+
+        return l;
+    }
+
+    @Override
+    public void a(BlockPosition blockposition, int i) {
+        ((LightEngineStorageBlock) this.c).d();
+        this.a(Long.MAX_VALUE, blockposition.asLong(), 15 - i, true);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/lighting/LightEngineLayer.java b/src/main/java/net/minecraft/world/level/lighting/LightEngineLayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..944a8c295ff9df0d96800ddc4f6763598cf61d0d
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/lighting/LightEngineLayer.java
@@ -0,0 +1,231 @@
+package net.minecraft.world.level.lighting;
+
+import java.util.Arrays;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.ILightAccess;
+import net.minecraft.world.level.chunk.NibbleArray;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+import org.apache.commons.lang3.mutable.MutableInt;
+
+public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S extends LightEngineStorage<M>> extends LightEngineGraph implements LightEngineLayerEventListener {
+
+    private static final EnumDirection[] e = EnumDirection.values();
+    protected final ILightAccess a;
+    protected final EnumSkyBlock b;
+    protected final S c;
+    private boolean f;
+    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition();
+    private final long[] g = new long[2];
+    private final IBlockAccess[] h = new IBlockAccess[2];
+
+    public LightEngineLayer(ILightAccess ilightaccess, EnumSkyBlock enumskyblock, S s0) {
+        super(16, 256, 8192);
+        this.a = ilightaccess;
+        this.b = enumskyblock;
+        this.c = s0;
+        this.d();
+    }
+
+    @Override
+    protected void f(long i) {
+        this.c.d();
+        if (this.c.g(SectionPosition.e(i))) {
+            super.f(i);
+        }
+
+    }
+
+    @Nullable
+    private IBlockAccess a(int i, int j) {
+        long k = ChunkCoordIntPair.pair(i, j);
+
+        for (int l = 0; l < 2; ++l) {
+            if (k == this.g[l]) {
+                return this.h[l];
+            }
+        }
+
+        IBlockAccess iblockaccess = this.a.c(i, j);
+
+        for (int i1 = 1; i1 > 0; --i1) {
+            this.g[i1] = this.g[i1 - 1];
+            this.h[i1] = this.h[i1 - 1];
+        }
+
+        this.g[0] = k;
+        this.h[0] = iblockaccess;
+        return iblockaccess;
+    }
+
+    private void d() {
+        Arrays.fill(this.g, ChunkCoordIntPair.a);
+        Arrays.fill(this.h, (Object) null);
+    }
+
+    protected IBlockData a(long i, @Nullable MutableInt mutableint) {
+        if (i == Long.MAX_VALUE) {
+            if (mutableint != null) {
+                mutableint.setValue(0);
+            }
+
+            return Blocks.AIR.getBlockData();
+        } else {
+            int j = SectionPosition.a(BlockPosition.b(i));
+            int k = SectionPosition.a(BlockPosition.d(i));
+            IBlockAccess iblockaccess = this.a(j, k);
+
+            if (iblockaccess == null) {
+                if (mutableint != null) {
+                    mutableint.setValue(16);
+                }
+
+                return Blocks.BEDROCK.getBlockData();
+            } else {
+                this.d.g(i);
+                IBlockData iblockdata = iblockaccess.getType(this.d);
+                boolean flag = iblockdata.l() && iblockdata.e();
+
+                if (mutableint != null) {
+                    mutableint.setValue(iblockdata.b(this.a.getWorld(), (BlockPosition) this.d));
+                }
+
+                return flag ? iblockdata : Blocks.AIR.getBlockData();
+            }
+        }
+    }
+
+    protected VoxelShape a(IBlockData iblockdata, long i, EnumDirection enumdirection) {
+        return iblockdata.l() ? iblockdata.a(this.a.getWorld(), this.d.g(i), enumdirection) : VoxelShapes.a();
+    }
+
+    public static int a(IBlockAccess iblockaccess, IBlockData iblockdata, BlockPosition blockposition, IBlockData iblockdata1, BlockPosition blockposition1, EnumDirection enumdirection, int i) {
+        boolean flag = iblockdata.l() && iblockdata.e();
+        boolean flag1 = iblockdata1.l() && iblockdata1.e();
+
+        if (!flag && !flag1) {
+            return i;
+        } else {
+            VoxelShape voxelshape = flag ? iblockdata.c(iblockaccess, blockposition) : VoxelShapes.a();
+            VoxelShape voxelshape1 = flag1 ? iblockdata1.c(iblockaccess, blockposition1) : VoxelShapes.a();
+
+            return VoxelShapes.b(voxelshape, voxelshape1, enumdirection) ? 16 : i;
+        }
+    }
+
+    @Override
+    protected boolean a(long i) {
+        return i == Long.MAX_VALUE;
+    }
+
+    @Override
+    protected int a(long i, long j, int k) {
+        return 0;
+    }
+
+    @Override
+    protected int c(long i) {
+        return i == Long.MAX_VALUE ? 0 : 15 - this.c.i(i);
+    }
+
+    protected int a(NibbleArray nibblearray, long i) {
+        return 15 - nibblearray.a(SectionPosition.b(BlockPosition.b(i)), SectionPosition.b(BlockPosition.c(i)), SectionPosition.b(BlockPosition.d(i)));
+    }
+
+    @Override
+    protected void a(long i, int j) {
+        this.c.b(i, Math.min(15, 15 - j));
+    }
+
+    @Override
+    protected int b(long i, long j, int k) {
+        return 0;
+    }
+
+    public boolean a() {
+        return this.b() || this.c.b() || this.c.a();
+    }
+
+    public int a(int i, boolean flag, boolean flag1) {
+        if (!this.f) {
+            if (this.c.b()) {
+                i = this.c.b(i);
+                if (i == 0) {
+                    return i;
+                }
+            }
+
+            this.c.a(this, flag, flag1);
+        }
+
+        this.f = true;
+        if (this.b()) {
+            i = this.b(i);
+            this.d();
+            if (i == 0) {
+                return i;
+            }
+        }
+
+        this.f = false;
+        this.c.e();
+        return i;
+    }
+
+    protected void a(long i, @Nullable NibbleArray nibblearray, boolean flag) {
+        this.c.a(i, nibblearray, flag);
+    }
+
+    @Nullable
+    @Override
+    public NibbleArray a(SectionPosition sectionposition) {
+        return this.c.h(sectionposition.s());
+    }
+
+    @Override
+    public int b(BlockPosition blockposition) {
+        return this.c.d(blockposition.asLong());
+    }
+
+    public void a(BlockPosition blockposition) {
+        long i = blockposition.asLong();
+
+        this.f(i);
+        EnumDirection[] aenumdirection = LightEngineLayer.e;
+        int j = aenumdirection.length;
+
+        for (int k = 0; k < j; ++k) {
+            EnumDirection enumdirection = aenumdirection[k];
+
+            this.f(BlockPosition.a(i, enumdirection));
+        }
+
+    }
+
+    public void a(BlockPosition blockposition, int i) {}
+
+    @Override
+    public void a(SectionPosition sectionposition, boolean flag) {
+        this.c.d(sectionposition.s(), flag);
+    }
+
+    public void a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        long i = SectionPosition.f(SectionPosition.b(chunkcoordintpair.x, 0, chunkcoordintpair.z));
+
+        this.c.b(i, flag);
+    }
+
+    public void b(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        long i = SectionPosition.f(SectionPosition.b(chunkcoordintpair.x, 0, chunkcoordintpair.z));
+
+        this.c.c(i, flag);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/lighting/LightEngineSky.java b/src/main/java/net/minecraft/world/level/lighting/LightEngineSky.java
new file mode 100644
index 0000000000000000000000000000000000000000..113c575a16121aa1146f21a6f41ebd9d12a0c924
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/lighting/LightEngineSky.java
@@ -0,0 +1,260 @@
+package net.minecraft.world.level.lighting;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.chunk.ILightAccess;
+import net.minecraft.world.level.chunk.NibbleArray;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShapes;
+import org.apache.commons.lang3.mutable.MutableInt;
+
+public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky.a, LightEngineStorageSky> {
+
+    private static final EnumDirection[] e = EnumDirection.values();
+    private static final EnumDirection[] f = new EnumDirection[]{EnumDirection.NORTH, EnumDirection.SOUTH, EnumDirection.WEST, EnumDirection.EAST};
+
+    public LightEngineSky(ILightAccess ilightaccess) {
+        super(ilightaccess, EnumSkyBlock.SKY, new LightEngineStorageSky(ilightaccess));
+    }
+
+    @Override
+    protected int b(long i, long j, int k) {
+        if (j == Long.MAX_VALUE) {
+            return 15;
+        } else {
+            if (i == Long.MAX_VALUE) {
+                if (!((LightEngineStorageSky) this.c).m(j)) {
+                    return 15;
+                }
+
+                k = 0;
+            }
+
+            if (k >= 15) {
+                return k;
+            } else {
+                MutableInt mutableint = new MutableInt();
+                IBlockData iblockdata = this.a(j, mutableint);
+
+                if (mutableint.getValue() >= 15) {
+                    return 15;
+                } else {
+                    int l = BlockPosition.b(i);
+                    int i1 = BlockPosition.c(i);
+                    int j1 = BlockPosition.d(i);
+                    int k1 = BlockPosition.b(j);
+                    int l1 = BlockPosition.c(j);
+                    int i2 = BlockPosition.d(j);
+                    boolean flag = l == k1 && j1 == i2;
+                    int j2 = Integer.signum(k1 - l);
+                    int k2 = Integer.signum(l1 - i1);
+                    int l2 = Integer.signum(i2 - j1);
+                    EnumDirection enumdirection;
+
+                    if (i == Long.MAX_VALUE) {
+                        enumdirection = EnumDirection.DOWN;
+                    } else {
+                        enumdirection = EnumDirection.a(j2, k2, l2);
+                    }
+
+                    IBlockData iblockdata1 = this.a(i, (MutableInt) null);
+                    VoxelShape voxelshape;
+
+                    if (enumdirection != null) {
+                        voxelshape = this.a(iblockdata1, i, enumdirection);
+                        VoxelShape voxelshape1 = this.a(iblockdata, j, enumdirection.opposite());
+
+                        if (VoxelShapes.b(voxelshape, voxelshape1)) {
+                            return 15;
+                        }
+                    } else {
+                        voxelshape = this.a(iblockdata1, i, EnumDirection.DOWN);
+                        if (VoxelShapes.b(voxelshape, VoxelShapes.a())) {
+                            return 15;
+                        }
+
+                        int i3 = flag ? -1 : 0;
+                        EnumDirection enumdirection1 = EnumDirection.a(j2, i3, l2);
+
+                        if (enumdirection1 == null) {
+                            return 15;
+                        }
+
+                        VoxelShape voxelshape2 = this.a(iblockdata, j, enumdirection1.opposite());
+
+                        if (VoxelShapes.b(VoxelShapes.a(), voxelshape2)) {
+                            return 15;
+                        }
+                    }
+
+                    boolean flag1 = i == Long.MAX_VALUE || flag && i1 > l1;
+
+                    return flag1 && k == 0 && mutableint.getValue() == 0 ? 0 : k + Math.max(1, mutableint.getValue());
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void a(long i, int j, boolean flag) {
+        long k = SectionPosition.e(i);
+        int l = BlockPosition.c(i);
+        int i1 = SectionPosition.b(l);
+        int j1 = SectionPosition.a(l);
+        int k1;
+
+        if (i1 != 0) {
+            k1 = 0;
+        } else {
+            int l1;
+
+            for (l1 = 0; !((LightEngineStorageSky) this.c).g(SectionPosition.a(k, 0, -l1 - 1, 0)) && ((LightEngineStorageSky) this.c).a(j1 - l1 - 1); ++l1) {
+                ;
+            }
+
+            k1 = l1;
+        }
+
+        long i2 = BlockPosition.a(i, 0, -1 - k1 * 16, 0);
+        long j2 = SectionPosition.e(i2);
+
+        if (k == j2 || ((LightEngineStorageSky) this.c).g(j2)) {
+            this.b(i, i2, j, flag);
+        }
+
+        long k2 = BlockPosition.a(i, EnumDirection.UP);
+        long l2 = SectionPosition.e(k2);
+
+        if (k == l2 || ((LightEngineStorageSky) this.c).g(l2)) {
+            this.b(i, k2, j, flag);
+        }
+
+        EnumDirection[] aenumdirection = LightEngineSky.f;
+        int i3 = aenumdirection.length;
+        int j3 = 0;
+
+        while (j3 < i3) {
+            EnumDirection enumdirection = aenumdirection[j3];
+            int k3 = 0;
+
+            while (true) {
+                long l3 = BlockPosition.a(i, enumdirection.getAdjacentX(), -k3, enumdirection.getAdjacentZ());
+                long i4 = SectionPosition.e(l3);
+
+                if (k == i4) {
+                    this.b(i, l3, j, flag);
+                } else {
+                    if (((LightEngineStorageSky) this.c).g(i4)) {
+                        this.b(i, l3, j, flag);
+                    }
+
+                    ++k3;
+                    if (k3 <= k1 * 16) {
+                        continue;
+                    }
+                }
+
+                ++j3;
+                break;
+            }
+        }
+
+    }
+
+    @Override
+    protected int a(long i, long j, int k) {
+        int l = k;
+
+        if (Long.MAX_VALUE != j) {
+            int i1 = this.b(Long.MAX_VALUE, i, 0);
+
+            if (k > i1) {
+                l = i1;
+            }
+
+            if (l == 0) {
+                return l;
+            }
+        }
+
+        long j1 = SectionPosition.e(i);
+        NibbleArray nibblearray = ((LightEngineStorageSky) this.c).a(j1, true);
+        EnumDirection[] aenumdirection = LightEngineSky.e;
+        int k1 = aenumdirection.length;
+
+        for (int l1 = 0; l1 < k1; ++l1) {
+            EnumDirection enumdirection = aenumdirection[l1];
+            long i2 = BlockPosition.a(i, enumdirection);
+            long j2 = SectionPosition.e(i2);
+            NibbleArray nibblearray1;
+
+            if (j1 == j2) {
+                nibblearray1 = nibblearray;
+            } else {
+                nibblearray1 = ((LightEngineStorageSky) this.c).a(j2, true);
+            }
+
+            if (nibblearray1 != null) {
+                if (i2 != j) {
+                    int k2 = this.b(i2, i, this.a(nibblearray1, i2));
+
+                    if (l > k2) {
+                        l = k2;
+                    }
+
+                    if (l == 0) {
+                        return l;
+                    }
+                }
+            } else if (enumdirection != EnumDirection.DOWN) {
+                for (i2 = BlockPosition.f(i2); !((LightEngineStorageSky) this.c).g(j2) && !((LightEngineStorageSky) this.c).n(j2); i2 = BlockPosition.a(i2, 0, 16, 0)) {
+                    j2 = SectionPosition.a(j2, EnumDirection.UP);
+                }
+
+                NibbleArray nibblearray2 = ((LightEngineStorageSky) this.c).a(j2, true);
+
+                if (i2 != j) {
+                    int l2;
+
+                    if (nibblearray2 != null) {
+                        l2 = this.b(i2, i, this.a(nibblearray2, i2));
+                    } else {
+                        l2 = ((LightEngineStorageSky) this.c).o(j2) ? 0 : 15;
+                    }
+
+                    if (l > l2) {
+                        l = l2;
+                    }
+
+                    if (l == 0) {
+                        return l;
+                    }
+                }
+            }
+        }
+
+        return l;
+    }
+
+    @Override
+    protected void f(long i) {
+        ((LightEngineStorageSky) this.c).d();
+        long j = SectionPosition.e(i);
+
+        if (((LightEngineStorageSky) this.c).g(j)) {
+            super.f(i);
+        } else {
+            for (i = BlockPosition.f(i); !((LightEngineStorageSky) this.c).g(j) && !((LightEngineStorageSky) this.c).n(j); i = BlockPosition.a(i, 0, 16, 0)) {
+                j = SectionPosition.a(j, EnumDirection.UP);
+            }
+
+            if (((LightEngineStorageSky) this.c).g(j)) {
+                super.f(i);
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/lighting/LightEngineStorage.java b/src/main/java/net/minecraft/world/level/lighting/LightEngineStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f3d2c090d098834e38e447d93f1ea8184c8fb3e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/lighting/LightEngineStorage.java
@@ -0,0 +1,387 @@
+package net.minecraft.world.level.lighting;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.server.level.LightEngineGraphSection;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.chunk.ILightAccess;
+import net.minecraft.world.level.chunk.NibbleArray;
+
+public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> extends LightEngineGraphSection {
+
+    protected static final NibbleArray a = new NibbleArray();
+    private static final EnumDirection[] k = EnumDirection.values();
+    private final EnumSkyBlock l;
+    private final ILightAccess m;
+    protected final LongSet b = new LongOpenHashSet();
+    protected final LongSet c = new LongOpenHashSet();
+    protected final LongSet d = new LongOpenHashSet();
+    protected volatile M e;
+    protected final M f;
+    protected final LongSet g = new LongOpenHashSet();
+    protected final LongSet h = new LongOpenHashSet();
+    protected final Long2ObjectMap<NibbleArray> i = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap());
+    private final LongSet n = new LongOpenHashSet();
+    private final LongSet o = new LongOpenHashSet();
+    private final LongSet p = new LongOpenHashSet();
+    protected volatile boolean j;
+
+    protected LightEngineStorage(EnumSkyBlock enumskyblock, ILightAccess ilightaccess, M m0) {
+        super(3, 16, 256);
+        this.l = enumskyblock;
+        this.m = ilightaccess;
+        this.f = m0;
+        this.e = m0.b();
+        this.e.d();
+    }
+
+    protected boolean g(long i) {
+        return this.a(i, true) != null;
+    }
+
+    @Nullable
+    protected NibbleArray a(long i, boolean flag) {
+        return this.a(flag ? this.f : this.e, i);
+    }
+
+    @Nullable
+    protected NibbleArray a(M m0, long i) {
+        return m0.c(i);
+    }
+
+    @Nullable
+    public NibbleArray h(long i) {
+        NibbleArray nibblearray = (NibbleArray) this.i.get(i);
+
+        return nibblearray != null ? nibblearray : this.a(i, false);
+    }
+
+    protected abstract int d(long i);
+
+    protected int i(long i) {
+        long j = SectionPosition.e(i);
+        NibbleArray nibblearray = this.a(j, true);
+
+        return nibblearray.a(SectionPosition.b(BlockPosition.b(i)), SectionPosition.b(BlockPosition.c(i)), SectionPosition.b(BlockPosition.d(i)));
+    }
+
+    protected void b(long i, int j) {
+        long k = SectionPosition.e(i);
+
+        if (this.g.add(k)) {
+            this.f.a(k);
+        }
+
+        NibbleArray nibblearray = this.a(k, true);
+
+        nibblearray.a(SectionPosition.b(BlockPosition.b(i)), SectionPosition.b(BlockPosition.c(i)), SectionPosition.b(BlockPosition.d(i)), j);
+
+        for (int l = -1; l <= 1; ++l) {
+            for (int i1 = -1; i1 <= 1; ++i1) {
+                for (int j1 = -1; j1 <= 1; ++j1) {
+                    this.h.add(SectionPosition.e(BlockPosition.a(i, i1, j1, l)));
+                }
+            }
+        }
+
+    }
+
+    @Override
+    protected int c(long i) {
+        return i == Long.MAX_VALUE ? 2 : (this.b.contains(i) ? 0 : (!this.p.contains(i) && this.f.b(i) ? 1 : 2));
+    }
+
+    @Override
+    protected int b(long i) {
+        return this.c.contains(i) ? 2 : (!this.b.contains(i) && !this.d.contains(i) ? 2 : 0);
+    }
+
+    @Override
+    protected void a(long i, int j) {
+        int k = this.c(i);
+
+        if (k != 0 && j == 0) {
+            this.b.add(i);
+            this.d.remove(i);
+        }
+
+        if (k == 0 && j != 0) {
+            this.b.remove(i);
+            this.c.remove(i);
+        }
+
+        if (k >= 2 && j != 2) {
+            if (this.p.contains(i)) {
+                this.p.remove(i);
+            } else {
+                this.f.a(i, this.j(i));
+                this.g.add(i);
+                this.k(i);
+
+                for (int l = -1; l <= 1; ++l) {
+                    for (int i1 = -1; i1 <= 1; ++i1) {
+                        for (int j1 = -1; j1 <= 1; ++j1) {
+                            this.h.add(SectionPosition.e(BlockPosition.a(i, i1, j1, l)));
+                        }
+                    }
+                }
+            }
+        }
+
+        if (k != 2 && j >= 2) {
+            this.p.add(i);
+        }
+
+        this.j = !this.p.isEmpty();
+    }
+
+    protected NibbleArray j(long i) {
+        NibbleArray nibblearray = (NibbleArray) this.i.get(i);
+
+        return nibblearray != null ? nibblearray : new NibbleArray();
+    }
+
+    protected void a(LightEngineLayer<?, ?> lightenginelayer, long i) {
+        if (lightenginelayer.c() < 8192) {
+            lightenginelayer.a((j) -> {
+                return SectionPosition.e(j) == i;
+            });
+        } else {
+            int j = SectionPosition.c(SectionPosition.b(i));
+            int k = SectionPosition.c(SectionPosition.c(i));
+            int l = SectionPosition.c(SectionPosition.d(i));
+
+            for (int i1 = 0; i1 < 16; ++i1) {
+                for (int j1 = 0; j1 < 16; ++j1) {
+                    for (int k1 = 0; k1 < 16; ++k1) {
+                        long l1 = BlockPosition.a(j + i1, k + j1, l + k1);
+
+                        lightenginelayer.e(l1);
+                    }
+                }
+            }
+
+        }
+    }
+
+    protected boolean a() {
+        return this.j;
+    }
+
+    protected void a(LightEngineLayer<M, ?> lightenginelayer, boolean flag, boolean flag1) {
+        if (this.a() || !this.i.isEmpty()) {
+            LongIterator longiterator = this.p.iterator();
+
+            long i;
+            NibbleArray nibblearray;
+
+            while (longiterator.hasNext()) {
+                i = (Long) longiterator.next();
+                this.a(lightenginelayer, i);
+                NibbleArray nibblearray1 = (NibbleArray) this.i.remove(i);
+
+                nibblearray = this.f.d(i);
+                if (this.o.contains(SectionPosition.f(i))) {
+                    if (nibblearray1 != null) {
+                        this.i.put(i, nibblearray1);
+                    } else if (nibblearray != null) {
+                        this.i.put(i, nibblearray);
+                    }
+                }
+            }
+
+            this.f.c();
+            longiterator = this.p.iterator();
+
+            while (longiterator.hasNext()) {
+                i = (Long) longiterator.next();
+                this.l(i);
+            }
+
+            this.p.clear();
+            this.j = false;
+            ObjectIterator objectiterator = this.i.long2ObjectEntrySet().iterator();
+
+            Entry entry;
+            long j;
+
+            while (objectiterator.hasNext()) {
+                entry = (Entry) objectiterator.next();
+                j = entry.getLongKey();
+                if (this.g(j)) {
+                    nibblearray = (NibbleArray) entry.getValue();
+                    if (this.f.c(j) != nibblearray) {
+                        this.a(lightenginelayer, j);
+                        this.f.a(j, nibblearray);
+                        this.g.add(j);
+                    }
+                }
+            }
+
+            this.f.c();
+            if (!flag1) {
+                longiterator = this.i.keySet().iterator();
+
+                while (longiterator.hasNext()) {
+                    i = (Long) longiterator.next();
+                    this.b(lightenginelayer, i);
+                }
+            } else {
+                longiterator = this.n.iterator();
+
+                while (longiterator.hasNext()) {
+                    i = (Long) longiterator.next();
+                    this.b(lightenginelayer, i);
+                }
+            }
+
+            this.n.clear();
+            objectiterator = this.i.long2ObjectEntrySet().iterator();
+
+            while (objectiterator.hasNext()) {
+                entry = (Entry) objectiterator.next();
+                j = entry.getLongKey();
+                if (this.g(j)) {
+                    objectiterator.remove();
+                }
+            }
+
+        }
+    }
+
+    private void b(LightEngineLayer<M, ?> lightenginelayer, long i) {
+        if (this.g(i)) {
+            int j = SectionPosition.c(SectionPosition.b(i));
+            int k = SectionPosition.c(SectionPosition.c(i));
+            int l = SectionPosition.c(SectionPosition.d(i));
+            EnumDirection[] aenumdirection = LightEngineStorage.k;
+            int i1 = aenumdirection.length;
+
+            for (int j1 = 0; j1 < i1; ++j1) {
+                EnumDirection enumdirection = aenumdirection[j1];
+                long k1 = SectionPosition.a(i, enumdirection);
+
+                if (!this.i.containsKey(k1) && this.g(k1)) {
+                    for (int l1 = 0; l1 < 16; ++l1) {
+                        for (int i2 = 0; i2 < 16; ++i2) {
+                            long j2;
+                            long k2;
+
+                            switch (enumdirection) {
+                                case DOWN:
+                                    j2 = BlockPosition.a(j + i2, k, l + l1);
+                                    k2 = BlockPosition.a(j + i2, k - 1, l + l1);
+                                    break;
+                                case UP:
+                                    j2 = BlockPosition.a(j + i2, k + 16 - 1, l + l1);
+                                    k2 = BlockPosition.a(j + i2, k + 16, l + l1);
+                                    break;
+                                case NORTH:
+                                    j2 = BlockPosition.a(j + l1, k + i2, l);
+                                    k2 = BlockPosition.a(j + l1, k + i2, l - 1);
+                                    break;
+                                case SOUTH:
+                                    j2 = BlockPosition.a(j + l1, k + i2, l + 16 - 1);
+                                    k2 = BlockPosition.a(j + l1, k + i2, l + 16);
+                                    break;
+                                case WEST:
+                                    j2 = BlockPosition.a(j, k + l1, l + i2);
+                                    k2 = BlockPosition.a(j - 1, k + l1, l + i2);
+                                    break;
+                                default:
+                                    j2 = BlockPosition.a(j + 16 - 1, k + l1, l + i2);
+                                    k2 = BlockPosition.a(j + 16, k + l1, l + i2);
+                            }
+
+                            lightenginelayer.a(j2, k2, lightenginelayer.b(j2, k2, lightenginelayer.c(j2)), false);
+                            lightenginelayer.a(k2, j2, lightenginelayer.b(k2, j2, lightenginelayer.c(k2)), false);
+                        }
+                    }
+                }
+            }
+
+        }
+    }
+
+    protected void k(long i) {}
+
+    protected void l(long i) {}
+
+    protected void b(long i, boolean flag) {}
+
+    public void c(long i, boolean flag) {
+        if (flag) {
+            this.o.add(i);
+        } else {
+            this.o.remove(i);
+        }
+
+    }
+
+    protected void a(long i, @Nullable NibbleArray nibblearray, boolean flag) {
+        if (nibblearray != null) {
+            this.i.put(i, nibblearray);
+            if (!flag) {
+                this.n.add(i);
+            }
+        } else {
+            this.i.remove(i);
+        }
+
+    }
+
+    protected void d(long i, boolean flag) {
+        boolean flag1 = this.b.contains(i);
+
+        if (!flag1 && !flag) {
+            this.d.add(i);
+            this.a(Long.MAX_VALUE, i, 0, true);
+        }
+
+        if (flag1 && flag) {
+            this.c.add(i);
+            this.a(Long.MAX_VALUE, i, 2, false);
+        }
+
+    }
+
+    protected void d() {
+        if (this.b()) {
+            this.b(Integer.MAX_VALUE);
+        }
+
+    }
+
+    protected void e() {
+        if (!this.g.isEmpty()) {
+            M m0 = this.f.b();
+
+            m0.d();
+            this.e = m0;
+            this.g.clear();
+        }
+
+        if (!this.h.isEmpty()) {
+            LongIterator longiterator = this.h.iterator();
+
+            while (longiterator.hasNext()) {
+                long i = longiterator.nextLong();
+
+                this.m.a(this.l, SectionPosition.a(i));
+            }
+
+            this.h.clear();
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageArray.java b/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageArray.java
new file mode 100644
index 0000000000000000000000000000000000000000..242a2c5dea1241b515b9eee7c334ab3c31ad9d12
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageArray.java
@@ -0,0 +1,80 @@
+package net.minecraft.world.level.lighting;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import javax.annotation.Nullable;
+import net.minecraft.world.level.chunk.NibbleArray;
+
+public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<M>> {
+
+    private final long[] b = new long[2];
+    private final NibbleArray[] c = new NibbleArray[2];
+    private boolean d;
+    protected final Long2ObjectOpenHashMap<NibbleArray> a;
+
+    protected LightEngineStorageArray(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
+        this.a = long2objectopenhashmap;
+        this.c();
+        this.d = true;
+    }
+
+    public abstract M b();
+
+    public void a(long i) {
+        this.a.put(i, ((NibbleArray) this.a.get(i)).b());
+        this.c();
+    }
+
+    public boolean b(long i) {
+        return this.a.containsKey(i);
+    }
+
+    @Nullable
+    public NibbleArray c(long i) {
+        if (this.d) {
+            for (int j = 0; j < 2; ++j) {
+                if (i == this.b[j]) {
+                    return this.c[j];
+                }
+            }
+        }
+
+        NibbleArray nibblearray = (NibbleArray) this.a.get(i);
+
+        if (nibblearray == null) {
+            return null;
+        } else {
+            if (this.d) {
+                for (int k = 1; k > 0; --k) {
+                    this.b[k] = this.b[k - 1];
+                    this.c[k] = this.c[k - 1];
+                }
+
+                this.b[0] = i;
+                this.c[0] = nibblearray;
+            }
+
+            return nibblearray;
+        }
+    }
+
+    @Nullable
+    public NibbleArray d(long i) {
+        return (NibbleArray) this.a.remove(i);
+    }
+
+    public void a(long i, NibbleArray nibblearray) {
+        this.a.put(i, nibblearray);
+    }
+
+    public void c() {
+        for (int i = 0; i < 2; ++i) {
+            this.b[i] = Long.MAX_VALUE;
+            this.c[i] = null;
+        }
+
+    }
+
+    public void d() {
+        this.d = false;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageBlock.java b/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..06c0635cb40114b078dace69bb5f987e24d25b0f
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageBlock.java
@@ -0,0 +1,35 @@
+package net.minecraft.world.level.lighting;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.chunk.ILightAccess;
+import net.minecraft.world.level.chunk.NibbleArray;
+
+public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStorageBlock.a> {
+
+    protected LightEngineStorageBlock(ILightAccess ilightaccess) {
+        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new Long2ObjectOpenHashMap()));
+    }
+
+    @Override
+    protected int d(long i) {
+        long j = SectionPosition.e(i);
+        NibbleArray nibblearray = this.a(j, false);
+
+        return nibblearray == null ? 0 : nibblearray.a(SectionPosition.b(BlockPosition.b(i)), SectionPosition.b(BlockPosition.c(i)), SectionPosition.b(BlockPosition.d(i)));
+    }
+
+    public static final class a extends LightEngineStorageArray<LightEngineStorageBlock.a> {
+
+        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
+            super(long2objectopenhashmap);
+        }
+
+        @Override
+        public LightEngineStorageBlock.a b() {
+            return new LightEngineStorageBlock.a(this.a.clone());
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageSky.java b/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageSky.java
new file mode 100644
index 0000000000000000000000000000000000000000..52564cce4146f49a906729b3ed9488a7a829ea3f
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/lighting/LightEngineStorageSky.java
@@ -0,0 +1,344 @@
+package net.minecraft.world.level.lighting;
+
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import java.util.Arrays;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.SectionPosition;
+import net.minecraft.world.level.EnumSkyBlock;
+import net.minecraft.world.level.chunk.ILightAccess;
+import net.minecraft.world.level.chunk.NibbleArray;
+
+public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorageSky.a> {
+
+    private static final EnumDirection[] k = new EnumDirection[]{EnumDirection.NORTH, EnumDirection.SOUTH, EnumDirection.WEST, EnumDirection.EAST};
+    private final LongSet l = new LongOpenHashSet();
+    private final LongSet m = new LongOpenHashSet();
+    private final LongSet n = new LongOpenHashSet();
+    private final LongSet o = new LongOpenHashSet();
+    private volatile boolean p;
+
+    protected LightEngineStorageSky(ILightAccess ilightaccess) {
+        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new Long2ObjectOpenHashMap(), new Long2IntOpenHashMap(), Integer.MAX_VALUE));
+    }
+
+    @Override
+    protected int d(long i) {
+        long j = SectionPosition.e(i);
+        int k = SectionPosition.c(j);
+        LightEngineStorageSky.a lightenginestoragesky_a = (LightEngineStorageSky.a) this.e;
+        int l = lightenginestoragesky_a.c.get(SectionPosition.f(j));
+
+        if (l != lightenginestoragesky_a.b && k < l) {
+            NibbleArray nibblearray = this.a((LightEngineStorageArray) lightenginestoragesky_a, j);
+
+            if (nibblearray == null) {
+                for (i = BlockPosition.f(i); nibblearray == null; nibblearray = this.a((LightEngineStorageArray) lightenginestoragesky_a, j)) {
+                    j = SectionPosition.a(j, EnumDirection.UP);
+                    ++k;
+                    if (k >= l) {
+                        return 15;
+                    }
+
+                    i = BlockPosition.a(i, 0, 16, 0);
+                }
+            }
+
+            return nibblearray.a(SectionPosition.b(BlockPosition.b(i)), SectionPosition.b(BlockPosition.c(i)), SectionPosition.b(BlockPosition.d(i)));
+        } else {
+            return 15;
+        }
+    }
+
+    @Override
+    protected void k(long i) {
+        int j = SectionPosition.c(i);
+
+        if (((LightEngineStorageSky.a) this.f).b > j) {
+            ((LightEngineStorageSky.a) this.f).b = j;
+            ((LightEngineStorageSky.a) this.f).c.defaultReturnValue(((LightEngineStorageSky.a) this.f).b);
+        }
+
+        long k = SectionPosition.f(i);
+        int l = ((LightEngineStorageSky.a) this.f).c.get(k);
+
+        if (l < j + 1) {
+            ((LightEngineStorageSky.a) this.f).c.put(k, j + 1);
+            if (this.o.contains(k)) {
+                this.q(i);
+                if (l > ((LightEngineStorageSky.a) this.f).b) {
+                    long i1 = SectionPosition.b(SectionPosition.b(i), l - 1, SectionPosition.d(i));
+
+                    this.p(i1);
+                }
+
+                this.f();
+            }
+        }
+
+    }
+
+    private void p(long i) {
+        this.n.add(i);
+        this.m.remove(i);
+    }
+
+    private void q(long i) {
+        this.m.add(i);
+        this.n.remove(i);
+    }
+
+    private void f() {
+        this.p = !this.m.isEmpty() || !this.n.isEmpty();
+    }
+
+    @Override
+    protected void l(long i) {
+        long j = SectionPosition.f(i);
+        boolean flag = this.o.contains(j);
+
+        if (flag) {
+            this.p(i);
+        }
+
+        int k = SectionPosition.c(i);
+
+        if (((LightEngineStorageSky.a) this.f).c.get(j) == k + 1) {
+            long l;
+
+            for (l = i; !this.g(l) && this.a(k); l = SectionPosition.a(l, EnumDirection.DOWN)) {
+                --k;
+            }
+
+            if (this.g(l)) {
+                ((LightEngineStorageSky.a) this.f).c.put(j, k + 1);
+                if (flag) {
+                    this.q(l);
+                }
+            } else {
+                ((LightEngineStorageSky.a) this.f).c.remove(j);
+            }
+        }
+
+        if (flag) {
+            this.f();
+        }
+
+    }
+
+    @Override
+    protected void b(long i, boolean flag) {
+        this.d();
+        if (flag && this.o.add(i)) {
+            int j = ((LightEngineStorageSky.a) this.f).c.get(i);
+
+            if (j != ((LightEngineStorageSky.a) this.f).b) {
+                long k = SectionPosition.b(SectionPosition.b(i), j - 1, SectionPosition.d(i));
+
+                this.q(k);
+                this.f();
+            }
+        } else if (!flag) {
+            this.o.remove(i);
+        }
+
+    }
+
+    @Override
+    protected boolean a() {
+        return super.a() || this.p;
+    }
+
+    @Override
+    protected NibbleArray j(long i) {
+        NibbleArray nibblearray = (NibbleArray) this.i.get(i);
+
+        if (nibblearray != null) {
+            return nibblearray;
+        } else {
+            long j = SectionPosition.a(i, EnumDirection.UP);
+            int k = ((LightEngineStorageSky.a) this.f).c.get(SectionPosition.f(i));
+
+            if (k != ((LightEngineStorageSky.a) this.f).b && SectionPosition.c(j) < k) {
+                NibbleArray nibblearray1;
+
+                while ((nibblearray1 = this.a(j, true)) == null) {
+                    j = SectionPosition.a(j, EnumDirection.UP);
+                }
+
+                return new NibbleArray((new NibbleArrayFlat(nibblearray1, 0)).asBytes());
+            } else {
+                return new NibbleArray();
+            }
+        }
+    }
+
+    @Override
+    protected void a(LightEngineLayer<LightEngineStorageSky.a, ?> lightenginelayer, boolean flag, boolean flag1) {
+        super.a(lightenginelayer, flag, flag1);
+        if (flag) {
+            LongIterator longiterator;
+            long i;
+            int j;
+            int k;
+
+            if (!this.m.isEmpty()) {
+                longiterator = this.m.iterator();
+
+                while (longiterator.hasNext()) {
+                    i = (Long) longiterator.next();
+                    j = this.c(i);
+                    if (j != 2 && !this.n.contains(i) && this.l.add(i)) {
+                        int l;
+
+                        if (j == 1) {
+                            this.a(lightenginelayer, i);
+                            if (this.g.add(i)) {
+                                ((LightEngineStorageSky.a) this.f).a(i);
+                            }
+
+                            Arrays.fill(this.a(i, true).asBytes(), (byte) -1);
+                            k = SectionPosition.c(SectionPosition.b(i));
+                            l = SectionPosition.c(SectionPosition.c(i));
+                            int i1 = SectionPosition.c(SectionPosition.d(i));
+                            EnumDirection[] aenumdirection = LightEngineStorageSky.k;
+                            int j1 = aenumdirection.length;
+
+                            long k1;
+
+                            for (int l1 = 0; l1 < j1; ++l1) {
+                                EnumDirection enumdirection = aenumdirection[l1];
+
+                                k1 = SectionPosition.a(i, enumdirection);
+                                if ((this.n.contains(k1) || !this.l.contains(k1) && !this.m.contains(k1)) && this.g(k1)) {
+                                    for (int i2 = 0; i2 < 16; ++i2) {
+                                        for (int j2 = 0; j2 < 16; ++j2) {
+                                            long k2;
+                                            long l2;
+
+                                            switch (enumdirection) {
+                                                case NORTH:
+                                                    k2 = BlockPosition.a(k + i2, l + j2, i1);
+                                                    l2 = BlockPosition.a(k + i2, l + j2, i1 - 1);
+                                                    break;
+                                                case SOUTH:
+                                                    k2 = BlockPosition.a(k + i2, l + j2, i1 + 16 - 1);
+                                                    l2 = BlockPosition.a(k + i2, l + j2, i1 + 16);
+                                                    break;
+                                                case WEST:
+                                                    k2 = BlockPosition.a(k, l + i2, i1 + j2);
+                                                    l2 = BlockPosition.a(k - 1, l + i2, i1 + j2);
+                                                    break;
+                                                default:
+                                                    k2 = BlockPosition.a(k + 16 - 1, l + i2, i1 + j2);
+                                                    l2 = BlockPosition.a(k + 16, l + i2, i1 + j2);
+                                            }
+
+                                            lightenginelayer.a(k2, l2, lightenginelayer.b(k2, l2, 0), true);
+                                        }
+                                    }
+                                }
+                            }
+
+                            for (int i3 = 0; i3 < 16; ++i3) {
+                                for (j1 = 0; j1 < 16; ++j1) {
+                                    long j3 = BlockPosition.a(SectionPosition.c(SectionPosition.b(i)) + i3, SectionPosition.c(SectionPosition.c(i)), SectionPosition.c(SectionPosition.d(i)) + j1);
+
+                                    k1 = BlockPosition.a(SectionPosition.c(SectionPosition.b(i)) + i3, SectionPosition.c(SectionPosition.c(i)) - 1, SectionPosition.c(SectionPosition.d(i)) + j1);
+                                    lightenginelayer.a(j3, k1, lightenginelayer.b(j3, k1, 0), true);
+                                }
+                            }
+                        } else {
+                            for (k = 0; k < 16; ++k) {
+                                for (l = 0; l < 16; ++l) {
+                                    long k3 = BlockPosition.a(SectionPosition.c(SectionPosition.b(i)) + k, SectionPosition.c(SectionPosition.c(i)) + 16 - 1, SectionPosition.c(SectionPosition.d(i)) + l);
+
+                                    lightenginelayer.a(Long.MAX_VALUE, k3, 0, true);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            this.m.clear();
+            if (!this.n.isEmpty()) {
+                longiterator = this.n.iterator();
+
+                while (longiterator.hasNext()) {
+                    i = (Long) longiterator.next();
+                    if (this.l.remove(i) && this.g(i)) {
+                        for (j = 0; j < 16; ++j) {
+                            for (k = 0; k < 16; ++k) {
+                                long l3 = BlockPosition.a(SectionPosition.c(SectionPosition.b(i)) + j, SectionPosition.c(SectionPosition.c(i)) + 16 - 1, SectionPosition.c(SectionPosition.d(i)) + k);
+
+                                lightenginelayer.a(Long.MAX_VALUE, l3, 15, false);
+                            }
+                        }
+                    }
+                }
+            }
+
+            this.n.clear();
+            this.p = false;
+        }
+    }
+
+    protected boolean a(int i) {
+        return i >= ((LightEngineStorageSky.a) this.f).b;
+    }
+
+    protected boolean m(long i) {
+        int j = BlockPosition.c(i);
+
+        if ((j & 15) != 15) {
+            return false;
+        } else {
+            long k = SectionPosition.e(i);
+            long l = SectionPosition.f(k);
+
+            if (!this.o.contains(l)) {
+                return false;
+            } else {
+                int i1 = ((LightEngineStorageSky.a) this.f).c.get(l);
+
+                return SectionPosition.c(i1) == j + 16;
+            }
+        }
+    }
+
+    protected boolean n(long i) {
+        long j = SectionPosition.f(i);
+        int k = ((LightEngineStorageSky.a) this.f).c.get(j);
+
+        return k == ((LightEngineStorageSky.a) this.f).b || SectionPosition.c(i) >= k;
+    }
+
+    protected boolean o(long i) {
+        long j = SectionPosition.f(i);
+
+        return this.o.contains(j);
+    }
+
+    public static final class a extends LightEngineStorageArray<LightEngineStorageSky.a> {
+
+        private int b;
+        private final Long2IntOpenHashMap c;
+
+        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap, Long2IntOpenHashMap long2intopenhashmap, int i) {
+            super(long2objectopenhashmap);
+            this.c = long2intopenhashmap;
+            long2intopenhashmap.defaultReturnValue(i);
+            this.b = i;
+        }
+
+        @Override
+        public LightEngineStorageSky.a b() {
+            return new LightEngineStorageSky.a(this.a.clone(), this.c.clone(), this.b);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/lighting/NibbleArrayFlat.java b/src/main/java/net/minecraft/world/level/lighting/NibbleArrayFlat.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc059d5f332fdf561c7e410ce9959154de25006a
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/lighting/NibbleArrayFlat.java
@@ -0,0 +1,31 @@
+package net.minecraft.world.level.lighting;
+
+import net.minecraft.world.level.chunk.NibbleArray;
+
+public class NibbleArrayFlat extends NibbleArray {
+
+    public NibbleArrayFlat() {
+        super(128);
+    }
+
+    public NibbleArrayFlat(NibbleArray nibblearray, int i) {
+        super(128);
+        System.arraycopy(nibblearray.asBytes(), i * 128, this.a, 0, 128);
+    }
+
+    @Override
+    protected int b(int i, int j, int k) {
+        return k << 4 | i;
+    }
+
+    @Override
+    public byte[] asBytes() {
+        byte[] abyte = new byte[2048];
+
+        for (int i = 0; i < 16; ++i) {
+            System.arraycopy(this.a, 0, abyte, i * 128, 128);
+        }
+
+        return abyte;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/material/Fluid.java b/src/main/java/net/minecraft/world/level/material/Fluid.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a93b204973eef4c02a52f33fd9578a43603ed98
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/material/Fluid.java
@@ -0,0 +1,86 @@
+package net.minecraft.world.level.material;
+
+import com.google.common.collect.ImmutableMap;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.MapCodec;
+import java.util.Random;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.IRegistry;
+import net.minecraft.tags.Tag;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.World;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.block.state.IBlockDataHolder;
+import net.minecraft.world.level.block.state.properties.IBlockState;
+import net.minecraft.world.phys.Vec3D;
+import net.minecraft.world.phys.shapes.VoxelShape;
+
+public final class Fluid extends IBlockDataHolder<FluidType, Fluid> {
+
+    public static final Codec<Fluid> a = a((Codec) IRegistry.FLUID, FluidType::h).stable();
+
+    public Fluid(FluidType fluidtype, ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap, MapCodec<Fluid> mapcodec) {
+        super(fluidtype, immutablemap, mapcodec);
+    }
+
+    public FluidType getType() {
+        return (FluidType) this.c;
+    }
+
+    public boolean isSource() {
+        return this.getType().c(this);
+    }
+
+    public boolean isEmpty() {
+        return this.getType().b();
+    }
+
+    public float getHeight(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return this.getType().a(this, iblockaccess, blockposition);
+    }
+
+    public float d() {
+        return this.getType().a(this);
+    }
+
+    public int e() {
+        return this.getType().d(this);
+    }
+
+    public void a(World world, BlockPosition blockposition) {
+        this.getType().a(world, blockposition, this);
+    }
+
+    public boolean f() {
+        return this.getType().j();
+    }
+
+    public void b(World world, BlockPosition blockposition, Random random) {
+        this.getType().b(world, blockposition, this, random);
+    }
+
+    public Vec3D c(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return this.getType().a(iblockaccess, blockposition, this);
+    }
+
+    public IBlockData getBlockData() {
+        return this.getType().b(this);
+    }
+
+    public boolean a(Tag<FluidType> tag) {
+        return this.getType().a(tag);
+    }
+
+    public float i() {
+        return this.getType().c();
+    }
+
+    public boolean a(IBlockAccess iblockaccess, BlockPosition blockposition, FluidType fluidtype, EnumDirection enumdirection) {
+        return this.getType().a(this, iblockaccess, blockposition, fluidtype, enumdirection);
+    }
+
+    public VoxelShape d(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return this.getType().b(this, iblockaccess, blockposition);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathEntity.java b/src/main/java/net/minecraft/world/level/pathfinder/PathEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..606027de777750f6d2ab0d7f1ef387ed4f0c6092
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathEntity.java
@@ -0,0 +1,134 @@
+package net.minecraft.world.level.pathfinder;
+
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.Vec3D;
+
+public class PathEntity {
+
+    private final List<PathPoint> a;
+    private PathPoint[] b = new PathPoint[0];
+    private PathPoint[] c = new PathPoint[0];
+    private int e;
+    private final BlockPosition f;
+    private final float g;
+    private final boolean h;
+
+    public PathEntity(List<PathPoint> list, BlockPosition blockposition, boolean flag) {
+        this.a = list;
+        this.f = blockposition;
+        this.g = list.isEmpty() ? Float.MAX_VALUE : ((PathPoint) this.a.get(this.a.size() - 1)).c(this.f);
+        this.h = flag;
+    }
+
+    public void a() {
+        ++this.e;
+    }
+
+    public boolean b() {
+        return this.e <= 0;
+    }
+
+    public boolean c() {
+        return this.e >= this.a.size();
+    }
+
+    @Nullable
+    public PathPoint d() {
+        return !this.a.isEmpty() ? (PathPoint) this.a.get(this.a.size() - 1) : null;
+    }
+
+    public PathPoint a(int i) {
+        return (PathPoint) this.a.get(i);
+    }
+
+    public void b(int i) {
+        if (this.a.size() > i) {
+            this.a.subList(i, this.a.size()).clear();
+        }
+
+    }
+
+    public void a(int i, PathPoint pathpoint) {
+        this.a.set(i, pathpoint);
+    }
+
+    public int e() {
+        return this.a.size();
+    }
+
+    public int f() {
+        return this.e;
+    }
+
+    public void c(int i) {
+        this.e = i;
+    }
+
+    public Vec3D a(Entity entity, int i) {
+        PathPoint pathpoint = (PathPoint) this.a.get(i);
+        double d0 = (double) pathpoint.a + (double) ((int) (entity.getWidth() + 1.0F)) * 0.5D;
+        double d1 = (double) pathpoint.b;
+        double d2 = (double) pathpoint.c + (double) ((int) (entity.getWidth() + 1.0F)) * 0.5D;
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    public BlockPosition d(int i) {
+        return ((PathPoint) this.a.get(i)).a();
+    }
+
+    public Vec3D a(Entity entity) {
+        return this.a(entity, this.e);
+    }
+
+    public BlockPosition g() {
+        return ((PathPoint) this.a.get(this.e)).a();
+    }
+
+    public PathPoint h() {
+        return (PathPoint) this.a.get(this.e);
+    }
+
+    @Nullable
+    public PathPoint i() {
+        return this.e > 0 ? (PathPoint) this.a.get(this.e - 1) : null;
+    }
+
+    public boolean a(@Nullable PathEntity pathentity) {
+        if (pathentity == null) {
+            return false;
+        } else if (pathentity.a.size() != this.a.size()) {
+            return false;
+        } else {
+            for (int i = 0; i < this.a.size(); ++i) {
+                PathPoint pathpoint = (PathPoint) this.a.get(i);
+                PathPoint pathpoint1 = (PathPoint) pathentity.a.get(i);
+
+                if (pathpoint.a != pathpoint1.a || pathpoint.b != pathpoint1.b || pathpoint.c != pathpoint1.c) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+
+    public boolean j() {
+        return this.h;
+    }
+
+    public String toString() {
+        return "Path(length=" + this.a.size() + ")";
+    }
+
+    public BlockPosition m() {
+        return this.f;
+    }
+
+    public float n() {
+        return this.g;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathPoint.java b/src/main/java/net/minecraft/world/level/pathfinder/PathPoint.java
new file mode 100644
index 0000000000000000000000000000000000000000..43cc9430972a18cbf03a590d576ed200e3836017
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathPoint.java
@@ -0,0 +1,106 @@
+package net.minecraft.world.level.pathfinder;
+
+import net.minecraft.core.BlockPosition;
+import net.minecraft.util.MathHelper;
+
+public class PathPoint {
+
+    public final int a;
+    public final int b;
+    public final int c;
+    private final int m;
+    public int d = -1;
+    public float e;
+    public float f;
+    public float g;
+    public PathPoint h;
+    public boolean i;
+    public float j;
+    public float k;
+    public PathType l;
+
+    public PathPoint(int i, int j, int k) {
+        this.l = PathType.BLOCKED;
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.m = b(i, j, k);
+    }
+
+    public PathPoint a(int i, int j, int k) {
+        PathPoint pathpoint = new PathPoint(i, j, k);
+
+        pathpoint.d = this.d;
+        pathpoint.e = this.e;
+        pathpoint.f = this.f;
+        pathpoint.g = this.g;
+        pathpoint.h = this.h;
+        pathpoint.i = this.i;
+        pathpoint.j = this.j;
+        pathpoint.k = this.k;
+        pathpoint.l = this.l;
+        return pathpoint;
+    }
+
+    public static int b(int i, int j, int k) {
+        return j & 255 | (i & 32767) << 8 | (k & 32767) << 24 | (i < 0 ? Integer.MIN_VALUE : 0) | (k < 0 ? '\u8000' : 0);
+    }
+
+    public float a(PathPoint pathpoint) {
+        float f = (float) (pathpoint.a - this.a);
+        float f1 = (float) (pathpoint.b - this.b);
+        float f2 = (float) (pathpoint.c - this.c);
+
+        return MathHelper.c(f * f + f1 * f1 + f2 * f2);
+    }
+
+    public float b(PathPoint pathpoint) {
+        float f = (float) (pathpoint.a - this.a);
+        float f1 = (float) (pathpoint.b - this.b);
+        float f2 = (float) (pathpoint.c - this.c);
+
+        return f * f + f1 * f1 + f2 * f2;
+    }
+
+    public float c(PathPoint pathpoint) {
+        float f = (float) Math.abs(pathpoint.a - this.a);
+        float f1 = (float) Math.abs(pathpoint.b - this.b);
+        float f2 = (float) Math.abs(pathpoint.c - this.c);
+
+        return f + f1 + f2;
+    }
+
+    public float c(BlockPosition blockposition) {
+        float f = (float) Math.abs(blockposition.getX() - this.a);
+        float f1 = (float) Math.abs(blockposition.getY() - this.b);
+        float f2 = (float) Math.abs(blockposition.getZ() - this.c);
+
+        return f + f1 + f2;
+    }
+
+    public BlockPosition a() {
+        return new BlockPosition(this.a, this.b, this.c);
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof PathPoint)) {
+            return false;
+        } else {
+            PathPoint pathpoint = (PathPoint) object;
+
+            return this.m == pathpoint.m && this.a == pathpoint.a && this.b == pathpoint.b && this.c == pathpoint.c;
+        }
+    }
+
+    public int hashCode() {
+        return this.m;
+    }
+
+    public boolean c() {
+        return this.d >= 0;
+    }
+
+    public String toString() {
+        return "Node{x=" + this.a + ", y=" + this.b + ", z=" + this.c + '}';
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathType.java b/src/main/java/net/minecraft/world/level/pathfinder/PathType.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd20802155097d4951cbe273f64de4809dee5c96
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathType.java
@@ -0,0 +1,16 @@
+package net.minecraft.world.level.pathfinder;
+
+public enum PathType {
+
+    BLOCKED(-1.0F), OPEN(0.0F), WALKABLE(0.0F), WALKABLE_DOOR(0.0F), TRAPDOOR(0.0F), FENCE(-1.0F), LAVA(-1.0F), WATER(8.0F), WATER_BORDER(8.0F), RAIL(0.0F), UNPASSABLE_RAIL(-1.0F), DANGER_FIRE(8.0F), DAMAGE_FIRE(16.0F), DANGER_CACTUS(8.0F), DAMAGE_CACTUS(-1.0F), DANGER_OTHER(8.0F), DAMAGE_OTHER(-1.0F), DOOR_OPEN(0.0F), DOOR_WOOD_CLOSED(-1.0F), DOOR_IRON_CLOSED(-1.0F), BREACH(4.0F), LEAVES(-1.0F), STICKY_HONEY(8.0F), COCOA(0.0F);
+
+    private final float y;
+
+    private PathType(float f) {
+        this.y = f;
+    }
+
+    public float a() {
+        return this.y;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/Pathfinder.java b/src/main/java/net/minecraft/world/level/pathfinder/Pathfinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..39cd22a820fdc4c75aefb625b45b0c8c6ce1f199
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/pathfinder/Pathfinder.java
@@ -0,0 +1,151 @@
+package net.minecraft.world.level.pathfinder;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.level.ChunkCache;
+
+public class Pathfinder {
+
+    private final PathPoint[] a = new PathPoint[32];
+    private final int b;
+    private final PathfinderAbstract c;
+    private final Path d = new Path();
+
+    public Pathfinder(PathfinderAbstract pathfinderabstract, int i) {
+        this.c = pathfinderabstract;
+        this.b = i;
+    }
+
+    @Nullable
+    public PathEntity a(ChunkCache chunkcache, EntityInsentient entityinsentient, Set<BlockPosition> set, float f, int i, float f1) {
+        this.d.a();
+        this.c.a(chunkcache, entityinsentient);
+        PathPoint pathpoint = this.c.b();
+        Map<PathDestination, BlockPosition> map = (Map) set.stream().collect(Collectors.toMap((blockposition) -> {
+            return this.c.a((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ());
+        }, Function.identity()));
+        PathEntity pathentity = this.a(pathpoint, map, f, i, f1);
+
+        this.c.a();
+        return pathentity;
+    }
+
+    @Nullable
+    private PathEntity a(PathPoint pathpoint, Map<PathDestination, BlockPosition> map, float f, int i, float f1) {
+        Set<PathDestination> set = map.keySet();
+
+        pathpoint.e = 0.0F;
+        pathpoint.f = this.a(pathpoint, set);
+        pathpoint.g = pathpoint.f;
+        this.d.a();
+        this.d.a(pathpoint);
+        Set<PathPoint> set1 = ImmutableSet.of();
+        int j = 0;
+        Set<PathDestination> set2 = Sets.newHashSetWithExpectedSize(set.size());
+        int k = (int) ((float) this.b * f1);
+
+        while (!this.d.e()) {
+            ++j;
+            if (j >= k) {
+                break;
+            }
+
+            PathPoint pathpoint1 = this.d.c();
+
+            pathpoint1.i = true;
+            Iterator iterator = set.iterator();
+
+            while (iterator.hasNext()) {
+                PathDestination pathdestination = (PathDestination) iterator.next();
+
+                if (pathpoint1.c((PathPoint) pathdestination) <= (float) i) {
+                    pathdestination.e();
+                    set2.add(pathdestination);
+                }
+            }
+
+            if (!set2.isEmpty()) {
+                break;
+            }
+
+            if (pathpoint1.a(pathpoint) < f) {
+                int l = this.c.a(this.a, pathpoint1);
+
+                for (int i1 = 0; i1 < l; ++i1) {
+                    PathPoint pathpoint2 = this.a[i1];
+                    float f2 = pathpoint1.a(pathpoint2);
+
+                    pathpoint2.j = pathpoint1.j + f2;
+                    float f3 = pathpoint1.e + f2 + pathpoint2.k;
+
+                    if (pathpoint2.j < f && (!pathpoint2.c() || f3 < pathpoint2.e)) {
+                        pathpoint2.h = pathpoint1;
+                        pathpoint2.e = f3;
+                        pathpoint2.f = this.a(pathpoint2, set) * 1.5F;
+                        if (pathpoint2.c()) {
+                            this.d.a(pathpoint2, pathpoint2.e + pathpoint2.f);
+                        } else {
+                            pathpoint2.g = pathpoint2.e + pathpoint2.f;
+                            this.d.a(pathpoint2);
+                        }
+                    }
+                }
+            }
+        }
+
+        Optional<PathEntity> optional = !set2.isEmpty() ? set2.stream().map((pathdestination1) -> {
+            return this.a(pathdestination1.d(), (BlockPosition) map.get(pathdestination1), true);
+        }).min(Comparator.comparingInt(PathEntity::e)) : set.stream().map((pathdestination1) -> {
+            return this.a(pathdestination1.d(), (BlockPosition) map.get(pathdestination1), false);
+        }).min(Comparator.comparingDouble(PathEntity::n).thenComparingInt(PathEntity::e));
+
+        if (!optional.isPresent()) {
+            return null;
+        } else {
+            PathEntity pathentity = (PathEntity) optional.get();
+
+            return pathentity;
+        }
+    }
+
+    private float a(PathPoint pathpoint, Set<PathDestination> set) {
+        float f = Float.MAX_VALUE;
+
+        float f1;
+
+        for (Iterator iterator = set.iterator(); iterator.hasNext(); f = Math.min(f1, f)) {
+            PathDestination pathdestination = (PathDestination) iterator.next();
+
+            f1 = pathpoint.a(pathdestination);
+            pathdestination.a(f1, pathpoint);
+        }
+
+        return f;
+    }
+
+    private PathEntity a(PathPoint pathpoint, BlockPosition blockposition, boolean flag) {
+        List<PathPoint> list = Lists.newArrayList();
+        PathPoint pathpoint1 = pathpoint;
+
+        list.add(0, pathpoint);
+
+        while (pathpoint1.h != null) {
+            pathpoint1 = pathpoint1.h;
+            list.add(0, pathpoint1);
+        }
+
+        return new PathEntity(list, blockposition, flag);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathfinderAbstract.java b/src/main/java/net/minecraft/world/level/pathfinder/PathfinderAbstract.java
new file mode 100644
index 0000000000000000000000000000000000000000..f2080bd50db04af6eabec4b4b757d6dadfb1a2f5
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathfinderAbstract.java
@@ -0,0 +1,82 @@
+package net.minecraft.world.level.pathfinder;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.level.ChunkCache;
+import net.minecraft.world.level.IBlockAccess;
+
+public abstract class PathfinderAbstract {
+
+    protected ChunkCache a;
+    protected EntityInsentient b;
+    protected final Int2ObjectMap<PathPoint> c = new Int2ObjectOpenHashMap();
+    protected int d;
+    protected int e;
+    protected int f;
+    protected boolean g;
+    protected boolean h;
+    protected boolean i;
+
+    public PathfinderAbstract() {}
+
+    public void a(ChunkCache chunkcache, EntityInsentient entityinsentient) {
+        this.a = chunkcache;
+        this.b = entityinsentient;
+        this.c.clear();
+        this.d = MathHelper.d(entityinsentient.getWidth() + 1.0F);
+        this.e = MathHelper.d(entityinsentient.getHeight() + 1.0F);
+        this.f = MathHelper.d(entityinsentient.getWidth() + 1.0F);
+    }
+
+    public void a() {
+        this.a = null;
+        this.b = null;
+    }
+
+    protected PathPoint a(BlockPosition blockposition) {
+        return this.a(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+    }
+
+    protected PathPoint a(int i, int j, int k) {
+        return (PathPoint) this.c.computeIfAbsent(PathPoint.b(i, j, k), (l) -> {
+            return new PathPoint(i, j, k);
+        });
+    }
+
+    public abstract PathPoint b();
+
+    public abstract PathDestination a(double d0, double d1, double d2);
+
+    public abstract int a(PathPoint[] apathpoint, PathPoint pathpoint);
+
+    public abstract PathType a(IBlockAccess iblockaccess, int i, int j, int k, EntityInsentient entityinsentient, int l, int i1, int j1, boolean flag, boolean flag1);
+
+    public abstract PathType a(IBlockAccess iblockaccess, int i, int j, int k);
+
+    public void a(boolean flag) {
+        this.g = flag;
+    }
+
+    public void b(boolean flag) {
+        this.h = flag;
+    }
+
+    public void c(boolean flag) {
+        this.i = flag;
+    }
+
+    public boolean c() {
+        return this.g;
+    }
+
+    public boolean d() {
+        return this.h;
+    }
+
+    public boolean e() {
+        return this.i;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathfinderNormal.java b/src/main/java/net/minecraft/world/level/pathfinder/PathfinderNormal.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed9c1dfbc84b9573784e6531186b3cd9513ddf75
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathfinderNormal.java
@@ -0,0 +1,536 @@
+package net.minecraft.world.level.pathfinder;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
+import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
+import java.util.EnumSet;
+import java.util.Iterator;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.tags.Tag;
+import net.minecraft.tags.TagsBlock;
+import net.minecraft.tags.TagsFluid;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.entity.EntityInsentient;
+import net.minecraft.world.level.ChunkCache;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BlockCampfire;
+import net.minecraft.world.level.block.BlockDoor;
+import net.minecraft.world.level.block.BlockFenceGate;
+import net.minecraft.world.level.block.BlockLeaves;
+import net.minecraft.world.level.block.BlockMinecartTrackAbstract;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.FluidTypes;
+import net.minecraft.world.level.material.Material;
+import net.minecraft.world.phys.AxisAlignedBB;
+import net.minecraft.world.phys.Vec3D;
+import net.minecraft.world.phys.shapes.VoxelShape;
+
+public class PathfinderNormal extends PathfinderAbstract {
+
+    protected float j;
+    private final Long2ObjectMap<PathType> k = new Long2ObjectOpenHashMap();
+    private final Object2BooleanMap<AxisAlignedBB> l = new Object2BooleanOpenHashMap();
+
+    public PathfinderNormal() {}
+
+    @Override
+    public void a(ChunkCache chunkcache, EntityInsentient entityinsentient) {
+        super.a(chunkcache, entityinsentient);
+        this.j = entityinsentient.a(PathType.WATER);
+    }
+
+    @Override
+    public void a() {
+        this.b.a(PathType.WATER, this.j);
+        this.k.clear();
+        this.l.clear();
+        super.a();
+    }
+
+    @Override
+    public PathPoint b() {
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        int i = MathHelper.floor(this.b.locY());
+        IBlockData iblockdata = this.a.getType(blockposition_mutableblockposition.c(this.b.locX(), (double) i, this.b.locZ()));
+        BlockPosition blockposition;
+
+        if (this.b.a(iblockdata.getFluid().getType())) {
+            while (this.b.a(iblockdata.getFluid().getType())) {
+                ++i;
+                iblockdata = this.a.getType(blockposition_mutableblockposition.c(this.b.locX(), (double) i, this.b.locZ()));
+            }
+
+            --i;
+        } else if (this.e() && this.b.isInWater()) {
+            while (iblockdata.getBlock() == Blocks.WATER || iblockdata.getFluid() == FluidTypes.WATER.a(false)) {
+                ++i;
+                iblockdata = this.a.getType(blockposition_mutableblockposition.c(this.b.locX(), (double) i, this.b.locZ()));
+            }
+
+            --i;
+        } else if (this.b.isOnGround()) {
+            i = MathHelper.floor(this.b.locY() + 0.5D);
+        } else {
+            for (blockposition = this.b.getChunkCoordinates(); (this.a.getType(blockposition).isAir() || this.a.getType(blockposition).a((IBlockAccess) this.a, blockposition, PathMode.LAND)) && blockposition.getY() > 0; blockposition = blockposition.down()) {
+                ;
+            }
+
+            i = blockposition.up().getY();
+        }
+
+        blockposition = this.b.getChunkCoordinates();
+        PathType pathtype = this.a(this.b, blockposition.getX(), i, blockposition.getZ());
+
+        if (this.b.a(pathtype) < 0.0F) {
+            AxisAlignedBB axisalignedbb = this.b.getBoundingBox();
+
+            if (this.b(blockposition_mutableblockposition.c(axisalignedbb.minX, (double) i, axisalignedbb.minZ)) || this.b(blockposition_mutableblockposition.c(axisalignedbb.minX, (double) i, axisalignedbb.maxZ)) || this.b(blockposition_mutableblockposition.c(axisalignedbb.maxX, (double) i, axisalignedbb.minZ)) || this.b(blockposition_mutableblockposition.c(axisalignedbb.maxX, (double) i, axisalignedbb.maxZ))) {
+                PathPoint pathpoint = this.a((BlockPosition) blockposition_mutableblockposition);
+
+                pathpoint.l = this.a(this.b, pathpoint.a());
+                pathpoint.k = this.b.a(pathpoint.l);
+                return pathpoint;
+            }
+        }
+
+        PathPoint pathpoint1 = this.a(blockposition.getX(), i, blockposition.getZ());
+
+        pathpoint1.l = this.a(this.b, pathpoint1.a());
+        pathpoint1.k = this.b.a(pathpoint1.l);
+        return pathpoint1;
+    }
+
+    private boolean b(BlockPosition blockposition) {
+        PathType pathtype = this.a(this.b, blockposition);
+
+        return this.b.a(pathtype) >= 0.0F;
+    }
+
+    @Override
+    public PathDestination a(double d0, double d1, double d2) {
+        return new PathDestination(this.a(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2)));
+    }
+
+    @Override
+    public int a(PathPoint[] apathpoint, PathPoint pathpoint) {
+        int i = 0;
+        int j = 0;
+        PathType pathtype = this.a(this.b, pathpoint.a, pathpoint.b + 1, pathpoint.c);
+        PathType pathtype1 = this.a(this.b, pathpoint.a, pathpoint.b, pathpoint.c);
+
+        if (this.b.a(pathtype) >= 0.0F && pathtype1 != PathType.STICKY_HONEY) {
+            j = MathHelper.d(Math.max(1.0F, this.b.G));
+        }
+
+        double d0 = a((IBlockAccess) this.a, new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c));
+        PathPoint pathpoint1 = this.a(pathpoint.a, pathpoint.b, pathpoint.c + 1, j, d0, EnumDirection.SOUTH, pathtype1);
+
+        if (this.a(pathpoint1, pathpoint)) {
+            apathpoint[i++] = pathpoint1;
+        }
+
+        PathPoint pathpoint2 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c, j, d0, EnumDirection.WEST, pathtype1);
+
+        if (this.a(pathpoint2, pathpoint)) {
+            apathpoint[i++] = pathpoint2;
+        }
+
+        PathPoint pathpoint3 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c, j, d0, EnumDirection.EAST, pathtype1);
+
+        if (this.a(pathpoint3, pathpoint)) {
+            apathpoint[i++] = pathpoint3;
+        }
+
+        PathPoint pathpoint4 = this.a(pathpoint.a, pathpoint.b, pathpoint.c - 1, j, d0, EnumDirection.NORTH, pathtype1);
+
+        if (this.a(pathpoint4, pathpoint)) {
+            apathpoint[i++] = pathpoint4;
+        }
+
+        PathPoint pathpoint5 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c - 1, j, d0, EnumDirection.NORTH, pathtype1);
+
+        if (this.a(pathpoint, pathpoint2, pathpoint4, pathpoint5)) {
+            apathpoint[i++] = pathpoint5;
+        }
+
+        PathPoint pathpoint6 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c - 1, j, d0, EnumDirection.NORTH, pathtype1);
+
+        if (this.a(pathpoint, pathpoint3, pathpoint4, pathpoint6)) {
+            apathpoint[i++] = pathpoint6;
+        }
+
+        PathPoint pathpoint7 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c + 1, j, d0, EnumDirection.SOUTH, pathtype1);
+
+        if (this.a(pathpoint, pathpoint2, pathpoint1, pathpoint7)) {
+            apathpoint[i++] = pathpoint7;
+        }
+
+        PathPoint pathpoint8 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c + 1, j, d0, EnumDirection.SOUTH, pathtype1);
+
+        if (this.a(pathpoint, pathpoint3, pathpoint1, pathpoint8)) {
+            apathpoint[i++] = pathpoint8;
+        }
+
+        return i;
+    }
+
+    private boolean a(PathPoint pathpoint, PathPoint pathpoint1) {
+        return pathpoint != null && !pathpoint.i && (pathpoint.k >= 0.0F || pathpoint1.k < 0.0F);
+    }
+
+    private boolean a(PathPoint pathpoint, @Nullable PathPoint pathpoint1, @Nullable PathPoint pathpoint2, @Nullable PathPoint pathpoint3) {
+        if (pathpoint3 != null && pathpoint2 != null && pathpoint1 != null) {
+            if (pathpoint3.i) {
+                return false;
+            } else if (pathpoint2.b <= pathpoint.b && pathpoint1.b <= pathpoint.b) {
+                if (pathpoint1.l != PathType.WALKABLE_DOOR && pathpoint2.l != PathType.WALKABLE_DOOR && pathpoint3.l != PathType.WALKABLE_DOOR) {
+                    boolean flag = pathpoint2.l == PathType.FENCE && pathpoint1.l == PathType.FENCE && (double) this.b.getWidth() < 0.5D;
+
+                    return pathpoint3.k >= 0.0F && (pathpoint2.b < pathpoint.b || pathpoint2.k >= 0.0F || flag) && (pathpoint1.b < pathpoint.b || pathpoint1.k >= 0.0F || flag);
+                } else {
+                    return false;
+                }
+            } else {
+                return false;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private boolean a(PathPoint pathpoint) {
+        Vec3D vec3d = new Vec3D((double) pathpoint.a - this.b.locX(), (double) pathpoint.b - this.b.locY(), (double) pathpoint.c - this.b.locZ());
+        AxisAlignedBB axisalignedbb = this.b.getBoundingBox();
+        int i = MathHelper.f(vec3d.f() / axisalignedbb.a());
+
+        vec3d = vec3d.a((double) (1.0F / (float) i));
+
+        for (int j = 1; j <= i; ++j) {
+            axisalignedbb = axisalignedbb.c(vec3d);
+            if (this.a(axisalignedbb)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static double a(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        BlockPosition blockposition1 = blockposition.down();
+        VoxelShape voxelshape = iblockaccess.getType(blockposition1).getCollisionShape(iblockaccess, blockposition1);
+
+        return (double) blockposition1.getY() + (voxelshape.isEmpty() ? 0.0D : voxelshape.c(EnumDirection.EnumAxis.Y));
+    }
+
+    @Nullable
+    private PathPoint a(int i, int j, int k, int l, double d0, EnumDirection enumdirection, PathType pathtype) {
+        PathPoint pathpoint = null;
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+        double d1 = a((IBlockAccess) this.a, (BlockPosition) blockposition_mutableblockposition.d(i, j, k));
+
+        if (d1 - d0 > 1.125D) {
+            return null;
+        } else {
+            PathType pathtype1 = this.a(this.b, i, j, k);
+            float f = this.b.a(pathtype1);
+            double d2 = (double) this.b.getWidth() / 2.0D;
+
+            if (f >= 0.0F) {
+                pathpoint = this.a(i, j, k);
+                pathpoint.l = pathtype1;
+                pathpoint.k = Math.max(pathpoint.k, f);
+            }
+
+            if (pathtype == PathType.FENCE && pathpoint != null && pathpoint.k >= 0.0F && !this.a(pathpoint)) {
+                pathpoint = null;
+            }
+
+            if (pathtype1 == PathType.WALKABLE) {
+                return pathpoint;
+            } else {
+                if ((pathpoint == null || pathpoint.k < 0.0F) && l > 0 && pathtype1 != PathType.FENCE && pathtype1 != PathType.UNPASSABLE_RAIL && pathtype1 != PathType.TRAPDOOR) {
+                    pathpoint = this.a(i, j + 1, k, l - 1, d0, enumdirection, pathtype);
+                    if (pathpoint != null && (pathpoint.l == PathType.OPEN || pathpoint.l == PathType.WALKABLE) && this.b.getWidth() < 1.0F) {
+                        double d3 = (double) (i - enumdirection.getAdjacentX()) + 0.5D;
+                        double d4 = (double) (k - enumdirection.getAdjacentZ()) + 0.5D;
+                        AxisAlignedBB axisalignedbb = new AxisAlignedBB(d3 - d2, a((IBlockAccess) this.a, (BlockPosition) blockposition_mutableblockposition.c(d3, (double) (j + 1), d4)) + 0.001D, d4 - d2, d3 + d2, (double) this.b.getHeight() + a((IBlockAccess) this.a, (BlockPosition) blockposition_mutableblockposition.c((double) pathpoint.a, (double) pathpoint.b, (double) pathpoint.c)) - 0.002D, d4 + d2);
+
+                        if (this.a(axisalignedbb)) {
+                            pathpoint = null;
+                        }
+                    }
+                }
+
+                if (pathtype1 == PathType.WATER && !this.e()) {
+                    if (this.a(this.b, i, j - 1, k) != PathType.WATER) {
+                        return pathpoint;
+                    }
+
+                    while (j > 0) {
+                        --j;
+                        pathtype1 = this.a(this.b, i, j, k);
+                        if (pathtype1 != PathType.WATER) {
+                            return pathpoint;
+                        }
+
+                        pathpoint = this.a(i, j, k);
+                        pathpoint.l = pathtype1;
+                        pathpoint.k = Math.max(pathpoint.k, this.b.a(pathtype1));
+                    }
+                }
+
+                if (pathtype1 == PathType.OPEN) {
+                    int i1 = 0;
+                    int j1 = j;
+
+                    while (pathtype1 == PathType.OPEN) {
+                        --j;
+                        PathPoint pathpoint1;
+
+                        if (j < 0) {
+                            pathpoint1 = this.a(i, j1, k);
+                            pathpoint1.l = PathType.BLOCKED;
+                            pathpoint1.k = -1.0F;
+                            return pathpoint1;
+                        }
+
+                        if (i1++ >= this.b.bP()) {
+                            pathpoint1 = this.a(i, j, k);
+                            pathpoint1.l = PathType.BLOCKED;
+                            pathpoint1.k = -1.0F;
+                            return pathpoint1;
+                        }
+
+                        pathtype1 = this.a(this.b, i, j, k);
+                        f = this.b.a(pathtype1);
+                        if (pathtype1 != PathType.OPEN && f >= 0.0F) {
+                            pathpoint = this.a(i, j, k);
+                            pathpoint.l = pathtype1;
+                            pathpoint.k = Math.max(pathpoint.k, f);
+                            break;
+                        }
+
+                        if (f < 0.0F) {
+                            pathpoint1 = this.a(i, j, k);
+                            pathpoint1.l = PathType.BLOCKED;
+                            pathpoint1.k = -1.0F;
+                            return pathpoint1;
+                        }
+                    }
+                }
+
+                if (pathtype1 == PathType.FENCE) {
+                    pathpoint = this.a(i, j, k);
+                    pathpoint.i = true;
+                    pathpoint.l = pathtype1;
+                    pathpoint.k = pathtype1.a();
+                }
+
+                return pathpoint;
+            }
+        }
+    }
+
+    private boolean a(AxisAlignedBB axisalignedbb) {
+        return (Boolean) this.l.computeIfAbsent(axisalignedbb, (axisalignedbb1) -> {
+            return !this.a.getCubes(this.b, axisalignedbb);
+        });
+    }
+
+    @Override
+    public PathType a(IBlockAccess iblockaccess, int i, int j, int k, EntityInsentient entityinsentient, int l, int i1, int j1, boolean flag, boolean flag1) {
+        EnumSet<PathType> enumset = EnumSet.noneOf(PathType.class);
+        PathType pathtype = PathType.BLOCKED;
+        BlockPosition blockposition = entityinsentient.getChunkCoordinates();
+
+        pathtype = this.a(iblockaccess, i, j, k, l, i1, j1, flag, flag1, enumset, pathtype, blockposition);
+        if (enumset.contains(PathType.FENCE)) {
+            return PathType.FENCE;
+        } else if (enumset.contains(PathType.UNPASSABLE_RAIL)) {
+            return PathType.UNPASSABLE_RAIL;
+        } else {
+            PathType pathtype1 = PathType.BLOCKED;
+            Iterator iterator = enumset.iterator();
+
+            while (iterator.hasNext()) {
+                PathType pathtype2 = (PathType) iterator.next();
+
+                if (entityinsentient.a(pathtype2) < 0.0F) {
+                    return pathtype2;
+                }
+
+                if (entityinsentient.a(pathtype2) >= entityinsentient.a(pathtype1)) {
+                    pathtype1 = pathtype2;
+                }
+            }
+
+            if (pathtype == PathType.OPEN && entityinsentient.a(pathtype1) == 0.0F && l <= 1) {
+                return PathType.OPEN;
+            } else {
+                return pathtype1;
+            }
+        }
+    }
+
+    public PathType a(IBlockAccess iblockaccess, int i, int j, int k, int l, int i1, int j1, boolean flag, boolean flag1, EnumSet<PathType> enumset, PathType pathtype, BlockPosition blockposition) {
+        for (int k1 = 0; k1 < l; ++k1) {
+            for (int l1 = 0; l1 < i1; ++l1) {
+                for (int i2 = 0; i2 < j1; ++i2) {
+                    int j2 = k1 + i;
+                    int k2 = l1 + j;
+                    int l2 = i2 + k;
+                    PathType pathtype1 = this.a(iblockaccess, j2, k2, l2);
+
+                    pathtype1 = this.a(iblockaccess, flag, flag1, blockposition, pathtype1);
+                    if (k1 == 0 && l1 == 0 && i2 == 0) {
+                        pathtype = pathtype1;
+                    }
+
+                    enumset.add(pathtype1);
+                }
+            }
+        }
+
+        return pathtype;
+    }
+
+    protected PathType a(IBlockAccess iblockaccess, boolean flag, boolean flag1, BlockPosition blockposition, PathType pathtype) {
+        if (pathtype == PathType.DOOR_WOOD_CLOSED && flag && flag1) {
+            pathtype = PathType.WALKABLE_DOOR;
+        }
+
+        if (pathtype == PathType.DOOR_OPEN && !flag1) {
+            pathtype = PathType.BLOCKED;
+        }
+
+        if (pathtype == PathType.RAIL && !(iblockaccess.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(iblockaccess.getType(blockposition.down()).getBlock() instanceof BlockMinecartTrackAbstract)) {
+            pathtype = PathType.UNPASSABLE_RAIL;
+        }
+
+        if (pathtype == PathType.LEAVES) {
+            pathtype = PathType.BLOCKED;
+        }
+
+        return pathtype;
+    }
+
+    private PathType a(EntityInsentient entityinsentient, BlockPosition blockposition) {
+        return this.a(entityinsentient, blockposition.getX(), blockposition.getY(), blockposition.getZ());
+    }
+
+    private PathType a(EntityInsentient entityinsentient, int i, int j, int k) {
+        return (PathType) this.k.computeIfAbsent(BlockPosition.a(i, j, k), (l) -> {
+            return this.a(this.a, i, j, k, entityinsentient, this.d, this.e, this.f, this.d(), this.c());
+        });
+    }
+
+    @Override
+    public PathType a(IBlockAccess iblockaccess, int i, int j, int k) {
+        return a(iblockaccess, new BlockPosition.MutableBlockPosition(i, j, k));
+    }
+
+    public static PathType a(IBlockAccess iblockaccess, BlockPosition.MutableBlockPosition blockposition_mutableblockposition) {
+        int i = blockposition_mutableblockposition.getX();
+        int j = blockposition_mutableblockposition.getY();
+        int k = blockposition_mutableblockposition.getZ();
+        PathType pathtype = b(iblockaccess, blockposition_mutableblockposition);
+
+        if (pathtype == PathType.OPEN && j >= 1) {
+            PathType pathtype1 = b(iblockaccess, blockposition_mutableblockposition.d(i, j - 1, k));
+
+            pathtype = pathtype1 != PathType.WALKABLE && pathtype1 != PathType.OPEN && pathtype1 != PathType.WATER && pathtype1 != PathType.LAVA ? PathType.WALKABLE : PathType.OPEN;
+            if (pathtype1 == PathType.DAMAGE_FIRE) {
+                pathtype = PathType.DAMAGE_FIRE;
+            }
+
+            if (pathtype1 == PathType.DAMAGE_CACTUS) {
+                pathtype = PathType.DAMAGE_CACTUS;
+            }
+
+            if (pathtype1 == PathType.DAMAGE_OTHER) {
+                pathtype = PathType.DAMAGE_OTHER;
+            }
+
+            if (pathtype1 == PathType.STICKY_HONEY) {
+                pathtype = PathType.STICKY_HONEY;
+            }
+        }
+
+        if (pathtype == PathType.WALKABLE) {
+            pathtype = a(iblockaccess, blockposition_mutableblockposition.d(i, j, k), pathtype);
+        }
+
+        return pathtype;
+    }
+
+    public static PathType a(IBlockAccess iblockaccess, BlockPosition.MutableBlockPosition blockposition_mutableblockposition, PathType pathtype) {
+        int i = blockposition_mutableblockposition.getX();
+        int j = blockposition_mutableblockposition.getY();
+        int k = blockposition_mutableblockposition.getZ();
+
+        for (int l = -1; l <= 1; ++l) {
+            for (int i1 = -1; i1 <= 1; ++i1) {
+                for (int j1 = -1; j1 <= 1; ++j1) {
+                    if (l != 0 || j1 != 0) {
+                        blockposition_mutableblockposition.d(i + l, j + i1, k + j1);
+                        IBlockData iblockdata = iblockaccess.getType(blockposition_mutableblockposition);
+
+                        if (iblockdata.a(Blocks.CACTUS)) {
+                            return PathType.DANGER_CACTUS;
+                        }
+
+                        if (iblockdata.a(Blocks.SWEET_BERRY_BUSH)) {
+                            return PathType.DANGER_OTHER;
+                        }
+
+                        if (a(iblockdata)) {
+                            return PathType.DANGER_FIRE;
+                        }
+
+                        if (iblockaccess.getFluid(blockposition_mutableblockposition).a((Tag) TagsFluid.WATER)) {
+                            return PathType.WATER_BORDER;
+                        }
+                    }
+                }
+            }
+        }
+
+        return pathtype;
+    }
+
+    protected static PathType b(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        Block block = iblockdata.getBlock();
+        Material material = iblockdata.getMaterial();
+
+        if (iblockdata.isAir()) {
+            return PathType.OPEN;
+        } else if (!iblockdata.a((Tag) TagsBlock.TRAPDOORS) && !iblockdata.a(Blocks.LILY_PAD)) {
+            if (iblockdata.a(Blocks.CACTUS)) {
+                return PathType.DAMAGE_CACTUS;
+            } else if (iblockdata.a(Blocks.SWEET_BERRY_BUSH)) {
+                return PathType.DAMAGE_OTHER;
+            } else if (iblockdata.a(Blocks.HONEY_BLOCK)) {
+                return PathType.STICKY_HONEY;
+            } else if (iblockdata.a(Blocks.COCOA)) {
+                return PathType.COCOA;
+            } else {
+                Fluid fluid = iblockaccess.getFluid(blockposition);
+
+                return fluid.a((Tag) TagsFluid.WATER) ? PathType.WATER : (fluid.a((Tag) TagsFluid.LAVA) ? PathType.LAVA : (a(iblockdata) ? PathType.DAMAGE_FIRE : (BlockDoor.l(iblockdata) && !(Boolean) iblockdata.get(BlockDoor.OPEN) ? PathType.DOOR_WOOD_CLOSED : (block instanceof BlockDoor && material == Material.ORE && !(Boolean) iblockdata.get(BlockDoor.OPEN) ? PathType.DOOR_IRON_CLOSED : (block instanceof BlockDoor && (Boolean) iblockdata.get(BlockDoor.OPEN) ? PathType.DOOR_OPEN : (block instanceof BlockMinecartTrackAbstract ? PathType.RAIL : (block instanceof BlockLeaves ? PathType.LEAVES : (!block.a((Tag) TagsBlock.FENCES) && !block.a((Tag) TagsBlock.WALLS) && (!(block instanceof BlockFenceGate) || (Boolean) iblockdata.get(BlockFenceGate.OPEN)) ? (!iblockdata.a(iblockaccess, blockposition, PathMode.LAND) ? PathType.BLOCKED : PathType.OPEN) : PathType.FENCE))))))));
+            }
+        } else {
+            return PathType.TRAPDOOR;
+        }
+    }
+
+    private static boolean a(IBlockData iblockdata) {
+        return iblockdata.a((Tag) TagsBlock.FIRE) || iblockdata.a(Blocks.LAVA) || iblockdata.a(Blocks.MAGMA_BLOCK) || BlockCampfire.g(iblockdata);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/storage/WorldData.java b/src/main/java/net/minecraft/world/level/storage/WorldData.java
new file mode 100644
index 0000000000000000000000000000000000000000..81ad90ba93481decdfaa38fc9fa81bca0e402781
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/storage/WorldData.java
@@ -0,0 +1,43 @@
+package net.minecraft.world.level.storage;
+
+import net.minecraft.CrashReportSystemDetails;
+import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.level.GameRules;
+
+public interface WorldData {
+
+    int a();
+
+    int b();
+
+    int c();
+
+    float d();
+
+    long getTime();
+
+    long getDayTime();
+
+    boolean isThundering();
+
+    boolean hasStorm();
+
+    void setStorm(boolean flag);
+
+    boolean isHardcore();
+
+    GameRules q();
+
+    EnumDifficulty getDifficulty();
+
+    boolean isDifficultyLocked();
+
+    default void a(CrashReportSystemDetails crashreportsystemdetails) {
+        crashreportsystemdetails.a("Level spawn location", () -> {
+            return CrashReportSystemDetails.a(this.a(), this.b(), this.c());
+        });
+        crashreportsystemdetails.a("Level time", () -> {
+            return String.format("%d game time, %d day time", this.getTime(), this.getDayTime());
+        });
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/storage/WorldPersistentData.java b/src/main/java/net/minecraft/world/level/storage/WorldPersistentData.java
new file mode 100644
index 0000000000000000000000000000000000000000..45c1d79e0bb2fcffea31513c3d003d28140146b9
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/storage/WorldPersistentData.java
@@ -0,0 +1,204 @@
+package net.minecraft.world.level.storage;
+
+import com.google.common.collect.Maps;
+import com.mojang.datafixers.DataFixer;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.PushbackInputStream;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.function.Supplier;
+import javax.annotation.Nullable;
+import net.minecraft.SharedConstants;
+import net.minecraft.nbt.GameProfileSerializer;
+import net.minecraft.nbt.NBTCompressedStreamTools;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.util.datafix.DataFixTypes;
+import net.minecraft.world.level.saveddata.PersistentBase;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class WorldPersistentData {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    public final Map<String, PersistentBase> data = Maps.newHashMap();
+    private final DataFixer c;
+    private final File d;
+
+    public WorldPersistentData(File file, DataFixer datafixer) {
+        this.c = datafixer;
+        this.d = file;
+    }
+
+    private File a(String s) {
+        return new File(this.d, s + ".dat");
+    }
+
+    public <T extends PersistentBase> T a(Supplier<T> supplier, String s) {
+        T t0 = this.b(supplier, s);
+
+        if (t0 != null) {
+            return t0;
+        } else {
+            T t1 = (PersistentBase) supplier.get();
+
+            this.a(t1);
+            return t1;
+        }
+    }
+
+    @Nullable
+    public <T extends PersistentBase> T b(Supplier<T> supplier, String s) {
+        PersistentBase persistentbase = (PersistentBase) this.data.get(s);
+
+        if (persistentbase == null && !this.data.containsKey(s)) {
+            persistentbase = this.c(supplier, s);
+            this.data.put(s, persistentbase);
+        }
+
+        return persistentbase;
+    }
+
+    @Nullable
+    private <T extends PersistentBase> T c(Supplier<T> supplier, String s) {
+        try {
+            File file = this.a(s);
+
+            if (file.exists()) {
+                T t0 = (PersistentBase) supplier.get();
+                NBTTagCompound nbttagcompound = this.a(s, SharedConstants.getGameVersion().getWorldVersion());
+
+                t0.a(nbttagcompound.getCompound("data"));
+                return t0;
+            }
+        } catch (Exception exception) {
+            WorldPersistentData.LOGGER.error("Error loading saved data: {}", s, exception);
+        }
+
+        return null;
+    }
+
+    public void a(PersistentBase persistentbase) {
+        this.data.put(persistentbase.getId(), persistentbase);
+    }
+
+    public NBTTagCompound a(String s, int i) throws IOException {
+        File file = this.a(s);
+        FileInputStream fileinputstream = new FileInputStream(file);
+        Throwable throwable = null;
+
+        Object object;
+
+        try {
+            PushbackInputStream pushbackinputstream = new PushbackInputStream(fileinputstream, 2);
+            Throwable throwable1 = null;
+
+            try {
+                NBTTagCompound nbttagcompound;
+
+                if (this.a(pushbackinputstream)) {
+                    nbttagcompound = NBTCompressedStreamTools.a((InputStream) pushbackinputstream);
+                } else {
+                    DataInputStream datainputstream = new DataInputStream(pushbackinputstream);
+
+                    object = null;
+
+                    try {
+                        nbttagcompound = NBTCompressedStreamTools.a((DataInput) datainputstream);
+                    } catch (Throwable throwable2) {
+                        object = throwable2;
+                        throw throwable2;
+                    } finally {
+                        if (datainputstream != null) {
+                            if (object != null) {
+                                try {
+                                    datainputstream.close();
+                                } catch (Throwable throwable3) {
+                                    ((Throwable) object).addSuppressed(throwable3);
+                                }
+                            } else {
+                                datainputstream.close();
+                            }
+                        }
+
+                    }
+                }
+
+                int j = nbttagcompound.hasKeyOfType("DataVersion", 99) ? nbttagcompound.getInt("DataVersion") : 1343;
+
+                object = GameProfileSerializer.a(this.c, DataFixTypes.SAVED_DATA, nbttagcompound, j, i);
+            } catch (Throwable throwable4) {
+                throwable1 = throwable4;
+                throw throwable4;
+            } finally {
+                if (pushbackinputstream != null) {
+                    if (throwable1 != null) {
+                        try {
+                            pushbackinputstream.close();
+                        } catch (Throwable throwable5) {
+                            throwable1.addSuppressed(throwable5);
+                        }
+                    } else {
+                        pushbackinputstream.close();
+                    }
+                }
+
+            }
+        } catch (Throwable throwable6) {
+            throwable = throwable6;
+            throw throwable6;
+        } finally {
+            if (fileinputstream != null) {
+                if (throwable != null) {
+                    try {
+                        fileinputstream.close();
+                    } catch (Throwable throwable7) {
+                        throwable.addSuppressed(throwable7);
+                    }
+                } else {
+                    fileinputstream.close();
+                }
+            }
+
+        }
+
+        return (NBTTagCompound) object;
+    }
+
+    private boolean a(PushbackInputStream pushbackinputstream) throws IOException {
+        byte[] abyte = new byte[2];
+        boolean flag = false;
+        int i = pushbackinputstream.read(abyte, 0, 2);
+
+        if (i == 2) {
+            int j = (abyte[1] & 255) << 8 | abyte[0] & 255;
+
+            if (j == 35615) {
+                flag = true;
+            }
+        }
+
+        if (i != 0) {
+            pushbackinputstream.unread(abyte, 0, i);
+        }
+
+        return flag;
+    }
+
+    public void a() {
+        Iterator iterator = this.data.values().iterator();
+
+        while (iterator.hasNext()) {
+            PersistentBase persistentbase = (PersistentBase) iterator.next();
+
+            if (persistentbase != null) {
+                persistentbase.a(this.a(persistentbase.getId()));
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/entries/LootSelectorEntry.java b/src/main/java/net/minecraft/world/level/storage/loot/entries/LootSelectorEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e3fe138fc11bd7e648296922c651cecaab8e71e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/storage/loot/entries/LootSelectorEntry.java
@@ -0,0 +1,162 @@
+package net.minecraft.world.level.storage.loot.entries;
+
+import com.google.common.collect.Lists;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSerializationContext;
+import java.util.List;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import net.minecraft.util.ChatDeserializer;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.storage.loot.LootCollector;
+import net.minecraft.world.level.storage.loot.LootTableInfo;
+import net.minecraft.world.level.storage.loot.functions.LootItemFunction;
+import net.minecraft.world.level.storage.loot.functions.LootItemFunctionUser;
+import net.minecraft.world.level.storage.loot.functions.LootItemFunctions;
+import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
+import org.apache.commons.lang3.ArrayUtils;
+
+public abstract class LootSelectorEntry extends LootEntryAbstract {
+
+    protected final int c;
+    protected final int e;
+    protected final LootItemFunction[] f;
+    private final BiFunction<ItemStack, LootTableInfo, ItemStack> g;
+    private final LootEntry h = new LootSelectorEntry.c() {
+        @Override
+        public void a(Consumer<ItemStack> consumer, LootTableInfo loottableinfo) {
+            LootSelectorEntry.this.a(LootItemFunction.a(LootSelectorEntry.this.g, consumer, loottableinfo), loottableinfo);
+        }
+    };
+
+    protected LootSelectorEntry(int i, int j, LootItemCondition[] alootitemcondition, LootItemFunction[] alootitemfunction) {
+        super(alootitemcondition);
+        this.c = i;
+        this.e = j;
+        this.f = alootitemfunction;
+        this.g = LootItemFunctions.a(alootitemfunction);
+    }
+
+    @Override
+    public void a(LootCollector lootcollector) {
+        super.a(lootcollector);
+
+        for (int i = 0; i < this.f.length; ++i) {
+            this.f[i].a(lootcollector.b(".functions[" + i + "]"));
+        }
+
+    }
+
+    protected abstract void a(Consumer<ItemStack> consumer, LootTableInfo loottableinfo);
+
+    @Override
+    public boolean expand(LootTableInfo loottableinfo, Consumer<LootEntry> consumer) {
+        if (this.a(loottableinfo)) {
+            consumer.accept(this.h);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public static LootSelectorEntry.a<?> a(LootSelectorEntry.d lootselectorentry_d) {
+        return new LootSelectorEntry.b(lootselectorentry_d);
+    }
+
+    public abstract static class e<T extends LootSelectorEntry> extends LootEntryAbstract.Serializer<T> {
+
+        public e() {}
+
+        public void a(JsonObject jsonobject, T t0, JsonSerializationContext jsonserializationcontext) {
+            if (t0.c != 1) {
+                jsonobject.addProperty("weight", t0.c);
+            }
+
+            if (t0.e != 0) {
+                jsonobject.addProperty("quality", t0.e);
+            }
+
+            if (!ArrayUtils.isEmpty(t0.f)) {
+                jsonobject.add("functions", jsonserializationcontext.serialize(t0.f));
+            }
+
+        }
+
+        @Override
+        public final T deserializeType(JsonObject jsonobject, JsonDeserializationContext jsondeserializationcontext, LootItemCondition[] alootitemcondition) {
+            int i = ChatDeserializer.a(jsonobject, "weight", (int) 1);
+            int j = ChatDeserializer.a(jsonobject, "quality", (int) 0);
+            LootItemFunction[] alootitemfunction = (LootItemFunction[]) ChatDeserializer.a(jsonobject, "functions", new LootItemFunction[0], jsondeserializationcontext, LootItemFunction[].class);
+
+            return this.b(jsonobject, jsondeserializationcontext, i, j, alootitemcondition, alootitemfunction);
+        }
+
+        protected abstract T b(JsonObject jsonobject, JsonDeserializationContext jsondeserializationcontext, int i, int j, LootItemCondition[] alootitemcondition, LootItemFunction[] alootitemfunction);
+    }
+
+    static class b extends LootSelectorEntry.a<LootSelectorEntry.b> {
+
+        private final LootSelectorEntry.d c;
+
+        public b(LootSelectorEntry.d lootselectorentry_d) {
+            this.c = lootselectorentry_d;
+        }
+
+        @Override
+        protected LootSelectorEntry.b d() {
+            return this;
+        }
+
+        @Override
+        public LootEntryAbstract b() {
+            return this.c.build(this.a, this.b, this.f(), this.a());
+        }
+    }
+
+    @FunctionalInterface
+    public interface d {
+
+        LootSelectorEntry build(int i, int j, LootItemCondition[] alootitemcondition, LootItemFunction[] alootitemfunction);
+    }
+
+    public abstract static class a<T extends LootSelectorEntry.a<T>> extends LootEntryAbstract.a<T> implements LootItemFunctionUser<T> {
+
+        protected int a = 1;
+        protected int b = 0;
+        private final List<LootItemFunction> c = Lists.newArrayList();
+
+        public a() {}
+
+        @Override
+        public T b(LootItemFunction.a lootitemfunction_a) {
+            this.c.add(lootitemfunction_a.b());
+            return (LootSelectorEntry.a) this.d();
+        }
+
+        protected LootItemFunction[] a() {
+            return (LootItemFunction[]) this.c.toArray(new LootItemFunction[0]);
+        }
+
+        public T a(int i) {
+            this.a = i;
+            return (LootSelectorEntry.a) this.d();
+        }
+
+        public T b(int i) {
+            this.b = i;
+            return (LootSelectorEntry.a) this.d();
+        }
+    }
+
+    public abstract class c implements LootEntry {
+
+        protected c() {}
+
+        @Override
+        public int a(float f) {
+            return Math.max(MathHelper.d((float) LootSelectorEntry.this.c + (float) LootSelectorEntry.this.e * f), 0);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/functions/LootItemFunctionExplorationMap.java b/src/main/java/net/minecraft/world/level/storage/loot/functions/LootItemFunctionExplorationMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..f516e7440ed306b1ace9b35ae82f70ca69df51f3
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/storage/loot/functions/LootItemFunctionExplorationMap.java
@@ -0,0 +1,194 @@
+package net.minecraft.world.level.storage.loot.functions;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSerializationContext;
+import java.util.Locale;
+import java.util.Set;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.network.chat.ChatMessage;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.util.ChatDeserializer;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.ItemWorldMap;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.levelgen.feature.StructureGenerator;
+import net.minecraft.world.level.saveddata.maps.MapIcon;
+import net.minecraft.world.level.saveddata.maps.WorldMap;
+import net.minecraft.world.level.storage.loot.LootTableInfo;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParameter;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParameters;
+import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
+import net.minecraft.world.phys.Vec3D;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class LootItemFunctionExplorationMap extends LootItemFunctionConditional {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    public static final StructureGenerator<?> a = StructureGenerator.BURIED_TREASURE;
+    public static final MapIcon.Type b = MapIcon.Type.MANSION;
+    private final StructureGenerator<?> e;
+    private final MapIcon.Type f;
+    private final byte g;
+    private final int h;
+    private final boolean i;
+
+    private LootItemFunctionExplorationMap(LootItemCondition[] alootitemcondition, StructureGenerator<?> structuregenerator, MapIcon.Type mapicon_type, byte b0, int i, boolean flag) {
+        super(alootitemcondition);
+        this.e = structuregenerator;
+        this.f = mapicon_type;
+        this.g = b0;
+        this.h = i;
+        this.i = flag;
+    }
+
+    @Override
+    public LootItemFunctionType b() {
+        return LootItemFunctions.k;
+    }
+
+    @Override
+    public Set<LootContextParameter<?>> a() {
+        return ImmutableSet.of(LootContextParameters.ORIGIN);
+    }
+
+    @Override
+    public ItemStack a(ItemStack itemstack, LootTableInfo loottableinfo) {
+        if (itemstack.getItem() != Items.MAP) {
+            return itemstack;
+        } else {
+            Vec3D vec3d = (Vec3D) loottableinfo.getContextParameter(LootContextParameters.ORIGIN);
+
+            if (vec3d != null) {
+                WorldServer worldserver = loottableinfo.getWorld();
+                BlockPosition blockposition = worldserver.a(this.e, new BlockPosition(vec3d), this.h, this.i);
+
+                if (blockposition != null) {
+                    ItemStack itemstack1 = ItemWorldMap.createFilledMapView(worldserver, blockposition.getX(), blockposition.getZ(), this.g, true, true);
+
+                    ItemWorldMap.applySepiaFilter(worldserver, itemstack1);
+                    WorldMap.decorateMap(itemstack1, blockposition, "+", this.f);
+                    itemstack1.a((IChatBaseComponent) (new ChatMessage("filled_map." + this.e.i().toLowerCase(Locale.ROOT))));
+                    return itemstack1;
+                }
+            }
+
+            return itemstack;
+        }
+    }
+
+    public static LootItemFunctionExplorationMap.a c() {
+        return new LootItemFunctionExplorationMap.a();
+    }
+
+    public static class b extends LootItemFunctionConditional.c<LootItemFunctionExplorationMap> {
+
+        public b() {}
+
+        public void a(JsonObject jsonobject, LootItemFunctionExplorationMap lootitemfunctionexplorationmap, JsonSerializationContext jsonserializationcontext) {
+            super.a(jsonobject, (LootItemFunctionConditional) lootitemfunctionexplorationmap, jsonserializationcontext);
+            if (!lootitemfunctionexplorationmap.e.equals(LootItemFunctionExplorationMap.a)) {
+                jsonobject.add("destination", jsonserializationcontext.serialize(lootitemfunctionexplorationmap.e.i()));
+            }
+
+            if (lootitemfunctionexplorationmap.f != LootItemFunctionExplorationMap.b) {
+                jsonobject.add("decoration", jsonserializationcontext.serialize(lootitemfunctionexplorationmap.f.toString().toLowerCase(Locale.ROOT)));
+            }
+
+            if (lootitemfunctionexplorationmap.g != 2) {
+                jsonobject.addProperty("zoom", lootitemfunctionexplorationmap.g);
+            }
+
+            if (lootitemfunctionexplorationmap.h != 50) {
+                jsonobject.addProperty("search_radius", lootitemfunctionexplorationmap.h);
+            }
+
+            if (!lootitemfunctionexplorationmap.i) {
+                jsonobject.addProperty("skip_existing_chunks", lootitemfunctionexplorationmap.i);
+            }
+
+        }
+
+        @Override
+        public LootItemFunctionExplorationMap b(JsonObject jsonobject, JsonDeserializationContext jsondeserializationcontext, LootItemCondition[] alootitemcondition) {
+            StructureGenerator<?> structuregenerator = a(jsonobject);
+            String s = jsonobject.has("decoration") ? ChatDeserializer.h(jsonobject, "decoration") : "mansion";
+            MapIcon.Type mapicon_type = LootItemFunctionExplorationMap.b;
+
+            try {
+                mapicon_type = MapIcon.Type.valueOf(s.toUpperCase(Locale.ROOT));
+            } catch (IllegalArgumentException illegalargumentexception) {
+                LootItemFunctionExplorationMap.LOGGER.error("Error while parsing loot table decoration entry. Found {}. Defaulting to " + LootItemFunctionExplorationMap.b, s);
+            }
+
+            byte b0 = ChatDeserializer.a(jsonobject, "zoom", (byte) 2);
+            int i = ChatDeserializer.a(jsonobject, "search_radius", (int) 50);
+            boolean flag = ChatDeserializer.a(jsonobject, "skip_existing_chunks", true);
+
+            return new LootItemFunctionExplorationMap(alootitemcondition, structuregenerator, mapicon_type, b0, i, flag);
+        }
+
+        private static StructureGenerator<?> a(JsonObject jsonobject) {
+            if (jsonobject.has("destination")) {
+                String s = ChatDeserializer.h(jsonobject, "destination");
+                StructureGenerator<?> structuregenerator = (StructureGenerator) StructureGenerator.a.get(s.toLowerCase(Locale.ROOT));
+
+                if (structuregenerator != null) {
+                    return structuregenerator;
+                }
+            }
+
+            return LootItemFunctionExplorationMap.a;
+        }
+    }
+
+    public static class a extends LootItemFunctionConditional.a<LootItemFunctionExplorationMap.a> {
+
+        private StructureGenerator<?> a;
+        private MapIcon.Type b;
+        private byte c;
+        private int d;
+        private boolean e;
+
+        public a() {
+            this.a = LootItemFunctionExplorationMap.a;
+            this.b = LootItemFunctionExplorationMap.b;
+            this.c = 2;
+            this.d = 50;
+            this.e = true;
+        }
+
+        @Override
+        protected LootItemFunctionExplorationMap.a d() {
+            return this;
+        }
+
+        public LootItemFunctionExplorationMap.a a(StructureGenerator<?> structuregenerator) {
+            this.a = structuregenerator;
+            return this;
+        }
+
+        public LootItemFunctionExplorationMap.a a(MapIcon.Type mapicon_type) {
+            this.b = mapicon_type;
+            return this;
+        }
+
+        public LootItemFunctionExplorationMap.a a(byte b0) {
+            this.c = b0;
+            return this;
+        }
+
+        public LootItemFunctionExplorationMap.a a(boolean flag) {
+            this.e = flag;
+            return this;
+        }
+
+        @Override
+        public LootItemFunction b() {
+            return new LootItemFunctionExplorationMap(this.g(), this.a, this.b, this.c, this.d, this.e);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/phys/AxisAlignedBB.java b/src/main/java/net/minecraft/world/phys/AxisAlignedBB.java
new file mode 100644
index 0000000000000000000000000000000000000000..633a484cebc99f4a2f071b7f84b0b63d0ec3f985
--- /dev/null
+++ b/src/main/java/net/minecraft/world/phys/AxisAlignedBB.java
@@ -0,0 +1,324 @@
+package net.minecraft.world.phys;
+
+import java.util.Iterator;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.level.levelgen.structure.StructureBoundingBox;
+
+public class AxisAlignedBB {
+
+    public final double minX;
+    public final double minY;
+    public final double minZ;
+    public final double maxX;
+    public final double maxY;
+    public final double maxZ;
+
+    public AxisAlignedBB(double d0, double d1, double d2, double d3, double d4, double d5) {
+        this.minX = Math.min(d0, d3);
+        this.minY = Math.min(d1, d4);
+        this.minZ = Math.min(d2, d5);
+        this.maxX = Math.max(d0, d3);
+        this.maxY = Math.max(d1, d4);
+        this.maxZ = Math.max(d2, d5);
+    }
+
+    public AxisAlignedBB(BlockPosition blockposition) {
+        this((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), (double) (blockposition.getX() + 1), (double) (blockposition.getY() + 1), (double) (blockposition.getZ() + 1));
+    }
+
+    public AxisAlignedBB(BlockPosition blockposition, BlockPosition blockposition1) {
+        this((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), (double) blockposition1.getX(), (double) blockposition1.getY(), (double) blockposition1.getZ());
+    }
+
+    public AxisAlignedBB(Vec3D vec3d, Vec3D vec3d1) {
+        this(vec3d.x, vec3d.y, vec3d.z, vec3d1.x, vec3d1.y, vec3d1.z);
+    }
+
+    public static AxisAlignedBB a(StructureBoundingBox structureboundingbox) {
+        return new AxisAlignedBB((double) structureboundingbox.a, (double) structureboundingbox.b, (double) structureboundingbox.c, (double) (structureboundingbox.d + 1), (double) (structureboundingbox.e + 1), (double) (structureboundingbox.f + 1));
+    }
+
+    public static AxisAlignedBB a(Vec3D vec3d) {
+        return new AxisAlignedBB(vec3d.x, vec3d.y, vec3d.z, vec3d.x + 1.0D, vec3d.y + 1.0D, vec3d.z + 1.0D);
+    }
+
+    public double a(EnumDirection.EnumAxis enumdirection_enumaxis) {
+        return enumdirection_enumaxis.a(this.minX, this.minY, this.minZ);
+    }
+
+    public double b(EnumDirection.EnumAxis enumdirection_enumaxis) {
+        return enumdirection_enumaxis.a(this.maxX, this.maxY, this.maxZ);
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof AxisAlignedBB)) {
+            return false;
+        } else {
+            AxisAlignedBB axisalignedbb = (AxisAlignedBB) object;
+
+            return Double.compare(axisalignedbb.minX, this.minX) != 0 ? false : (Double.compare(axisalignedbb.minY, this.minY) != 0 ? false : (Double.compare(axisalignedbb.minZ, this.minZ) != 0 ? false : (Double.compare(axisalignedbb.maxX, this.maxX) != 0 ? false : (Double.compare(axisalignedbb.maxY, this.maxY) != 0 ? false : Double.compare(axisalignedbb.maxZ, this.maxZ) == 0))));
+        }
+    }
+
+    public int hashCode() {
+        long i = Double.doubleToLongBits(this.minX);
+        int j = (int) (i ^ i >>> 32);
+
+        i = Double.doubleToLongBits(this.minY);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.minZ);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.maxX);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.maxY);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.maxZ);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        return j;
+    }
+
+    public AxisAlignedBB a(double d0, double d1, double d2) {
+        double d3 = this.minX;
+        double d4 = this.minY;
+        double d5 = this.minZ;
+        double d6 = this.maxX;
+        double d7 = this.maxY;
+        double d8 = this.maxZ;
+
+        if (d0 < 0.0D) {
+            d3 -= d0;
+        } else if (d0 > 0.0D) {
+            d6 -= d0;
+        }
+
+        if (d1 < 0.0D) {
+            d4 -= d1;
+        } else if (d1 > 0.0D) {
+            d7 -= d1;
+        }
+
+        if (d2 < 0.0D) {
+            d5 -= d2;
+        } else if (d2 > 0.0D) {
+            d8 -= d2;
+        }
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public AxisAlignedBB b(Vec3D vec3d) {
+        return this.b(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public AxisAlignedBB b(double d0, double d1, double d2) {
+        double d3 = this.minX;
+        double d4 = this.minY;
+        double d5 = this.minZ;
+        double d6 = this.maxX;
+        double d7 = this.maxY;
+        double d8 = this.maxZ;
+
+        if (d0 < 0.0D) {
+            d3 += d0;
+        } else if (d0 > 0.0D) {
+            d6 += d0;
+        }
+
+        if (d1 < 0.0D) {
+            d4 += d1;
+        } else if (d1 > 0.0D) {
+            d7 += d1;
+        }
+
+        if (d2 < 0.0D) {
+            d5 += d2;
+        } else if (d2 > 0.0D) {
+            d8 += d2;
+        }
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public AxisAlignedBB grow(double d0, double d1, double d2) {
+        double d3 = this.minX - d0;
+        double d4 = this.minY - d1;
+        double d5 = this.minZ - d2;
+        double d6 = this.maxX + d0;
+        double d7 = this.maxY + d1;
+        double d8 = this.maxZ + d2;
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public AxisAlignedBB g(double d0) {
+        return this.grow(d0, d0, d0);
+    }
+
+    public AxisAlignedBB a(AxisAlignedBB axisalignedbb) {
+        double d0 = Math.max(this.minX, axisalignedbb.minX);
+        double d1 = Math.max(this.minY, axisalignedbb.minY);
+        double d2 = Math.max(this.minZ, axisalignedbb.minZ);
+        double d3 = Math.min(this.maxX, axisalignedbb.maxX);
+        double d4 = Math.min(this.maxY, axisalignedbb.maxY);
+        double d5 = Math.min(this.maxZ, axisalignedbb.maxZ);
+
+        return new AxisAlignedBB(d0, d1, d2, d3, d4, d5);
+    }
+
+    public AxisAlignedBB b(AxisAlignedBB axisalignedbb) {
+        double d0 = Math.min(this.minX, axisalignedbb.minX);
+        double d1 = Math.min(this.minY, axisalignedbb.minY);
+        double d2 = Math.min(this.minZ, axisalignedbb.minZ);
+        double d3 = Math.max(this.maxX, axisalignedbb.maxX);
+        double d4 = Math.max(this.maxY, axisalignedbb.maxY);
+        double d5 = Math.max(this.maxZ, axisalignedbb.maxZ);
+
+        return new AxisAlignedBB(d0, d1, d2, d3, d4, d5);
+    }
+
+    public AxisAlignedBB d(double d0, double d1, double d2) {
+        return new AxisAlignedBB(this.minX + d0, this.minY + d1, this.minZ + d2, this.maxX + d0, this.maxY + d1, this.maxZ + d2);
+    }
+
+    public AxisAlignedBB a(BlockPosition blockposition) {
+        return new AxisAlignedBB(this.minX + (double) blockposition.getX(), this.minY + (double) blockposition.getY(), this.minZ + (double) blockposition.getZ(), this.maxX + (double) blockposition.getX(), this.maxY + (double) blockposition.getY(), this.maxZ + (double) blockposition.getZ());
+    }
+
+    public AxisAlignedBB c(Vec3D vec3d) {
+        return this.d(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public boolean c(AxisAlignedBB axisalignedbb) {
+        return this.a(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.maxX, axisalignedbb.maxY, axisalignedbb.maxZ);
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3, double d4, double d5) {
+        return this.minX < d3 && this.maxX > d0 && this.minY < d4 && this.maxY > d1 && this.minZ < d5 && this.maxZ > d2;
+    }
+
+    public boolean d(Vec3D vec3d) {
+        return this.e(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public boolean e(double d0, double d1, double d2) {
+        return d0 >= this.minX && d0 < this.maxX && d1 >= this.minY && d1 < this.maxY && d2 >= this.minZ && d2 < this.maxZ;
+    }
+
+    public double a() {
+        double d0 = this.b();
+        double d1 = this.c();
+        double d2 = this.d();
+
+        return (d0 + d1 + d2) / 3.0D;
+    }
+
+    public double b() {
+        return this.maxX - this.minX;
+    }
+
+    public double c() {
+        return this.maxY - this.minY;
+    }
+
+    public double d() {
+        return this.maxZ - this.minZ;
+    }
+
+    public AxisAlignedBB shrink(double d0) {
+        return this.g(-d0);
+    }
+
+    public Optional<Vec3D> b(Vec3D vec3d, Vec3D vec3d1) {
+        double[] adouble = new double[]{1.0D};
+        double d0 = vec3d1.x - vec3d.x;
+        double d1 = vec3d1.y - vec3d.y;
+        double d2 = vec3d1.z - vec3d.z;
+        EnumDirection enumdirection = a(this, vec3d, adouble, (EnumDirection) null, d0, d1, d2);
+
+        if (enumdirection == null) {
+            return Optional.empty();
+        } else {
+            double d3 = adouble[0];
+
+            return Optional.of(vec3d.add(d3 * d0, d3 * d1, d3 * d2));
+        }
+    }
+
+    @Nullable
+    public static MovingObjectPositionBlock a(Iterable<AxisAlignedBB> iterable, Vec3D vec3d, Vec3D vec3d1, BlockPosition blockposition) {
+        double[] adouble = new double[]{1.0D};
+        EnumDirection enumdirection = null;
+        double d0 = vec3d1.x - vec3d.x;
+        double d1 = vec3d1.y - vec3d.y;
+        double d2 = vec3d1.z - vec3d.z;
+
+        AxisAlignedBB axisalignedbb;
+
+        for (Iterator iterator = iterable.iterator(); iterator.hasNext(); enumdirection = a(axisalignedbb.a(blockposition), vec3d, adouble, enumdirection, d0, d1, d2)) {
+            axisalignedbb = (AxisAlignedBB) iterator.next();
+        }
+
+        if (enumdirection == null) {
+            return null;
+        } else {
+            double d3 = adouble[0];
+
+            return new MovingObjectPositionBlock(vec3d.add(d3 * d0, d3 * d1, d3 * d2), enumdirection, blockposition, false);
+        }
+    }
+
+    @Nullable
+    private static EnumDirection a(AxisAlignedBB axisalignedbb, Vec3D vec3d, double[] adouble, @Nullable EnumDirection enumdirection, double d0, double d1, double d2) {
+        if (d0 > 1.0E-7D) {
+            enumdirection = a(adouble, enumdirection, d0, d1, d2, axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.maxY, axisalignedbb.minZ, axisalignedbb.maxZ, EnumDirection.WEST, vec3d.x, vec3d.y, vec3d.z);
+        } else if (d0 < -1.0E-7D) {
+            enumdirection = a(adouble, enumdirection, d0, d1, d2, axisalignedbb.maxX, axisalignedbb.minY, axisalignedbb.maxY, axisalignedbb.minZ, axisalignedbb.maxZ, EnumDirection.EAST, vec3d.x, vec3d.y, vec3d.z);
+        }
+
+        if (d1 > 1.0E-7D) {
+            enumdirection = a(adouble, enumdirection, d1, d2, d0, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.maxZ, axisalignedbb.minX, axisalignedbb.maxX, EnumDirection.DOWN, vec3d.y, vec3d.z, vec3d.x);
+        } else if (d1 < -1.0E-7D) {
+            enumdirection = a(adouble, enumdirection, d1, d2, d0, axisalignedbb.maxY, axisalignedbb.minZ, axisalignedbb.maxZ, axisalignedbb.minX, axisalignedbb.maxX, EnumDirection.UP, vec3d.y, vec3d.z, vec3d.x);
+        }
+
+        if (d2 > 1.0E-7D) {
+            enumdirection = a(adouble, enumdirection, d2, d0, d1, axisalignedbb.minZ, axisalignedbb.minX, axisalignedbb.maxX, axisalignedbb.minY, axisalignedbb.maxY, EnumDirection.NORTH, vec3d.z, vec3d.x, vec3d.y);
+        } else if (d2 < -1.0E-7D) {
+            enumdirection = a(adouble, enumdirection, d2, d0, d1, axisalignedbb.maxZ, axisalignedbb.minX, axisalignedbb.maxX, axisalignedbb.minY, axisalignedbb.maxY, EnumDirection.SOUTH, vec3d.z, vec3d.x, vec3d.y);
+        }
+
+        return enumdirection;
+    }
+
+    @Nullable
+    private static EnumDirection a(double[] adouble, @Nullable EnumDirection enumdirection, double d0, double d1, double d2, double d3, double d4, double d5, double d6, double d7, EnumDirection enumdirection1, double d8, double d9, double d10) {
+        double d11 = (d3 - d8) / d0;
+        double d12 = d9 + d11 * d1;
+        double d13 = d10 + d11 * d2;
+
+        if (0.0D < d11 && d11 < adouble[0] && d4 - 1.0E-7D < d12 && d12 < d5 + 1.0E-7D && d6 - 1.0E-7D < d13 && d13 < d7 + 1.0E-7D) {
+            adouble[0] = d11;
+            return enumdirection1;
+        } else {
+            return enumdirection;
+        }
+    }
+
+    public String toString() {
+        return "AABB[" + this.minX + ", " + this.minY + ", " + this.minZ + "] -> [" + this.maxX + ", " + this.maxY + ", " + this.maxZ + "]";
+    }
+
+    public Vec3D f() {
+        return new Vec3D(MathHelper.d(0.5D, this.minX, this.maxX), MathHelper.d(0.5D, this.minY, this.maxY), MathHelper.d(0.5D, this.minZ, this.maxZ));
+    }
+
+    public static AxisAlignedBB g(double d0, double d1, double d2) {
+        return new AxisAlignedBB(-d0 / 2.0D, -d1 / 2.0D, -d2 / 2.0D, d0 / 2.0D, d1 / 2.0D, d2 / 2.0D);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/phys/Vec3D.java b/src/main/java/net/minecraft/world/phys/Vec3D.java
new file mode 100644
index 0000000000000000000000000000000000000000..b71e119eed6fa283d99dc033144c8be7b336d9c4
--- /dev/null
+++ b/src/main/java/net/minecraft/world/phys/Vec3D.java
@@ -0,0 +1,198 @@
+package net.minecraft.world.phys;
+
+import com.mojang.math.Vector3fa;
+import java.util.EnumSet;
+import net.minecraft.core.BaseBlockPosition;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.core.IPosition;
+import net.minecraft.util.MathHelper;
+
+public class Vec3D implements IPosition {
+
+    public static final Vec3D ORIGIN = new Vec3D(0.0D, 0.0D, 0.0D);
+    public final double x;
+    public final double y;
+    public final double z;
+
+    public static Vec3D a(BaseBlockPosition baseblockposition) {
+        return new Vec3D((double) baseblockposition.getX() + 0.5D, (double) baseblockposition.getY() + 0.5D, (double) baseblockposition.getZ() + 0.5D);
+    }
+
+    public static Vec3D b(BaseBlockPosition baseblockposition) {
+        return new Vec3D((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ());
+    }
+
+    public static Vec3D c(BaseBlockPosition baseblockposition) {
+        return new Vec3D((double) baseblockposition.getX() + 0.5D, (double) baseblockposition.getY(), (double) baseblockposition.getZ() + 0.5D);
+    }
+
+    public static Vec3D a(BaseBlockPosition baseblockposition, double d0) {
+        return new Vec3D((double) baseblockposition.getX() + 0.5D, (double) baseblockposition.getY() + d0, (double) baseblockposition.getZ() + 0.5D);
+    }
+
+    public Vec3D(double d0, double d1, double d2) {
+        this.x = d0;
+        this.y = d1;
+        this.z = d2;
+    }
+
+    public Vec3D(Vector3fa vector3fa) {
+        this((double) vector3fa.a(), (double) vector3fa.b(), (double) vector3fa.c());
+    }
+
+    public Vec3D a(Vec3D vec3d) {
+        return new Vec3D(vec3d.x - this.x, vec3d.y - this.y, vec3d.z - this.z);
+    }
+
+    public Vec3D d() {
+        double d0 = (double) MathHelper.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
+
+        return d0 < 1.0E-4D ? Vec3D.ORIGIN : new Vec3D(this.x / d0, this.y / d0, this.z / d0);
+    }
+
+    public double b(Vec3D vec3d) {
+        return this.x * vec3d.x + this.y * vec3d.y + this.z * vec3d.z;
+    }
+
+    public Vec3D c(Vec3D vec3d) {
+        return new Vec3D(this.y * vec3d.z - this.z * vec3d.y, this.z * vec3d.x - this.x * vec3d.z, this.x * vec3d.y - this.y * vec3d.x);
+    }
+
+    public Vec3D d(Vec3D vec3d) {
+        return this.a(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public Vec3D a(double d0, double d1, double d2) {
+        return this.add(-d0, -d1, -d2);
+    }
+
+    public Vec3D e(Vec3D vec3d) {
+        return this.add(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public Vec3D add(double d0, double d1, double d2) {
+        return new Vec3D(this.x + d0, this.y + d1, this.z + d2);
+    }
+
+    public boolean a(IPosition iposition, double d0) {
+        return this.c(iposition.getX(), iposition.getY(), iposition.getZ()) < d0 * d0;
+    }
+
+    public double f(Vec3D vec3d) {
+        double d0 = vec3d.x - this.x;
+        double d1 = vec3d.y - this.y;
+        double d2 = vec3d.z - this.z;
+
+        return (double) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+    }
+
+    public double distanceSquared(Vec3D vec3d) {
+        double d0 = vec3d.x - this.x;
+        double d1 = vec3d.y - this.y;
+        double d2 = vec3d.z - this.z;
+
+        return d0 * d0 + d1 * d1 + d2 * d2;
+    }
+
+    public double c(double d0, double d1, double d2) {
+        double d3 = d0 - this.x;
+        double d4 = d1 - this.y;
+        double d5 = d2 - this.z;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public Vec3D a(double d0) {
+        return this.d(d0, d0, d0);
+    }
+
+    public Vec3D h(Vec3D vec3d) {
+        return this.d(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public Vec3D d(double d0, double d1, double d2) {
+        return new Vec3D(this.x * d0, this.y * d1, this.z * d2);
+    }
+
+    public double f() {
+        return (double) MathHelper.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
+    }
+
+    public double g() {
+        return this.x * this.x + this.y * this.y + this.z * this.z;
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof Vec3D)) {
+            return false;
+        } else {
+            Vec3D vec3d = (Vec3D) object;
+
+            return Double.compare(vec3d.x, this.x) != 0 ? false : (Double.compare(vec3d.y, this.y) != 0 ? false : Double.compare(vec3d.z, this.z) == 0);
+        }
+    }
+
+    public int hashCode() {
+        long i = Double.doubleToLongBits(this.x);
+        int j = (int) (i ^ i >>> 32);
+
+        i = Double.doubleToLongBits(this.y);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.z);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        return j;
+    }
+
+    public String toString() {
+        return "(" + this.x + ", " + this.y + ", " + this.z + ")";
+    }
+
+    public Vec3D a(float f) {
+        float f1 = MathHelper.cos(f);
+        float f2 = MathHelper.sin(f);
+        double d0 = this.x;
+        double d1 = this.y * (double) f1 + this.z * (double) f2;
+        double d2 = this.z * (double) f1 - this.y * (double) f2;
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    public Vec3D b(float f) {
+        float f1 = MathHelper.cos(f);
+        float f2 = MathHelper.sin(f);
+        double d0 = this.x * (double) f1 + this.z * (double) f2;
+        double d1 = this.y;
+        double d2 = this.z * (double) f1 - this.x * (double) f2;
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    public Vec3D a(EnumSet<EnumDirection.EnumAxis> enumset) {
+        double d0 = enumset.contains(EnumDirection.EnumAxis.X) ? (double) MathHelper.floor(this.x) : this.x;
+        double d1 = enumset.contains(EnumDirection.EnumAxis.Y) ? (double) MathHelper.floor(this.y) : this.y;
+        double d2 = enumset.contains(EnumDirection.EnumAxis.Z) ? (double) MathHelper.floor(this.z) : this.z;
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    public double a(EnumDirection.EnumAxis enumdirection_enumaxis) {
+        return enumdirection_enumaxis.a(this.x, this.y, this.z);
+    }
+
+    @Override
+    public final double getX() {
+        return this.x;
+    }
+
+    @Override
+    public final double getY() {
+        return this.y;
+    }
+
+    @Override
+    public final double getZ() {
+        return this.z;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/phys/shapes/VoxelShape.java b/src/main/java/net/minecraft/world/phys/shapes/VoxelShape.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b82349b96b3ec9490d06d1c1d1cbf2b1578d313
--- /dev/null
+++ b/src/main/java/net/minecraft/world/phys/shapes/VoxelShape.java
@@ -0,0 +1,218 @@
+package net.minecraft.world.phys.shapes;
+
+import com.google.common.collect.Lists;
+import com.google.common.math.DoubleMath;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumAxisCycle;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.phys.AxisAlignedBB;
+import net.minecraft.world.phys.MovingObjectPositionBlock;
+import net.minecraft.world.phys.Vec3D;
+
+public abstract class VoxelShape {
+
+    protected final VoxelShapeDiscrete a;
+    @Nullable
+    private VoxelShape[] b;
+
+    VoxelShape(VoxelShapeDiscrete voxelshapediscrete) {
+        this.a = voxelshapediscrete;
+    }
+
+    public double b(EnumDirection.EnumAxis enumdirection_enumaxis) {
+        int i = this.a.a(enumdirection_enumaxis);
+
+        return i >= this.a.c(enumdirection_enumaxis) ? Double.POSITIVE_INFINITY : this.a(enumdirection_enumaxis, i);
+    }
+
+    public double c(EnumDirection.EnumAxis enumdirection_enumaxis) {
+        int i = this.a.b(enumdirection_enumaxis);
+
+        return i <= 0 ? Double.NEGATIVE_INFINITY : this.a(enumdirection_enumaxis, i);
+    }
+
+    public AxisAlignedBB getBoundingBox() {
+        if (this.isEmpty()) {
+            throw (UnsupportedOperationException) SystemUtils.c((Throwable) (new UnsupportedOperationException("No bounds for empty shape.")));
+        } else {
+            return new AxisAlignedBB(this.b(EnumDirection.EnumAxis.X), this.b(EnumDirection.EnumAxis.Y), this.b(EnumDirection.EnumAxis.Z), this.c(EnumDirection.EnumAxis.X), this.c(EnumDirection.EnumAxis.Y), this.c(EnumDirection.EnumAxis.Z));
+        }
+    }
+
+    protected double a(EnumDirection.EnumAxis enumdirection_enumaxis, int i) {
+        return this.a(enumdirection_enumaxis).getDouble(i);
+    }
+
+    protected abstract DoubleList a(EnumDirection.EnumAxis enumdirection_enumaxis);
+
+    public boolean isEmpty() {
+        return this.a.a();
+    }
+
+    public VoxelShape a(double d0, double d1, double d2) {
+        return (VoxelShape) (this.isEmpty() ? VoxelShapes.a() : new VoxelShapeArray(this.a, new DoubleListOffset(this.a(EnumDirection.EnumAxis.X), d0), new DoubleListOffset(this.a(EnumDirection.EnumAxis.Y), d1), new DoubleListOffset(this.a(EnumDirection.EnumAxis.Z), d2)));
+    }
+
+    public VoxelShape c() {
+        VoxelShape[] avoxelshape = new VoxelShape[]{VoxelShapes.a()};
+
+        this.b((d0, d1, d2, d3, d4, d5) -> {
+            avoxelshape[0] = VoxelShapes.b(avoxelshape[0], VoxelShapes.create(d0, d1, d2, d3, d4, d5), OperatorBoolean.OR);
+        });
+        return avoxelshape[0];
+    }
+
+    public void b(VoxelShapes.a voxelshapes_a) {
+        DoubleList doublelist = this.a(EnumDirection.EnumAxis.X);
+        DoubleList doublelist1 = this.a(EnumDirection.EnumAxis.Y);
+        DoubleList doublelist2 = this.a(EnumDirection.EnumAxis.Z);
+
+        this.a.b((i, j, k, l, i1, j1) -> {
+            voxelshapes_a.consume(doublelist.getDouble(i), doublelist1.getDouble(j), doublelist2.getDouble(k), doublelist.getDouble(l), doublelist1.getDouble(i1), doublelist2.getDouble(j1));
+        }, true);
+    }
+
+    public List<AxisAlignedBB> d() {
+        List<AxisAlignedBB> list = Lists.newArrayList();
+
+        this.b((d0, d1, d2, d3, d4, d5) -> {
+            list.add(new AxisAlignedBB(d0, d1, d2, d3, d4, d5));
+        });
+        return list;
+    }
+
+    protected int a(EnumDirection.EnumAxis enumdirection_enumaxis, double d0) {
+        return MathHelper.a(0, this.a.c(enumdirection_enumaxis) + 1, (i) -> {
+            return i < 0 ? false : (i > this.a.c(enumdirection_enumaxis) ? true : d0 < this.a(enumdirection_enumaxis, i));
+        }) - 1;
+    }
+
+    protected boolean b(double d0, double d1, double d2) {
+        return this.a.c(this.a(EnumDirection.EnumAxis.X, d0), this.a(EnumDirection.EnumAxis.Y, d1), this.a(EnumDirection.EnumAxis.Z, d2));
+    }
+
+    @Nullable
+    public MovingObjectPositionBlock rayTrace(Vec3D vec3d, Vec3D vec3d1, BlockPosition blockposition) {
+        if (this.isEmpty()) {
+            return null;
+        } else {
+            Vec3D vec3d2 = vec3d1.d(vec3d);
+
+            if (vec3d2.g() < 1.0E-7D) {
+                return null;
+            } else {
+                Vec3D vec3d3 = vec3d.e(vec3d2.a(0.001D));
+
+                return this.b(vec3d3.x - (double) blockposition.getX(), vec3d3.y - (double) blockposition.getY(), vec3d3.z - (double) blockposition.getZ()) ? new MovingObjectPositionBlock(vec3d3, EnumDirection.a(vec3d2.x, vec3d2.y, vec3d2.z).opposite(), blockposition, true) : AxisAlignedBB.a(this.d(), vec3d, vec3d1, blockposition);
+            }
+        }
+    }
+
+    public VoxelShape a(EnumDirection enumdirection) {
+        if (!this.isEmpty() && this != VoxelShapes.b()) {
+            VoxelShape voxelshape;
+
+            if (this.b != null) {
+                voxelshape = this.b[enumdirection.ordinal()];
+                if (voxelshape != null) {
+                    return voxelshape;
+                }
+            } else {
+                this.b = new VoxelShape[6];
+            }
+
+            voxelshape = this.b(enumdirection);
+            this.b[enumdirection.ordinal()] = voxelshape;
+            return voxelshape;
+        } else {
+            return this;
+        }
+    }
+
+    private VoxelShape b(EnumDirection enumdirection) {
+        EnumDirection.EnumAxis enumdirection_enumaxis = enumdirection.n();
+        EnumDirection.EnumAxisDirection enumdirection_enumaxisdirection = enumdirection.e();
+        DoubleList doublelist = this.a(enumdirection_enumaxis);
+
+        if (doublelist.size() == 2 && DoubleMath.fuzzyEquals(doublelist.getDouble(0), 0.0D, 1.0E-7D) && DoubleMath.fuzzyEquals(doublelist.getDouble(1), 1.0D, 1.0E-7D)) {
+            return this;
+        } else {
+            int i = this.a(enumdirection_enumaxis, enumdirection_enumaxisdirection == EnumDirection.EnumAxisDirection.POSITIVE ? 0.9999999D : 1.0E-7D);
+
+            return new VoxelShapeSlice(this, enumdirection_enumaxis, i);
+        }
+    }
+
+    public double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, double d0) {
+        return this.a(EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.X), axisalignedbb, d0);
+    }
+
+    protected double a(EnumAxisCycle enumaxiscycle, AxisAlignedBB axisalignedbb, double d0) {
+        if (this.isEmpty()) {
+            return d0;
+        } else if (Math.abs(d0) < 1.0E-7D) {
+            return 0.0D;
+        } else {
+            EnumAxisCycle enumaxiscycle1 = enumaxiscycle.a();
+            EnumDirection.EnumAxis enumdirection_enumaxis = enumaxiscycle1.a(EnumDirection.EnumAxis.X);
+            EnumDirection.EnumAxis enumdirection_enumaxis1 = enumaxiscycle1.a(EnumDirection.EnumAxis.Y);
+            EnumDirection.EnumAxis enumdirection_enumaxis2 = enumaxiscycle1.a(EnumDirection.EnumAxis.Z);
+            double d1 = axisalignedbb.b(enumdirection_enumaxis);
+            double d2 = axisalignedbb.a(enumdirection_enumaxis);
+            int i = this.a(enumdirection_enumaxis, d2 + 1.0E-7D);
+            int j = this.a(enumdirection_enumaxis, d1 - 1.0E-7D);
+            int k = Math.max(0, this.a(enumdirection_enumaxis1, axisalignedbb.a(enumdirection_enumaxis1) + 1.0E-7D));
+            int l = Math.min(this.a.c(enumdirection_enumaxis1), this.a(enumdirection_enumaxis1, axisalignedbb.b(enumdirection_enumaxis1) - 1.0E-7D) + 1);
+            int i1 = Math.max(0, this.a(enumdirection_enumaxis2, axisalignedbb.a(enumdirection_enumaxis2) + 1.0E-7D));
+            int j1 = Math.min(this.a.c(enumdirection_enumaxis2), this.a(enumdirection_enumaxis2, axisalignedbb.b(enumdirection_enumaxis2) - 1.0E-7D) + 1);
+            int k1 = this.a.c(enumdirection_enumaxis);
+            double d3;
+            int l1;
+            int i2;
+            int j2;
+
+            if (d0 > 0.0D) {
+                for (l1 = j + 1; l1 < k1; ++l1) {
+                    for (i2 = k; i2 < l; ++i2) {
+                        for (j2 = i1; j2 < j1; ++j2) {
+                            if (this.a.a(enumaxiscycle1, l1, i2, j2)) {
+                                d3 = this.a(enumdirection_enumaxis, l1) - d1;
+                                if (d3 >= -1.0E-7D) {
+                                    d0 = Math.min(d0, d3);
+                                }
+
+                                return d0;
+                            }
+                        }
+                    }
+                }
+            } else if (d0 < 0.0D) {
+                for (l1 = i - 1; l1 >= 0; --l1) {
+                    for (i2 = k; i2 < l; ++i2) {
+                        for (j2 = i1; j2 < j1; ++j2) {
+                            if (this.a.a(enumaxiscycle1, l1, i2, j2)) {
+                                d3 = this.a(enumdirection_enumaxis, l1 + 1) - d2;
+                                if (d3 <= 1.0E-7D) {
+                                    d0 = Math.max(d0, d3);
+                                }
+
+                                return d0;
+                            }
+                        }
+                    }
+                }
+            }
+
+            return d0;
+        }
+    }
+
+    public String toString() {
+        return this.isEmpty() ? "EMPTY" : "VoxelShape[" + this.getBoundingBox() + "]";
+    }
+}
diff --git a/src/main/java/net/minecraft/world/phys/shapes/VoxelShapeArray.java b/src/main/java/net/minecraft/world/phys/shapes/VoxelShapeArray.java
new file mode 100644
index 0000000000000000000000000000000000000000..56f0b3a74f676d288d81671a4791337e169b9758
--- /dev/null
+++ b/src/main/java/net/minecraft/world/phys/shapes/VoxelShapeArray.java
@@ -0,0 +1,47 @@
+package net.minecraft.world.phys.shapes;
+
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+import java.util.Arrays;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.EnumDirection;
+
+public final class VoxelShapeArray extends VoxelShape {
+
+    private final DoubleList b;
+    private final DoubleList c;
+    private final DoubleList d;
+
+    protected VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, double[] adouble, double[] adouble1, double[] adouble2) {
+        this(voxelshapediscrete, (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble, voxelshapediscrete.b() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble1, voxelshapediscrete.c() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble2, voxelshapediscrete.d() + 1)));
+    }
+
+    VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, DoubleList doublelist, DoubleList doublelist1, DoubleList doublelist2) {
+        super(voxelshapediscrete);
+        int i = voxelshapediscrete.b() + 1;
+        int j = voxelshapediscrete.c() + 1;
+        int k = voxelshapediscrete.d() + 1;
+
+        if (i == doublelist.size() && j == doublelist1.size() && k == doublelist2.size()) {
+            this.b = doublelist;
+            this.c = doublelist1;
+            this.d = doublelist2;
+        } else {
+            throw (IllegalArgumentException) SystemUtils.c((Throwable) (new IllegalArgumentException("Lengths of point arrays must be consistent with the size of the VoxelShape.")));
+        }
+    }
+
+    @Override
+    protected DoubleList a(EnumDirection.EnumAxis enumdirection_enumaxis) {
+        switch (enumdirection_enumaxis) {
+            case X:
+                return this.b;
+            case Y:
+                return this.c;
+            case Z:
+                return this.d;
+            default:
+                throw new IllegalArgumentException();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/phys/shapes/VoxelShapeMergerList.java b/src/main/java/net/minecraft/world/phys/shapes/VoxelShapeMergerList.java
new file mode 100644
index 0000000000000000000000000000000000000000..afd30320da51bf467d66e94f682936ed8db96d90
--- /dev/null
+++ b/src/main/java/net/minecraft/world/phys/shapes/VoxelShapeMergerList.java
@@ -0,0 +1,69 @@
+package net.minecraft.world.phys.shapes;
+
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+
+public final class VoxelShapeMergerList implements VoxelShapeMerger {
+
+    private final DoubleArrayList a;
+    private final IntArrayList b;
+    private final IntArrayList c;
+
+    protected VoxelShapeMergerList(DoubleList doublelist, DoubleList doublelist1, boolean flag, boolean flag1) {
+        int i = 0;
+        int j = 0;
+        double d0 = Double.NaN;
+        int k = doublelist.size();
+        int l = doublelist1.size();
+        int i1 = k + l;
+
+        this.a = new DoubleArrayList(i1);
+        this.b = new IntArrayList(i1);
+        this.c = new IntArrayList(i1);
+
+        while (true) {
+            boolean flag2 = i < k;
+            boolean flag3 = j < l;
+
+            if (!flag2 && !flag3) {
+                if (this.a.isEmpty()) {
+                    this.a.add(Math.min(doublelist.getDouble(k - 1), doublelist1.getDouble(l - 1)));
+                }
+
+                return;
+            }
+
+            boolean flag4 = flag2 && (!flag3 || doublelist.getDouble(i) < doublelist1.getDouble(j) + 1.0E-7D);
+            double d1 = flag4 ? doublelist.getDouble(i++) : doublelist1.getDouble(j++);
+
+            if ((i != 0 && flag2 || flag4 || flag1) && (j != 0 && flag3 || !flag4 || flag)) {
+                if (d0 < d1 - 1.0E-7D) {
+                    this.b.add(i - 1);
+                    this.c.add(j - 1);
+                    this.a.add(d1);
+                    d0 = d1;
+                } else if (!this.a.isEmpty()) {
+                    this.b.set(this.b.size() - 1, i - 1);
+                    this.c.set(this.c.size() - 1, j - 1);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean a(VoxelShapeMerger.a voxelshapemerger_a) {
+        for (int i = 0; i < this.a.size() - 1; ++i) {
+            if (!voxelshapemerger_a.merge(this.b.getInt(i), this.c.getInt(i), i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public DoubleList a() {
+        return this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/phys/shapes/VoxelShapes.java b/src/main/java/net/minecraft/world/phys/shapes/VoxelShapes.java
new file mode 100644
index 0000000000000000000000000000000000000000..44d37272a337fee9606ebaa1b6f647c0fd392320
--- /dev/null
+++ b/src/main/java/net/minecraft/world/phys/shapes/VoxelShapes.java
@@ -0,0 +1,346 @@
+package net.minecraft.world.phys.shapes;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.math.DoubleMath;
+import com.google.common.math.IntMath;
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.Objects;
+import java.util.stream.Stream;
+import net.minecraft.SystemUtils;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.core.EnumAxisCycle;
+import net.minecraft.core.EnumDirection;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.level.IBlockAccess;
+import net.minecraft.world.level.IWorldReader;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.IBlockData;
+import net.minecraft.world.phys.AxisAlignedBB;
+
+public final class VoxelShapes {
+
+    private static final VoxelShape b = (VoxelShape) SystemUtils.a(() -> {
+        VoxelShapeBitSet voxelshapebitset = new VoxelShapeBitSet(1, 1, 1);
+
+        voxelshapebitset.a(0, 0, 0, true, true);
+        return new VoxelShapeCube(voxelshapebitset);
+    });
+    public static final VoxelShape a = create(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
+    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}));
+
+    public static VoxelShape a() {
+        return VoxelShapes.c;
+    }
+
+    public static VoxelShape b() {
+        return VoxelShapes.b;
+    }
+
+    public static VoxelShape create(double d0, double d1, double d2, double d3, double d4, double d5) {
+        return a(new AxisAlignedBB(d0, d1, d2, d3, d4, d5));
+    }
+
+    public static VoxelShape a(AxisAlignedBB axisalignedbb) {
+        int i = a(axisalignedbb.minX, axisalignedbb.maxX);
+        int j = a(axisalignedbb.minY, axisalignedbb.maxY);
+        int k = a(axisalignedbb.minZ, axisalignedbb.maxZ);
+
+        if (i >= 0 && j >= 0 && k >= 0) {
+            if (i == 0 && j == 0 && k == 0) {
+                return axisalignedbb.e(0.5D, 0.5D, 0.5D) ? b() : a();
+            } else {
+                int l = 1 << i;
+                int i1 = 1 << j;
+                int j1 = 1 << k;
+                int k1 = (int) Math.round(axisalignedbb.minX * (double) l);
+                int l1 = (int) Math.round(axisalignedbb.maxX * (double) l);
+                int i2 = (int) Math.round(axisalignedbb.minY * (double) i1);
+                int j2 = (int) Math.round(axisalignedbb.maxY * (double) i1);
+                int k2 = (int) Math.round(axisalignedbb.minZ * (double) j1);
+                int l2 = (int) Math.round(axisalignedbb.maxZ * (double) j1);
+                VoxelShapeBitSet voxelshapebitset = new VoxelShapeBitSet(l, i1, j1, k1, i2, k2, l1, j2, l2);
+
+                for (long i3 = (long) k1; i3 < (long) l1; ++i3) {
+                    for (long j3 = (long) i2; j3 < (long) j2; ++j3) {
+                        for (long k3 = (long) k2; k3 < (long) l2; ++k3) {
+                            voxelshapebitset.a((int) i3, (int) j3, (int) k3, false, true);
+                        }
+                    }
+                }
+
+                return new VoxelShapeCube(voxelshapebitset);
+            }
+        } else {
+            return new VoxelShapeArray(VoxelShapes.b.a, new double[]{axisalignedbb.minX, axisalignedbb.maxX}, new double[]{axisalignedbb.minY, axisalignedbb.maxY}, new double[]{axisalignedbb.minZ, axisalignedbb.maxZ});
+        }
+    }
+
+    private static int a(double d0, double d1) {
+        if (d0 >= -1.0E-7D && d1 <= 1.0000001D) {
+            for (int i = 0; i <= 3; ++i) {
+                double d2 = d0 * (double) (1 << i);
+                double d3 = d1 * (double) (1 << i);
+                boolean flag = Math.abs(d2 - Math.floor(d2)) < 1.0E-7D;
+                boolean flag1 = Math.abs(d3 - Math.floor(d3)) < 1.0E-7D;
+
+                if (flag && flag1) {
+                    return i;
+                }
+            }
+
+            return -1;
+        } else {
+            return -1;
+        }
+    }
+
+    protected static long a(int i, int j) {
+        return (long) i * (long) (j / IntMath.gcd(i, j));
+    }
+
+    public static VoxelShape a(VoxelShape voxelshape, VoxelShape voxelshape1) {
+        return a(voxelshape, voxelshape1, OperatorBoolean.OR);
+    }
+
+    public static VoxelShape a(VoxelShape voxelshape, VoxelShape... avoxelshape) {
+        return (VoxelShape) Arrays.stream(avoxelshape).reduce(voxelshape, VoxelShapes::a);
+    }
+
+    public static VoxelShape a(VoxelShape voxelshape, VoxelShape voxelshape1, OperatorBoolean operatorboolean) {
+        return b(voxelshape, voxelshape1, operatorboolean).c();
+    }
+
+    public static VoxelShape b(VoxelShape voxelshape, VoxelShape voxelshape1, OperatorBoolean operatorboolean) {
+        if (operatorboolean.apply(false, false)) {
+            throw (IllegalArgumentException) SystemUtils.c((Throwable) (new IllegalArgumentException()));
+        } else if (voxelshape == voxelshape1) {
+            return operatorboolean.apply(true, true) ? voxelshape : a();
+        } else {
+            boolean flag = operatorboolean.apply(true, false);
+            boolean flag1 = operatorboolean.apply(false, true);
+
+            if (voxelshape.isEmpty()) {
+                return flag1 ? voxelshape1 : a();
+            } else if (voxelshape1.isEmpty()) {
+                return flag ? voxelshape : a();
+            } else {
+                VoxelShapeMerger voxelshapemerger = a(1, voxelshape.a(EnumDirection.EnumAxis.X), voxelshape1.a(EnumDirection.EnumAxis.X), flag, flag1);
+                VoxelShapeMerger voxelshapemerger1 = a(voxelshapemerger.a().size() - 1, voxelshape.a(EnumDirection.EnumAxis.Y), voxelshape1.a(EnumDirection.EnumAxis.Y), flag, flag1);
+                VoxelShapeMerger voxelshapemerger2 = a((voxelshapemerger.a().size() - 1) * (voxelshapemerger1.a().size() - 1), voxelshape.a(EnumDirection.EnumAxis.Z), voxelshape1.a(EnumDirection.EnumAxis.Z), flag, flag1);
+                VoxelShapeBitSet voxelshapebitset = VoxelShapeBitSet.a(voxelshape.a, voxelshape1.a, voxelshapemerger, voxelshapemerger1, voxelshapemerger2, operatorboolean);
+
+                return (VoxelShape) (voxelshapemerger instanceof VoxelShapeCubeMerger && voxelshapemerger1 instanceof VoxelShapeCubeMerger && voxelshapemerger2 instanceof VoxelShapeCubeMerger ? new VoxelShapeCube(voxelshapebitset) : new VoxelShapeArray(voxelshapebitset, voxelshapemerger.a(), voxelshapemerger1.a(), voxelshapemerger2.a()));
+            }
+        }
+    }
+
+    public static boolean c(VoxelShape voxelshape, VoxelShape voxelshape1, OperatorBoolean operatorboolean) {
+        if (operatorboolean.apply(false, false)) {
+            throw (IllegalArgumentException) SystemUtils.c((Throwable) (new IllegalArgumentException()));
+        } else if (voxelshape == voxelshape1) {
+            return operatorboolean.apply(true, true);
+        } else if (voxelshape.isEmpty()) {
+            return operatorboolean.apply(false, !voxelshape1.isEmpty());
+        } else if (voxelshape1.isEmpty()) {
+            return operatorboolean.apply(!voxelshape.isEmpty(), false);
+        } else {
+            boolean flag = operatorboolean.apply(true, false);
+            boolean flag1 = operatorboolean.apply(false, true);
+            EnumDirection.EnumAxis[] aenumdirection_enumaxis = EnumAxisCycle.d;
+            int i = aenumdirection_enumaxis.length;
+
+            for (int j = 0; j < i; ++j) {
+                EnumDirection.EnumAxis enumdirection_enumaxis = aenumdirection_enumaxis[j];
+
+                if (voxelshape.c(enumdirection_enumaxis) < voxelshape1.b(enumdirection_enumaxis) - 1.0E-7D) {
+                    return flag || flag1;
+                }
+
+                if (voxelshape1.c(enumdirection_enumaxis) < voxelshape.b(enumdirection_enumaxis) - 1.0E-7D) {
+                    return flag || flag1;
+                }
+            }
+
+            VoxelShapeMerger voxelshapemerger = a(1, voxelshape.a(EnumDirection.EnumAxis.X), voxelshape1.a(EnumDirection.EnumAxis.X), flag, flag1);
+            VoxelShapeMerger voxelshapemerger1 = a(voxelshapemerger.a().size() - 1, voxelshape.a(EnumDirection.EnumAxis.Y), voxelshape1.a(EnumDirection.EnumAxis.Y), flag, flag1);
+            VoxelShapeMerger voxelshapemerger2 = a((voxelshapemerger.a().size() - 1) * (voxelshapemerger1.a().size() - 1), voxelshape.a(EnumDirection.EnumAxis.Z), voxelshape1.a(EnumDirection.EnumAxis.Z), flag, flag1);
+
+            return a(voxelshapemerger, voxelshapemerger1, voxelshapemerger2, voxelshape.a, voxelshape1.a, operatorboolean);
+        }
+    }
+
+    private static boolean a(VoxelShapeMerger voxelshapemerger, VoxelShapeMerger voxelshapemerger1, VoxelShapeMerger voxelshapemerger2, VoxelShapeDiscrete voxelshapediscrete, VoxelShapeDiscrete voxelshapediscrete1, OperatorBoolean operatorboolean) {
+        return !voxelshapemerger.a((i, j, k) -> {
+            return voxelshapemerger1.a((l, i1, j1) -> {
+                return voxelshapemerger2.a((k1, l1, i2) -> {
+                    return !operatorboolean.apply(voxelshapediscrete.c(i, l, k1), voxelshapediscrete1.c(j, i1, l1));
+                });
+            });
+        });
+    }
+
+    public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, Stream<VoxelShape> stream, double d0) {
+        for (Iterator iterator = stream.iterator(); iterator.hasNext(); d0 = ((VoxelShape) iterator.next()).a(enumdirection_enumaxis, axisalignedbb, d0)) {
+            if (Math.abs(d0) < 1.0E-7D) {
+                return 0.0D;
+            }
+        }
+
+        return d0;
+    }
+
+    public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, Stream<VoxelShape> stream) {
+        return a(axisalignedbb, iworldreader, d0, voxelshapecollision, EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.Z), stream);
+    }
+
+    private static double a(AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, EnumAxisCycle enumaxiscycle, Stream<VoxelShape> stream) {
+        if (axisalignedbb.b() >= 1.0E-6D && axisalignedbb.c() >= 1.0E-6D && axisalignedbb.d() >= 1.0E-6D) {
+            if (Math.abs(d0) < 1.0E-7D) {
+                return 0.0D;
+            } else {
+                EnumAxisCycle enumaxiscycle1 = enumaxiscycle.a();
+                EnumDirection.EnumAxis enumdirection_enumaxis = enumaxiscycle1.a(EnumDirection.EnumAxis.X);
+                EnumDirection.EnumAxis enumdirection_enumaxis1 = enumaxiscycle1.a(EnumDirection.EnumAxis.Y);
+                EnumDirection.EnumAxis enumdirection_enumaxis2 = enumaxiscycle1.a(EnumDirection.EnumAxis.Z);
+                BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+                int i = MathHelper.floor(axisalignedbb.a(enumdirection_enumaxis) - 1.0E-7D) - 1;
+                int j = MathHelper.floor(axisalignedbb.b(enumdirection_enumaxis) + 1.0E-7D) + 1;
+                int k = MathHelper.floor(axisalignedbb.a(enumdirection_enumaxis1) - 1.0E-7D) - 1;
+                int l = MathHelper.floor(axisalignedbb.b(enumdirection_enumaxis1) + 1.0E-7D) + 1;
+                double d1 = axisalignedbb.a(enumdirection_enumaxis2) - 1.0E-7D;
+                double d2 = axisalignedbb.b(enumdirection_enumaxis2) + 1.0E-7D;
+                boolean flag = d0 > 0.0D;
+                int i1 = flag ? MathHelper.floor(axisalignedbb.b(enumdirection_enumaxis2) - 1.0E-7D) - 1 : MathHelper.floor(axisalignedbb.a(enumdirection_enumaxis2) + 1.0E-7D) + 1;
+                int j1 = a(d0, d1, d2);
+                int k1 = flag ? 1 : -1;
+                int l1 = i1;
+
+                while (true) {
+                    if (flag) {
+                        if (l1 > j1) {
+                            break;
+                        }
+                    } else if (l1 < j1) {
+                        break;
+                    }
+
+                    for (int i2 = i; i2 <= j; ++i2) {
+                        for (int j2 = k; j2 <= l; ++j2) {
+                            int k2 = 0;
+
+                            if (i2 == i || i2 == j) {
+                                ++k2;
+                            }
+
+                            if (j2 == k || j2 == l) {
+                                ++k2;
+                            }
+
+                            if (l1 == i1 || l1 == j1) {
+                                ++k2;
+                            }
+
+                            if (k2 < 3) {
+                                blockposition_mutableblockposition.a(enumaxiscycle1, i2, j2, l1);
+                                IBlockData iblockdata = iworldreader.getType(blockposition_mutableblockposition);
+
+                                if ((k2 != 1 || iblockdata.d()) && (k2 != 2 || iblockdata.a(Blocks.MOVING_PISTON))) {
+                                    d0 = iblockdata.b((IBlockAccess) iworldreader, blockposition_mutableblockposition, voxelshapecollision).a(enumdirection_enumaxis2, axisalignedbb.d((double) (-blockposition_mutableblockposition.getX()), (double) (-blockposition_mutableblockposition.getY()), (double) (-blockposition_mutableblockposition.getZ())), d0);
+                                    if (Math.abs(d0) < 1.0E-7D) {
+                                        return 0.0D;
+                                    }
+
+                                    j1 = a(d0, d1, d2);
+                                }
+                            }
+                        }
+                    }
+
+                    l1 += k1;
+                }
+
+                double[] adouble = new double[]{d0};
+
+                stream.forEach((voxelshape) -> {
+                    adouble[0] = voxelshape.a(enumdirection_enumaxis2, axisalignedbb, adouble[0]);
+                });
+                return adouble[0];
+            }
+        } else {
+            return d0;
+        }
+    }
+
+    private static int a(double d0, double d1, double d2) {
+        return d0 > 0.0D ? MathHelper.floor(d2 + d0) + 1 : MathHelper.floor(d1 + d0) - 1;
+    }
+
+    public static VoxelShape a(VoxelShape voxelshape, EnumDirection enumdirection) {
+        if (voxelshape == b()) {
+            return b();
+        } else {
+            EnumDirection.EnumAxis enumdirection_enumaxis = enumdirection.n();
+            boolean flag;
+            int i;
+
+            if (enumdirection.e() == EnumDirection.EnumAxisDirection.POSITIVE) {
+                flag = DoubleMath.fuzzyEquals(voxelshape.c(enumdirection_enumaxis), 1.0D, 1.0E-7D);
+                i = voxelshape.a.c(enumdirection_enumaxis) - 1;
+            } else {
+                flag = DoubleMath.fuzzyEquals(voxelshape.b(enumdirection_enumaxis), 0.0D, 1.0E-7D);
+                i = 0;
+            }
+
+            return (VoxelShape) (!flag ? a() : new VoxelShapeSlice(voxelshape, enumdirection_enumaxis, i));
+        }
+    }
+
+    public static boolean b(VoxelShape voxelshape, VoxelShape voxelshape1, EnumDirection enumdirection) {
+        if (voxelshape != b() && voxelshape1 != b()) {
+            EnumDirection.EnumAxis enumdirection_enumaxis = enumdirection.n();
+            EnumDirection.EnumAxisDirection enumdirection_enumaxisdirection = enumdirection.e();
+            VoxelShape voxelshape2 = enumdirection_enumaxisdirection == EnumDirection.EnumAxisDirection.POSITIVE ? voxelshape : voxelshape1;
+            VoxelShape voxelshape3 = enumdirection_enumaxisdirection == EnumDirection.EnumAxisDirection.POSITIVE ? voxelshape1 : voxelshape;
+
+            if (!DoubleMath.fuzzyEquals(voxelshape2.c(enumdirection_enumaxis), 1.0D, 1.0E-7D)) {
+                voxelshape2 = a();
+            }
+
+            if (!DoubleMath.fuzzyEquals(voxelshape3.b(enumdirection_enumaxis), 0.0D, 1.0E-7D)) {
+                voxelshape3 = a();
+            }
+
+            return !c(b(), b(new VoxelShapeSlice(voxelshape2, enumdirection_enumaxis, voxelshape2.a.c(enumdirection_enumaxis) - 1), new VoxelShapeSlice(voxelshape3, enumdirection_enumaxis, 0), OperatorBoolean.OR), OperatorBoolean.ONLY_FIRST);
+        } else {
+            return true;
+        }
+    }
+
+    public static boolean b(VoxelShape voxelshape, VoxelShape voxelshape1) {
+        return voxelshape != b() && voxelshape1 != b() ? (voxelshape.isEmpty() && voxelshape1.isEmpty() ? false : !c(b(), b(voxelshape, voxelshape1, OperatorBoolean.OR), OperatorBoolean.ONLY_FIRST)) : true;
+    }
+
+    @VisibleForTesting
+    protected static VoxelShapeMerger a(int i, DoubleList doublelist, DoubleList doublelist1, boolean flag, boolean flag1) {
+        int j = doublelist.size() - 1;
+        int k = doublelist1.size() - 1;
+
+        if (doublelist instanceof VoxelShapeCubePoint && doublelist1 instanceof VoxelShapeCubePoint) {
+            long l = a(j, k);
+
+            if ((long) i * l <= 256L) {
+                return new VoxelShapeCubeMerger(j, k);
+            }
+        }
+
+        return (VoxelShapeMerger) (doublelist.getDouble(j) < doublelist1.getDouble(0) - 1.0E-7D ? new VoxelShapeMergerDisjoint(doublelist, doublelist1, false) : (doublelist1.getDouble(k) < doublelist.getDouble(0) - 1.0E-7D ? new VoxelShapeMergerDisjoint(doublelist1, doublelist, true) : (j == k && Objects.equals(doublelist, doublelist1) ? (doublelist instanceof VoxelShapeMergerIdentical ? (VoxelShapeMerger) doublelist : (doublelist1 instanceof VoxelShapeMergerIdentical ? (VoxelShapeMerger) doublelist1 : new VoxelShapeMergerIdentical(doublelist))) : new VoxelShapeMergerList(doublelist, doublelist1, flag, flag1))));
+    }
+
+    public interface a {
+
+        void consume(double d0, double d1, double d2, double d3, double d4, double d5);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/scores/PersistentScoreboard.java b/src/main/java/net/minecraft/world/scores/PersistentScoreboard.java
new file mode 100644
index 0000000000000000000000000000000000000000..3998565ccd87c966c0fb9e6757cd1861faa5bc15
--- /dev/null
+++ b/src/main/java/net/minecraft/world/scores/PersistentScoreboard.java
@@ -0,0 +1,256 @@
+package net.minecraft.world.scores;
+
+import java.util.Collection;
+import java.util.Iterator;
+import net.minecraft.EnumChatFormat;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.nbt.NBTTagList;
+import net.minecraft.nbt.NBTTagString;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.network.chat.IChatMutableComponent;
+import net.minecraft.world.level.saveddata.PersistentBase;
+import net.minecraft.world.scores.criteria.IScoreboardCriteria;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class PersistentScoreboard extends PersistentBase {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private Scoreboard b;
+    private NBTTagCompound c;
+
+    public PersistentScoreboard() {
+        super("scoreboard");
+    }
+
+    public void a(Scoreboard scoreboard) {
+        this.b = scoreboard;
+        if (this.c != null) {
+            this.a(this.c);
+        }
+
+    }
+
+    @Override
+    public void a(NBTTagCompound nbttagcompound) {
+        if (this.b == null) {
+            this.c = nbttagcompound;
+        } else {
+            this.b(nbttagcompound.getList("Objectives", 10));
+            this.b.a(nbttagcompound.getList("PlayerScores", 10));
+            if (nbttagcompound.hasKeyOfType("DisplaySlots", 10)) {
+                this.c(nbttagcompound.getCompound("DisplaySlots"));
+            }
+
+            if (nbttagcompound.hasKeyOfType("Teams", 9)) {
+                this.a(nbttagcompound.getList("Teams", 10));
+            }
+
+        }
+    }
+
+    protected void a(NBTTagList nbttaglist) {
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound = nbttaglist.getCompound(i);
+            String s = nbttagcompound.getString("Name");
+
+            if (s.length() > 16) {
+                s = s.substring(0, 16);
+            }
+
+            ScoreboardTeam scoreboardteam = this.b.createTeam(s);
+            IChatMutableComponent ichatmutablecomponent = IChatBaseComponent.ChatSerializer.a(nbttagcompound.getString("DisplayName"));
+
+            if (ichatmutablecomponent != null) {
+                scoreboardteam.setDisplayName(ichatmutablecomponent);
+            }
+
+            if (nbttagcompound.hasKeyOfType("TeamColor", 8)) {
+                scoreboardteam.setColor(EnumChatFormat.b(nbttagcompound.getString("TeamColor")));
+            }
+
+            if (nbttagcompound.hasKeyOfType("AllowFriendlyFire", 99)) {
+                scoreboardteam.setAllowFriendlyFire(nbttagcompound.getBoolean("AllowFriendlyFire"));
+            }
+
+            if (nbttagcompound.hasKeyOfType("SeeFriendlyInvisibles", 99)) {
+                scoreboardteam.setCanSeeFriendlyInvisibles(nbttagcompound.getBoolean("SeeFriendlyInvisibles"));
+            }
+
+            IChatMutableComponent ichatmutablecomponent1;
+
+            if (nbttagcompound.hasKeyOfType("MemberNamePrefix", 8)) {
+                ichatmutablecomponent1 = IChatBaseComponent.ChatSerializer.a(nbttagcompound.getString("MemberNamePrefix"));
+                if (ichatmutablecomponent1 != null) {
+                    scoreboardteam.setPrefix(ichatmutablecomponent1);
+                }
+            }
+
+            if (nbttagcompound.hasKeyOfType("MemberNameSuffix", 8)) {
+                ichatmutablecomponent1 = IChatBaseComponent.ChatSerializer.a(nbttagcompound.getString("MemberNameSuffix"));
+                if (ichatmutablecomponent1 != null) {
+                    scoreboardteam.setSuffix(ichatmutablecomponent1);
+                }
+            }
+
+            ScoreboardTeamBase.EnumNameTagVisibility scoreboardteambase_enumnametagvisibility;
+
+            if (nbttagcompound.hasKeyOfType("NameTagVisibility", 8)) {
+                scoreboardteambase_enumnametagvisibility = ScoreboardTeamBase.EnumNameTagVisibility.a(nbttagcompound.getString("NameTagVisibility"));
+                if (scoreboardteambase_enumnametagvisibility != null) {
+                    scoreboardteam.setNameTagVisibility(scoreboardteambase_enumnametagvisibility);
+                }
+            }
+
+            if (nbttagcompound.hasKeyOfType("DeathMessageVisibility", 8)) {
+                scoreboardteambase_enumnametagvisibility = ScoreboardTeamBase.EnumNameTagVisibility.a(nbttagcompound.getString("DeathMessageVisibility"));
+                if (scoreboardteambase_enumnametagvisibility != null) {
+                    scoreboardteam.setDeathMessageVisibility(scoreboardteambase_enumnametagvisibility);
+                }
+            }
+
+            if (nbttagcompound.hasKeyOfType("CollisionRule", 8)) {
+                ScoreboardTeamBase.EnumTeamPush scoreboardteambase_enumteampush = ScoreboardTeamBase.EnumTeamPush.a(nbttagcompound.getString("CollisionRule"));
+
+                if (scoreboardteambase_enumteampush != null) {
+                    scoreboardteam.setCollisionRule(scoreboardteambase_enumteampush);
+                }
+            }
+
+            this.a(scoreboardteam, nbttagcompound.getList("Players", 8));
+        }
+
+    }
+
+    protected void a(ScoreboardTeam scoreboardteam, NBTTagList nbttaglist) {
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            this.b.addPlayerToTeam(nbttaglist.getString(i), scoreboardteam);
+        }
+
+    }
+
+    protected void c(NBTTagCompound nbttagcompound) {
+        for (int i = 0; i < 19; ++i) {
+            if (nbttagcompound.hasKeyOfType("slot_" + i, 8)) {
+                String s = nbttagcompound.getString("slot_" + i);
+                ScoreboardObjective scoreboardobjective = this.b.getObjective(s);
+
+                this.b.setDisplaySlot(i, scoreboardobjective);
+            }
+        }
+
+    }
+
+    protected void b(NBTTagList nbttaglist) {
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound = nbttaglist.getCompound(i);
+
+            IScoreboardCriteria.a(nbttagcompound.getString("CriteriaName")).ifPresent((iscoreboardcriteria) -> {
+                String s = nbttagcompound.getString("Name");
+
+                if (s.length() > 16) {
+                    s = s.substring(0, 16);
+                }
+
+                IChatMutableComponent ichatmutablecomponent = IChatBaseComponent.ChatSerializer.a(nbttagcompound.getString("DisplayName"));
+                IScoreboardCriteria.EnumScoreboardHealthDisplay iscoreboardcriteria_enumscoreboardhealthdisplay = IScoreboardCriteria.EnumScoreboardHealthDisplay.a(nbttagcompound.getString("RenderType"));
+
+                this.b.registerObjective(s, iscoreboardcriteria, ichatmutablecomponent, iscoreboardcriteria_enumscoreboardhealthdisplay);
+            });
+        }
+
+    }
+
+    @Override
+    public NBTTagCompound b(NBTTagCompound nbttagcompound) {
+        if (this.b == null) {
+            PersistentScoreboard.LOGGER.warn("Tried to save scoreboard without having a scoreboard...");
+            return nbttagcompound;
+        } else {
+            nbttagcompound.set("Objectives", this.e());
+            nbttagcompound.set("PlayerScores", this.b.i());
+            nbttagcompound.set("Teams", this.a());
+            this.d(nbttagcompound);
+            return nbttagcompound;
+        }
+    }
+
+    protected NBTTagList a() {
+        NBTTagList nbttaglist = new NBTTagList();
+        Collection<ScoreboardTeam> collection = this.b.getTeams();
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            ScoreboardTeam scoreboardteam = (ScoreboardTeam) iterator.next();
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+            nbttagcompound.setString("Name", scoreboardteam.getName());
+            nbttagcompound.setString("DisplayName", IChatBaseComponent.ChatSerializer.a(scoreboardteam.getDisplayName()));
+            if (scoreboardteam.getColor().b() >= 0) {
+                nbttagcompound.setString("TeamColor", scoreboardteam.getColor().f());
+            }
+
+            nbttagcompound.setBoolean("AllowFriendlyFire", scoreboardteam.allowFriendlyFire());
+            nbttagcompound.setBoolean("SeeFriendlyInvisibles", scoreboardteam.canSeeFriendlyInvisibles());
+            nbttagcompound.setString("MemberNamePrefix", IChatBaseComponent.ChatSerializer.a(scoreboardteam.getPrefix()));
+            nbttagcompound.setString("MemberNameSuffix", IChatBaseComponent.ChatSerializer.a(scoreboardteam.getSuffix()));
+            nbttagcompound.setString("NameTagVisibility", scoreboardteam.getNameTagVisibility().e);
+            nbttagcompound.setString("DeathMessageVisibility", scoreboardteam.getDeathMessageVisibility().e);
+            nbttagcompound.setString("CollisionRule", scoreboardteam.getCollisionRule().e);
+            NBTTagList nbttaglist1 = new NBTTagList();
+            Iterator iterator1 = scoreboardteam.getPlayerNameSet().iterator();
+
+            while (iterator1.hasNext()) {
+                String s = (String) iterator1.next();
+
+                nbttaglist1.add(NBTTagString.a(s));
+            }
+
+            nbttagcompound.set("Players", nbttaglist1);
+            nbttaglist.add(nbttagcompound);
+        }
+
+        return nbttaglist;
+    }
+
+    protected void d(NBTTagCompound nbttagcompound) {
+        NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+        boolean flag = false;
+
+        for (int i = 0; i < 19; ++i) {
+            ScoreboardObjective scoreboardobjective = this.b.getObjectiveForSlot(i);
+
+            if (scoreboardobjective != null) {
+                nbttagcompound1.setString("slot_" + i, scoreboardobjective.getName());
+                flag = true;
+            }
+        }
+
+        if (flag) {
+            nbttagcompound.set("DisplaySlots", nbttagcompound1);
+        }
+
+    }
+
+    protected NBTTagList e() {
+        NBTTagList nbttaglist = new NBTTagList();
+        Collection<ScoreboardObjective> collection = this.b.getObjectives();
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            ScoreboardObjective scoreboardobjective = (ScoreboardObjective) iterator.next();
+
+            if (scoreboardobjective.getCriteria() != null) {
+                NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+                nbttagcompound.setString("Name", scoreboardobjective.getName());
+                nbttagcompound.setString("CriteriaName", scoreboardobjective.getCriteria().getName());
+                nbttagcompound.setString("DisplayName", IChatBaseComponent.ChatSerializer.a(scoreboardobjective.getDisplayName()));
+                nbttagcompound.setString("RenderType", scoreboardobjective.getRenderType().a());
+                nbttaglist.add(nbttagcompound);
+            }
+        }
+
+        return nbttaglist;
+    }
+}
